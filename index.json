[{"id":3,"pagetitle":"Unfold.jl Documentation","title":"Unfold.jl Documentation","ref":"/UnfoldDocs/Unfold.jl/stable/#Unfold.jl-Documentation","content":" Unfold.jl Documentation Welcome to  Unfold.jl : a Julia Package for regression and event-based time series analysis, with a focus on regression ERPs for EEG analysis. The modular approach allows for easy modification to other context, like iEEG, pupil dilation, fMRI etc. - while maintaining the speed of Julia!"},{"id":4,"pagetitle":"Unfold.jl Documentation","title":"Key features","ref":"/UnfoldDocs/Unfold.jl/stable/#Key-features","content":" Key features Overlap correction:  Multiple ways to model overlap between temporally close events 📈 Regression ERPs:  Fit linear and non-linear predictors, mass univariate models, define contrasts, calculate marginal effects 🧠 Intuitive:  Easy to specify models ( w~i+lcox  formulas), easy to get 🧹 tidy results ⚡ Fast & modular:  Many solvers, GPU support, easily extensible 🌍 Ecosystem:  A diverse ecosystem allows for mixed-models, decoding, statistics, plotting and simulation"},{"id":5,"pagetitle":"Unfold.jl Documentation","title":"Installation","ref":"/UnfoldDocs/Unfold.jl/stable/#Installation","content":" Installation julia> using Pkg; Pkg.add(\"Unfold\") For more detailed instructions please refer to  Installing Julia & Unfold.jl ."},{"id":6,"pagetitle":"Unfold.jl Documentation","title":"Quick start","ref":"/UnfoldDocs/Unfold.jl/stable/#Quick-start","content":" Quick start There are four main model types Timeexpansion  No , Mixed  No   :  fit(UnfoldModel, [Any=>(f, -0.1:0.01:0.5)], evts, data_epoch) Timeexpansion  Yes , Mixed  No  :  fit(UnfoldModel, [Any=>(f, basisfunction)], evts, data) Timeexpansion  No , Mixed  Yes  :  fit(UnfoldModel, [Any=>(fLMM, -0.1:0.01:0.5)], evts, data_epoch) Timeexpansion  Yes , Mixed  Yes :  fit(UnfoldModel, [Any=>(fLMM, basisfunction)], evts, data)"},{"id":7,"pagetitle":"Unfold.jl Documentation","title":"Usage example","ref":"/UnfoldDocs/Unfold.jl/stable/#Usage-example","content":" Usage example"},{"id":8,"pagetitle":"Unfold.jl Documentation","title":"rERP model","ref":"/UnfoldDocs/Unfold.jl/stable/#rERP-model","content":" rERP model using Unfold\nusing UnfoldSim\ndata, evts = UnfoldSim.predef_eeg()\n\nf = @formula 0 ~ 1 + condition\nbasisfunction = firbasis(τ = (-0.1,0.5), sfreq = 100)\nfit(UnfoldModel, [Any=>(f, basisfunction)], evts, data)\nnothing #hide"},{"id":9,"pagetitle":"Unfold.jl Documentation","title":"MixedModels","ref":"/UnfoldDocs/Unfold.jl/stable/#MixedModels","content":" MixedModels It is also possible to fit Linear Mixed Models using the sister-package  UnfoldMixedModels.jl using UnfoldMixedModels\nusing UnfoldSim\ndata, evts = UnfoldSim.predef_eeg(10;return_epoched=true) # 10 subjects\ndata = reshape(data,size(data,1),:) # concatenate subjects\n\ntimes = range(-0.1,0.5,size(data,1)) # arbitrary time-vector\n\nfLMM = @formula 0 ~ 1 + condition + (1|subject) + (1|item)\nfit(UnfoldModel, [Any=>(f, times)], evts, data)\nnothing #hide"},{"id":10,"pagetitle":"Unfold.jl Documentation","title":"Where to start: Learning roadmap","ref":"/UnfoldDocs/Unfold.jl/stable/#Where-to-start:-Learning-roadmap","content":" Where to start: Learning roadmap"},{"id":11,"pagetitle":"Unfold.jl Documentation","title":"1. First step","ref":"/UnfoldDocs/Unfold.jl/stable/#1.-First-step","content":" 1. First step 📌 Goal: First run a mass-univariate analysis, similar to ERPs. Then add the overlap correction. Also very common is to have multiple-events (Stimulus, Response, Fixations etc.) 🔗  first the mass-univariate approach  - then  theoverlap-correction tutorial  -  finally  multiple events"},{"id":12,"pagetitle":"Unfold.jl Documentation","title":"2. Intermediate topics","ref":"/UnfoldDocs/Unfold.jl/stable/#2.-Intermediate-topics","content":" 2. Intermediate topics 📌 Goal: Next familiarize yoursel with marginal effects, and potentially non-linear spline modelling. Defining contrasts can also be helpful  🔗   marginal effects  -  non linear effects  -  contrast coding"},{"id":13,"pagetitle":"Unfold.jl Documentation","title":"3. Advanced topics","ref":"/UnfoldDocs/Unfold.jl/stable/#3.-Advanced-topics","content":" 3. Advanced topics 📌 Goal: There are a lot of advanced topics in Unfold.jl, learn how to use the GPU or outlier-robust solvers, or define your own solver  🔗  GPU and robust models  -  solver definition"},{"id":14,"pagetitle":"Unfold.jl Documentation","title":"Statement of need","ref":"/UnfoldDocs/Unfold.jl/stable/#Statement-of-need","content":" Statement of need"},{"id":17,"pagetitle":"Contributing guidelines","title":"Contributing guidelines","ref":"/UnfoldDocs/Unfold.jl/stable/90-contributing/#contributing","content":" Contributing guidelines First of all, thanks for the interest! We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc. Be polite and respectful, and follow the code of conduct."},{"id":18,"pagetitle":"Contributing guidelines","title":"Bug reports and discussions","ref":"/UnfoldDocs/Unfold.jl/stable/90-contributing/#Bug-reports-and-discussions","content":" Bug reports and discussions If you think you found a bug, feel free to open an  issue . Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please."},{"id":19,"pagetitle":"Contributing guidelines","title":"Working on an issue","ref":"/UnfoldDocs/Unfold.jl/stable/90-contributing/#Working-on-an-issue","content":" Working on an issue If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it. Tip Feel free to ping us after a few days if there are no responses. If your solution involves code (or something that requires running the package locally), check the  developer documentation . Otherwise, you can use the GitHub interface directly to create your pull request."},{"id":22,"pagetitle":"Developer documentation","title":"Developer documentation","ref":"/UnfoldDocs/Unfold.jl/stable/91-developer/#dev_docs","content":" Developer documentation Contributing guidelines If you haven't, please read the  Contributing guidelines  first. If you want to make contributions to this package that involves code, then this guide is for you."},{"id":23,"pagetitle":"Developer documentation","title":"First time clone","ref":"/UnfoldDocs/Unfold.jl/stable/91-developer/#First-time-clone","content":" First time clone If you have writing rights If you have writing rights, you don't have to fork. Instead, simply clone and skip ahead. Whenever  upstream  is mentioned, use  origin  instead. If this is the first time you work with this repository, follow the instructions below to clone the repository. Fork this repo Clone your repo (this will create a  git remote  called  origin ) Add this repo as a remote: git remote add upstream https://github.com/unfoldtoolbox/Unfold.jl This will ensure that you have two remotes in your git:  origin  and  upstream . You will create branches and push to  origin , and you will fetch and update your local  main  branch from  upstream ."},{"id":24,"pagetitle":"Developer documentation","title":"Linting and formatting","ref":"/UnfoldDocs/Unfold.jl/stable/91-developer/#Linting-and-formatting","content":" Linting and formatting Install a plugin on your editor to use  EditorConfig . This will ensure that your editor is configured with important formatting settings. We use  https://pre-commit.com  to run the linters and formatters. In particular, the Julia code is formatted using  JuliaFormatter.jl , so please install it globally first: julia> # Press ]\npkg> activate\npkg> add JuliaFormatter To install  pre-commit , we recommend using  pipx  as follows: # Install pipx following the link\npipx install pre-commit With  pre-commit  installed, activate it as a pre-commit hook: pre-commit install To run the linting and formatting manually, enter the command below: pre-commit run -a Now, you can only commit if all the pre-commit tests pass ."},{"id":25,"pagetitle":"Developer documentation","title":"Testing","ref":"/UnfoldDocs/Unfold.jl/stable/91-developer/#Testing","content":" Testing As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run  test : julia> # press ]\npkg> activate .\npkg> test"},{"id":26,"pagetitle":"Developer documentation","title":"Working on a new issue","ref":"/UnfoldDocs/Unfold.jl/stable/91-developer/#Working-on-a-new-issue","content":" Working on a new issue We try to keep a linear history in this repo, so it is important to keep your branches up-to-date. Fetch from the remote and fast-forward your local main git fetch upstream\ngit switch main\ngit merge --ff-only upstream/main Branch from  main  to address the issue (see below for naming) git switch -c 42-add-answer-universe Push the new local branch to your personal remote repository git push -u origin 42-add-answer-universe Create a pull request to merge your remote branch into the org main."},{"id":27,"pagetitle":"Developer documentation","title":"Branch naming","ref":"/UnfoldDocs/Unfold.jl/stable/91-developer/#Branch-naming","content":" Branch naming If there is an associated issue, add the issue number. If there is no associated issue,  and the changes are small , add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update. If the changes are not small and there is no associated issue, then create the issue first, so we can properly discuss the changes. Use dash separated imperative wording related to the issue (e.g.,  14-add-tests ,  15-fix-model ,  16-remove-obsolete-files )."},{"id":28,"pagetitle":"Developer documentation","title":"Commit message","ref":"/UnfoldDocs/Unfold.jl/stable/91-developer/#Commit-message","content":" Commit message Use imperative or present tense, for instance:  Add feature  or  Fix bug . Have informative titles. When necessary, add a body with details. If there are breaking changes, add the information to the commit message."},{"id":29,"pagetitle":"Developer documentation","title":"Before creating a pull request","ref":"/UnfoldDocs/Unfold.jl/stable/91-developer/#Before-creating-a-pull-request","content":" Before creating a pull request Atomic git commits Try to create \"atomic git commits\" (recommended reading:  The Utopic Git History ). Make sure the tests pass. Make sure the pre-commit tests pass. Fetch any  main  updates from upstream and rebase your branch, if necessary: git fetch upstream\ngit rebase upstream/main BRANCH_NAME Then you can open a pull request and work with the reviewer to address any issues."},{"id":30,"pagetitle":"Developer documentation","title":"Building and viewing the documentation locally","ref":"/UnfoldDocs/Unfold.jl/stable/91-developer/#Building-and-viewing-the-documentation-locally","content":" Building and viewing the documentation locally Following the latest suggestions, we recommend using  LiveServer  to build the documentation. Here is how you do it: Run  julia --project=docs  to open Julia in the environment of the docs. If this is the first time building the docs Press  ]  to enter  pkg  mode Run  pkg> dev .  to use the development version of your package Press backspace to leave  pkg  mode Run  julia> using LiveServer Run  julia> servedocs()"},{"id":33,"pagetitle":"Alternative Solvers (Robust, GPU, B2B)","title":"Alternative Solvers","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/custom_solvers/#custom_solvers","content":" Alternative Solvers A solver takes an Unfold-specified DesignMatrix and the data, and typically solves the equation system  y = Xb  (in the case of Linear Models). There are many different ways how one can approach this problem, depending if the matrix is sparse, if it is 2D or 3D, if one wants to use GPU etc. Most implemented solvers ultimately make use of  solver_main  for their main loop. See the  reference  tutorial for more information if that is interesting to you."},{"id":34,"pagetitle":"Alternative Solvers (Robust, GPU, B2B)","title":"Setup some data","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/custom_solvers/#Setup-some-data","content":" Setup some data using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\ndat, evts = UnfoldSim.predef_eeg(; noiselevel = 10, return_epoched = true)\n\nf = @formula 0 ~ 1 + condition + continuous\ndesignDict = Dict(Any => (f, range(0, 1, length = size(dat, 1))))"},{"id":35,"pagetitle":"Alternative Solvers (Robust, GPU, B2B)","title":"GPU Solvers","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/custom_solvers/#GPU-Solvers","content":" GPU Solvers GPU solvers can significantly speed up your model fitting, with observed improvements of up to a factor of 30-100!"},{"id":36,"pagetitle":"Alternative Solvers (Robust, GPU, B2B)","title":"fastest GPU solver","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/custom_solvers/#fastest-GPU-solver","content":" fastest GPU solver Empirically we found that solving  X'Xb = X'y  is the fastest way to solve for  b . To achieve this, you can run: using CUDA\ngpu_solver =(x, y) -> Unfold.solver_predefined(x, y; solver=:qr)\nm = Unfold.fit(UnfoldModel, designDict, evts, cu(dat), solver = gpu_solver) Where the  cu  is the magic that moves the data to the GPU. Internatlly, the solver function will move the matrix as well and pre-calculate some matrices (especially  X'X ,  X'  and allocate  X'y )."},{"id":37,"pagetitle":"Alternative Solvers (Robust, GPU, B2B)","title":"lsmr GPU solver","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/custom_solvers/#lsmr-GPU-solver","content":" lsmr GPU solver the  Krylov.lsmr  implementation directly solves  y = Xb , but allows for running on the GPU. using Krylov, CUDA # necessary to load the right package extension\ngpu_solver =(x, y) -> Unfold.solver_krylov(x, y; GPU = true)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = gpu_solver) To test it, you will need to run it yourself as we cannot run it on the docs. If you require a different graphicscard vendor than NVIDA/CUDA, please create an issue. Currently, we are unable to test it due to lack of hardware."},{"id":38,"pagetitle":"Alternative Solvers (Robust, GPU, B2B)","title":"Robust Solvers","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/custom_solvers/#Robust-Solvers","content":" Robust Solvers Robust solvers automatically adjust for outlier trials, but they come at a significant computational cost. using RobustModels # necessary to load the Unfold package extension\nse_solver = (x, y) -> Unfold.solver_robust(x, y)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = se_solver)\nresults = coeftable(m)\nplot_erp(results; stderror = true)"},{"id":39,"pagetitle":"Alternative Solvers (Robust, GPU, B2B)","title":"Back2Back regression","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/custom_solvers/#Back2Back-regression","content":" Back2Back regression Since 2025, this solver requires  UnfoldDecode  - please find the tutorial and explanation there, the example here is for historic reasons and will be removed at a later point. using UnfoldDecode\nb2b_solver = (x, y) -> UnfoldDecode.solver_b2b(x, y; ross_val_reps = 5)\ndat_3d = permutedims(repeat(dat, 1, 1, 20), [3 1 2])\nm = Unfold.fit(UnfoldModel, designDict, evts, dat_3d; solver = b2b_solver)\nresults = coeftable(m)\n\nplot_erp(results) These are the decoding results for  conditionA  while considering  conditionB , and vice versa."},{"id":42,"pagetitle":"Multiple events","title":"How to model multiple events","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/multiple_events/#multievent","content":" How to model multiple events When dealing with overlapping data, it is often necessary to model multiple eventtypes (e.g. fixations, stimuli, responses)."},{"id":43,"pagetitle":"Multiple events","title":"Load Example Data","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/multiple_events/#Load-Example-Data","content":" Load Example Data using Unfold\nusing UnfoldMakie, CairoMakie\nusing DataFrames\nusing StatsModels\nusing MixedModels\n\ninclude(joinpath(dirname(pathof(Unfold)), \"../test/test_utilities.jl\")) # to load data\ndat, evts = loadtestdata(\"test_case_4b\");\n\nevts[1:5,:] 5×3 DataFrame Row latency type intercept Int64 String7 Int64 1 38 eventA 1 2 50 eventB 1 3 89 eventA 1 4 102 eventB 1 5 144 eventA 1 The  type  column of table  evts  contains two conditions:  eventA and eventB (if your eventstypes are specified in a different column, you need to define the keywordargument eventcolumn in the fit` command below)"},{"id":44,"pagetitle":"Multiple events","title":"Specify formulas and basisfunctions","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/multiple_events/#Specify-formulas-and-basisfunctions","content":" Specify formulas and basisfunctions bf1 = firbasis(τ = (-0.4, 0.8), sfreq = 50)\nbf2 = firbasis(τ = (-0.2, 1.2), sfreq = 50) For each event, a basis function and formula must be specified. The same basis and formulas may be used. f  = @formula 0 ~ 1 FormulaTerm\nResponse:\n  0\nPredictors:\n  1 For each event, we must specify the formula and basis function to be used. bfDict = [ \"eventA\" => (f, bf1),\n           \"eventB\" => (f, bf2) ] Finally, fitting & plotting works the same way as always m = Unfold.fit(\n    UnfoldModel,\n    bfDict,\n    evts,\n    dat,\n    solver = (x, y) -> Unfold.solver_default(x, y; stderror = true),\n    eventcolumn = \"type\",\n)\nresults = coeftable(m)\nplot_erp(results; stderror = true, mapping = (; col = :eventname))"},{"id":47,"pagetitle":"🐍 Import EEG with PyMNE.jl","title":"Loading Data into Unfold","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/pymne/#Loading-Data-into-Unfold","content":" Loading Data into Unfold Unfold is generally agnostic to how you load your data. You only require a Matrix (channel x time) or 3D-Array(channel x time x epochs) and an event-dataframe."},{"id":48,"pagetitle":"🐍 Import EEG with PyMNE.jl","title":"Setup","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/pymne/#Setup","content":" Setup using Unfold\nusing UnfoldMakie,CairoMakie\nusing PyMNE\nusing DataFrames"},{"id":49,"pagetitle":"🐍 Import EEG with PyMNE.jl","title":"MNE Demo Dataset","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/pymne/#MNE-Demo-Dataset","content":" MNE Demo Dataset The easiest way to showcase this is to simply use a demo-dataset from MNE. limo_epochs = PyMNE.datasets.limo.load_data(subject=1,path=\"~/MNE/DATA\",update_path=false)\nlimo_epochs Now we can fit a simple  Unfold  model to it. First extract the data & convert it to Julia/Unfold requirements data = limo_epochs.get_data(picks=\"B11\")\ndata  = permutedims(data,[2,3,1]) # get into ch x times x epochs\n\nfunction convert_pandas(df_pd)\n      df= DataFrame()\n    for col in df_pd.columns\n        df[!, col] = getproperty(df_pd, col).values\n    end\n    return df\nend\nevents = convert_pandas(limo_epochs.metadata)\nrename!(events,2=>:coherence) # negative signs in formulas are not good ;)\nevents.face = string.(events.face) # ugly names, but fast\n Next fit an Unfold Model uf = fit(UnfoldModel,[Any=>(@formula(0~face+coherence),Float64.(limo_epochs.times))],events,data)\nresults = coeftable(uf) plot_results(results)"},{"id":50,"pagetitle":"🐍 Import EEG with PyMNE.jl","title":"Read some of your own data","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/pymne/#Read-some-of-your-own-data","content":" Read some of your own data We can make use of all PyMNE importer functions to load the data. Try it for your own data! Get starting with Unfold in no-time! #eeglabdata = PyMNE.io.read_raw_eeglab(\"pathToEEGLabSet.set\")"},{"id":51,"pagetitle":"🐍 Import EEG with PyMNE.jl","title":"Contribute?","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/pymne/#Contribute?","content":" Contribute? Some extra conversions are needed to import the data from PyMNE to Unfold (as shown above). We could try putting these in a wrapper function - do you want to tackle this challenge? Would be a great first contribution to the toolbox :-)"},{"id":54,"pagetitle":"Standard errors","title":"Standard Errors","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/standarderrors/#standard_errors","content":" Standard Errors"},{"id":55,"pagetitle":"Standard errors","title":"Setup some data","ref":"/UnfoldDocs/Unfold.jl/stable/HowTo/standarderrors/#Setup-some-data","content":" Setup some data using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\ndat, evts = UnfoldSim.predef_eeg(; noiselevel = 10, return_epoched = true)\n\nf = @formula 0 ~ 1 + condition + continuous\ndesignDict = Dict(Any => (f, range(0, 1, length = size(dat, 1)))) It is possible to specify a solver that calculates the standard errors of the estimates for a single subject as it possible for  custom solvers . se_solver = (x, y) -> Unfold.solver_default(x, y, stderror = true)\nm = Unfold.fit(UnfoldModel, designDict, evts, dat, solver = se_solver)\nresults = coeftable(m)\nplot_erp(results; stderror = true) Warning In case of overlap-correction:  Use single-subject standard errors on your own risk. EEG data is autocorrelated, which means that standard errors are typically too small."},{"id":58,"pagetitle":"Basisfunctions","title":"Basis Functions","ref":"/UnfoldDocs/Unfold.jl/stable/explanations/basisfunctions/#Basis-Functions","content":" Basis Functions This document will give you an explanation of basis functions. We start with basis functions for fMRI because they are very popular."},{"id":59,"pagetitle":"Basisfunctions","title":"HRF / BOLD","ref":"/UnfoldDocs/Unfold.jl/stable/explanations/basisfunctions/#HRF-/-BOLD","content":" HRF / BOLD We want to define a basis function. There are currently only few basisfunctions implemented in Unfold.jl, but your imagination knows no borders! We first have a look at the BOLD-HRF basisfunction aka  Blood Oxygenation Level Dependent Hemodynamic Response Function : using Unfold, DSP\n\nTR = 1.5 # the sampling rate\nbold = hrfbasis(TR) # using default SPM parameters\neventonset = 1.3\nbold_kernel = e -> Unfold.kernel(bold, e)\nlines(bold_kernel(eventonset)[:,1]) # returns a matrix, thus [:, 1] This is the shape that is assumed to reflect the activity for an event. Generally, we would like to know how much to scale this response shape per condition, e.g. in  condA  we might scale it by 0.7, in  condB  by 1.2. But let's start at the beginning and first simulate an fMRI signal. Then you will also appreciate why we need to deconvolve it later."},{"id":60,"pagetitle":"Basisfunctions","title":"Convolving a response shape to get a \"recorded\" fMRI signal","ref":"/UnfoldDocs/Unfold.jl/stable/explanations/basisfunctions/#Convolving-a-response-shape-to-get-a-\"recorded\"-fMRI-signal","content":" Convolving a response shape to get a \"recorded\" fMRI signal We start by convolving this HRF function with an impulse vector at event onsets. y = zeros(100) # signal length = 100\ny[[10, 30, 45]] .= 0.7 # 3 events at given for condition A\ny[[37]] .= 1.2 # 1 events at given for condition B\n\ny_conv = conv(y, bold_kernel(0)) # convolve!\nlines(y_conv[:,1]) Next, we would add some noise: using Random\ny_conv += randn(size(y_conv))\nlines(y_conv[:,1]) 🎉 - we did it, we simulated fMRI data. Now you can see that the conditions overlap in time. To get back to the original amplitude values, we need to specify a basis function and use Unfold to deconvolve the signals. Note Events can fall between TR (the sampling rate). Some packages subsample the time signal, but in  Unfold  we can call the  bold.kernel  function directly at a given event time, which allows us to use non-TR multiples."},{"id":61,"pagetitle":"Basisfunctions","title":"FIR Basis Function","ref":"/UnfoldDocs/Unfold.jl/stable/explanations/basisfunctions/#FIR-Basis-Function","content":" FIR Basis Function Okay, let's have a look at a different basis function: The FIR basisfunction. FIR stands for  Finite-Impulse-Response  and is a term taken from the filtering literature. basisfunction = firbasis(τ=(-0.4,.8), sfreq=50, name=\"myFIRbasis\")\nfir_kernel = e -> Unfold.kernel(basisfunction, e)\nm = fir_kernel(0)\nf = Figure()\nf[1,1] = Axis(f)\nfor col = 1:size(m, 2)\n    lines!(m[:,col])\nend\ncurrent_figure() The first thing to notice is that it is not a single basisfunction, but a set of basisfunctions. So every condition is explained by several basis functions! To make it clear better show it in 2D: fir_kernel(0)[1:10,1:10] 10×10 SparseArrays.SparseMatrixCSC{Int64, Int64} with 10 stored entries:\n 1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1 (all  .  are  0 's) The FIR basis set consists of multiple basis functions. That is, each event is now  time-expanded  to multiple predictors, each with a certain time delay to the event onset. This allows us to model any linear overlap shape, and doesn't force us to make assumptions about the convolution kernel, as we had to do in the BOLD case."},{"id":64,"pagetitle":"Duration-scaled basisfunctions (Hassall-style)","title":"FIR-Scaled duration predictors","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/FIRduration/#hassall-duration","content":" FIR-Scaled duration predictors using Unfold\nusing Interpolations\n\nusing UnfoldSim\nusing UnfoldMakie, CairoMakie\nusing DataFrames\n\ndata, evts = UnfoldSim.predef_eeg(sfreq = 10, n_repeats = 1)\n\nevts.duration = 5:24 5:24 putting  scale_duration = Interpolation.Linear()  will introduce a Cameron-Hassall 2022 PNAS- Style basisfunction, that scales with the  :duration  column basisfunction = firbasis(τ = (-1, 2), sfreq = 5, scale_duration = Interpolations.Linear()) �[0m�[22m╭──────────────────────────────────────────────────────────────────────────────╮�[22m�[0m8×16 SparseArrays.SparseMatrixCSC with 16 stored entries:\n�[22m│�[22m  �[1m�[34m::BasisFunction�[22m�[39m                                                             �[22m│�[22m⎡⠉⠒⠤⣀⠀⠀⠀⠀⎤                                               \n�[22m│�[22m  �[1mname: �[22m�[38;2;144;202;249m�[39m                                                                      �[22m│�[22m⎣⠀⠀⠀⠀⠉⠒⠤⣀⎦                                               \n�[22m│�[22m  �[1mkerneltype: �[22m�[38;2;144;202;249mFIRBasis�[39m                                                        �[22m│�[22m                                                         \n�[22m│�[22m  �[1mwidth: �[22m�[38;2;144;202;249m16�[39m                                                                   �[22m│�[22m                                                         \n�[22m│�[22m  �[1mheight: �[22m�[38;2;144;202;249mNaN�[39m                                                                 �[22m│�[22m                                                         \n�[22m│�[22m  �[1mcolnames: �[22m�[38;2;144;202;249m[-1.0, -0.8 ... 2.0]�[39m                                              �[22m│�[22m                                                         \n�[22m│�[22m  �[1mtimes: �[22m�[38;2;144;202;249m[-1.0, -0.8 ... 2.0]�[39m                                                 �[22m│�[22m                                                         \n�[22m│�[22m  �[1mcollabel: �[22m�[38;2;144;202;249mtime�[39m                                                              �[22m│�[22m                                                         \n�[22m│�[22m  �[1mshift_onset: �[22m�[38;2;144;202;249m-5�[39m                                                             �[22m│�[22m                                                         \n�[22m│�[22m                                                                              �[22m│�[22m                                                         \n�[0m�[22m╰──────────────────────────────────────────────────────────────────────────────╯�[22m�[0m�[0m                                                         \n Two examples with  duration = 10 Unfold.kernel(basisfunction, [0, 10]) 10×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 20 stored entries:\n⎡⠙⠢⢄⡀⠀⠀⠀⠀⎤\n⎢⠀⠀⠀⠉⠲⢄⡀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠈⠓⎦ and  duration = 20 Unfold.kernel(basisfunction, [0, 20]) 20×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 38 stored entries:\n⎡⠳⣄⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠘⢧⡀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠹⣆⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠈⢳⡄⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠙⢦⎦ let's fit a model f = @formula 0 ~ 1 + condition\nbf_vec = [Any => (f, basisfunction)]\nm = fit(UnfoldModel, bf_vec, evts, data; eventfields = [:latency, :duration]);\n\n\n# currently bugged for small matrices\n# plot_designmatrix(designmatrix(m))\n# thus using\nheatmap(Matrix(modelmatrix(m))') As one can see, the designmatrix is nicely scaled We can predict overlap-corrected results p = predict(m; overlap = false)[1]\nheatmap(p[1, :, :]) note the  missings  which are displayed as white pixels."},{"id":65,"pagetitle":"Duration-scaled basisfunctions (Hassall-style)","title":"Block-design predictors","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/FIRduration/#Block-design-predictors","content":" Block-design predictors In contrast, it is also possible to put  scale_duration = true  - which wil not scale the matrix as before, but introduce a step-function. putting  scale_duration = Interpolation.Linear()  will introduce a Cameron-Hassall 2022 PNAS- Style basisfunction, that scales with the  :duration  column basisfunction = firbasis(τ = (-1, 2), sfreq = 5, scale_duration = true) �[0m�[22m╭──────────────────────────────────────────────────────────────────────────────╮�[22m�[0m23×16 SparseArrays.SparseMatrixCSC with 128 stored entries:\n�[22m│�[22m  �[1m�[34m::BasisFunction�[22m�[39m                                                             �[22m│�[22m⎡⣷⣄⠀⠀⠀⠀⠀⠀⎤                                                 \n�[22m│�[22m  �[1mname: �[22m�[38;2;144;202;249m�[39m                                                                      �[22m│�[22m⎢⣿⣿⣷⣄⠀⠀⠀⠀⎥                                                 \n�[22m│�[22m  �[1mkerneltype: �[22m�[38;2;144;202;249mFIRBasis�[39m                                                        �[22m│�[22m⎢⠈⠻⣿⣿⣷⣄⠀⠀⎥                                                 \n�[22m│�[22m  �[1mwidth: �[22m�[38;2;144;202;249m16�[39m                                                                   �[22m│�[22m⎢⠀⠀⠈⠻⣿⣿⣷⣄⎥                                                 \n�[22m│�[22m  �[1mheight: �[22m�[38;2;144;202;249m16�[39m                                                                  �[22m│�[22m⎢⠀⠀⠀⠀⠈⠻⣿⣿⎥                                                 \n�[22m│�[22m  �[1mcolnames: �[22m�[38;2;144;202;249m[-1.0, -0.8 ... 2.0]�[39m                                              �[22m│�[22m⎣⠀⠀⠀⠀⠀⠀⠈⠻⎦                                                 \n�[22m│�[22m  �[1mtimes: �[22m�[38;2;144;202;249m[-1.0, -0.8 ... 2.0]�[39m                                                 �[22m│�[22m                                                           \n�[22m│�[22m  �[1mcollabel: �[22m�[38;2;144;202;249mtime�[39m                                                              �[22m│�[22m                                                           \n�[22m│�[22m  �[1mshift_onset: �[22m�[38;2;144;202;249m-5�[39m                                                             �[22m│�[22m                                                           \n�[22m│�[22m                                                                              �[22m│�[22m                                                           \n�[0m�[22m╰──────────────────────────────────────────────────────────────────────────────╯�[22m�[0m�[0m                                                           \n Two examples with  duration = 10 Unfold.kernel(basisfunction, [0, 10]) 25×16 SparseArrays.SparseMatrixCSC{Int64, Int64} with 160 stored entries:\n⎡⣷⣄⠀⠀⠀⠀⠀⠀⎤\n⎢⣿⣿⣷⣄⠀⠀⠀⠀⎥\n⎢⠻⣿⣿⣿⣷⣄⠀⠀⎥\n⎢⠀⠈⠻⣿⣿⣿⣷⣄⎥\n⎢⠀⠀⠀⠈⠻⣿⣿⣿⎥\n⎢⠀⠀⠀⠀⠀⠈⠻⣿⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠈⎦ and  duration = 20 Unfold.kernel(basisfunction, [0, 20]) 35×16 SparseArrays.SparseMatrixCSC{Int64, Int64} with 320 stored entries:\n⎡⣷⣄⠀⠀⠀⠀⠀⠀⎤\n⎢⣿⣿⣷⣄⠀⠀⠀⠀⎥\n⎢⣿⣿⣿⣿⣷⣄⠀⠀⎥\n⎢⣿⣿⣿⣿⣿⣿⣷⣄⎥\n⎢⣿⣿⣿⣿⣿⣿⣿⣿⎥\n⎢⠈⠻⣿⣿⣿⣿⣿⣿⎥\n⎢⠀⠀⠈⠻⣿⣿⣿⣿⎥\n⎢⠀⠀⠀⠀⠈⠻⣿⣿⎥\n⎣⠀⠀⠀⠀⠀⠀⠈⠻⎦ let's fit a model f = @formula 0 ~ 1 + condition\nbf_vec = [Any => (f, basisfunction)]\nm = fit(UnfoldModel, bf_vec, evts, data; eventfields = [:latency, :duration]);\n\n\nheatmap(Matrix(modelmatrix(m))') as one can see, now the designmatrix is not stretched - but rather \"block\"-ed p = predict(m; overlap = false)[1]\nheatmap(p[1, :, :]) This page was generated using  Literate.jl ."},{"id":68,"pagetitle":"Change contrasts / coding schema","title":"Contrast Coding","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/contrasts/#contrasts","content":" Contrast Coding using CairoMakie\nusing Unfold\nusing UnfoldMakie\nusing UnfoldSim\n\n\n# Contrast coding Unfold.jl uses the  StatsModels  package for the formula interface. This allows for a wide range of contrast coding schemes. For a full tutorial, please see  the StatsModels docs . Please read their tutorial, as a motivation of why one would change the contrast coding scheme is outside of the realms of this package and more a basic linear regression question. Hint Given we have a nice  effects  implementation (mimicking  emmeans  and similar packages), coding schema is typically less important. Here we will show a simple example of how to change the contrast coding scheme. We will use the  condition  variable, which has two levels,  A  and  B . We will change the contrast coding from  Dummy  aka  Reference  aka 0/1 coding to  Sum  coding, which is the default in R. eeg, evts = UnfoldSim.predef_eeg(noiselevel = 0)\nf = @formula 0 ~ 1 + condition\nbasis = firbasis((-0.1, 0.6), 100)\nm_dummy = fit(UnfoldModel, f, evts, eeg, basis)\nm_effec =\n    fit(UnfoldModel, f, evts, eeg, basis; contrasts = Dict(:condition => EffectsCoding())) Unfold�[38;2;239;83;80m-�[39mType: �[38;2;206;147;216m::UnfoldLinearModelContinuousTime�[39m{{Float64}} \n �[1m Any�[22m �[38;2;239;83;80m=�[39m�[38;2;239;83;80m>�[39m �[38;2;239;83;80mAny�[39m: timeexpand(�[38;2;144;202;249m1�[39m �[38;2;239;83;80m+�[39m condition) for times �[38;2;239;83;80m[�[39m�[38;2;239;83;80m-�[39m�[38;2;144;202;249m0.1�[39m, �[38;2;239;83;80m-�[39m�[38;2;144;202;249m0.09�[39m ... �[38;2;144;202;249m0.6�[39m�[38;2;239;83;80m]�[39m \n \n�[1m�[32m✔�[22m�[39m model is fit.  size(coefs) (�[38;2;144;202;249m1�[39m, �[38;2;144;202;249m142�[39m) \n \nUseful functions: �[38;2;255;238;88m`design(uf)`�[39m, �[38;2;255;238;88m`designmatrix(uf)`�[39m, �[38;2;255;238;88m`coef(uf)`�[39m, �[38;2;255;238;88m`coeftable(uf)`�[39m we could directly inspect the designmatrix modelmatrix(m_dummy, false)[1][1:5, :] 5×2 Matrix{Float64}:\n 1.0  0.0\n 1.0  1.0\n 1.0  0.0\n 1.0  0.0\n 1.0  0.0 and the effects coding modelmatrix(m_effec, false)[1][1:5, :] 5×2 Matrix{Float64}:\n 1.0  -1.0\n 1.0   1.0\n 1.0  -1.0\n 1.0  -1.0\n 1.0  -1.0 To confirm the difference in the actual fit, let's visualize them c_d = coeftable(m_dummy)\nc_e = coeftable(m_effec)\nc_d.group .= \"Dummy Coding\"\nc_e.group .= \"Effects Coding\"\nc = vcat(c_d, c_e)\n\nplot_erp(c; mapping = (; color = :coefname, col = :group)) As expected, the effects-coding slope of  condition: face  is half the size of the dummy-coding one (because -1/1 coding was used). This page was generated using  Literate.jl ."},{"id":71,"pagetitle":"Marginal effects (must read re: splines)","title":"Marginal effects","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/effects/#effects","content":" Marginal effects Marginal effect plots  are useful for understanding model fits. If you are an EEG researcher, you can think of the coefficients as the 'difference waves' and the (marginal) effects as the 'modelled ERP evaluated at a certain predictor value combination'. In some way, we are fitting a model with coefficients, receiving intercepts and slopes, and then try to recover the 'classical' ERPs in their \"data-domain\", typically with some effect adjustment, overlap removal, or similar."},{"id":72,"pagetitle":"Marginal effects (must read re: splines)","title":"Setup things","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/effects/#Setup-things","content":" Setup things Setup some packages using Unfold\nusing DataFrames\nusing Random\nusing CSV\nusing UnfoldMakie\nusing UnfoldSim\nusing UnfoldMakie Generate data and fit a model with a 2-level categorical predictor and a continuous predictor without interaction. data, evts = UnfoldSim.predef_eeg(; noiselevel = 8)\n\nbasisfunction = firbasis(τ = (-0.1, 0.5), sfreq = 100; interpolate = false)\n\nf = @formula 0 ~ 1 + condition + continuous # 1\n\nm = fit(UnfoldModel, [Any => (f, basisfunction)], evts, data, eventcolumn = \"type\") Plot the results plot_erp(coeftable(m)) The coefficients are represented by three lines on a figure: the intercept showing the reference category for a typical p1/n1/p3 ERP components; the slope of continuous variables with 1µV range; the effect of categorical variabe with 3µV range."},{"id":73,"pagetitle":"Marginal effects (must read re: splines)","title":"Effects function","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/effects/#Effects-function","content":" Effects function In order to better understand the actual predicted ERP curves, often researchers had to do manual contrasts. Remember that a linear model is  y = X * b , which allows (after  b  was estimated) to input a so-called  contrast  vector for X. You might know this in the form of  [1, 0, -1, 1]  or similar form. However, for larger models, this method can be prone to errors. The  effects  function is a convenient way to specify contrast vectors by providing the actual levels of the experimental design. It can be used to calculate all possible combinations of multiple variables. If a predictor-variable is not specified here, the function will automatically set it to its typical value. This value is usually the  mean , but for categorical variables, it could be something else. The R package  emmeans  has a lot of discussion on this topic. eff = effects(Dict(:condition => [\"car\", \"face\"]), m)\nplot_erp(eff; mapping = (; color = :condition,)) We can also generate continuous predictions: eff = effects(Dict(:continuous => -5:0.5:5), m)\nplot_erp(\n    eff;\n    mapping = (; color = :continuous, group = :continuous => nonnumeric),\n    categorical_color = false,\n    categorical_group = false,\n) Or we can split our marginal effects by condition and calculate all combinations \"automagically\". eff = effects(Dict(:condition => [\"car\", \"face\"], :continuous => -5:2:5), m)\nplot_erp(eff; mapping = (; color = :condition, col = :continuous))"},{"id":74,"pagetitle":"Marginal effects (must read re: splines)","title":"What is typical anyway?","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/effects/#What-is-typical-anyway?","content":" What is typical anyway? The  effects  function includes an argument called  typical , which specifies the function applied to the marginalized covariates/factors. The default value is  mean , which is usually sufficient for analysis. However, for skewed distributions, it may be more appropriate to use the  mode , while for outliers, the  median  or  winsor  mean may be more appropriate. To illustrate, we will use the  maximum  function on the  continuous  predictor. eff_max = effects(Dict(:condition => [\"car\", \"face\"]), m; typical = maximum)\neff_max.typical .= :maximum\neff = effects(Dict(:condition => [\"car\", \"face\"]), m)\neff.typical .= :mean # mean is the default\n\nplot_erp(vcat(eff, eff_max); mapping = (; color = :condition, col = :typical)) This page was generated using  Literate.jl ."},{"id":77,"pagetitle":"🐍 Calling Unfold.jl directly from Python","title":"Using Unfold.jl from Python","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/juliacall_unfold/#Using-Unfold.jl-from-Python","content":" Using Unfold.jl from Python it is straight forward to call Unfold from Python using  JuliaCall ."},{"id":78,"pagetitle":"🐍 Calling Unfold.jl directly from Python","title":"Quick start","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/juliacall_unfold/#Quick-start","content":" Quick start Create a Python environment and install JuliaCall. pip install juliacall Create a Julia environment and install Unfold # Import the Julia package manager\nfrom juliacall import Pkg as jlPkg\n\n# Activate the environment in the current folder\njlPkg.activate(\".\")\n\n# Install Unfold (in the activated environment)\njlPkg.add(\"Unfold\") Import Julia's main module and Unfold # Import Julia's Main module\nfrom juliacall import Main as jl\n\n# Import Unfold\n# The function seval() can be used to evaluate a piece of Julia code given as a string\njl.seval(\"using Unfold\")\nUnfold = jl.Unfold # simplify name Now you can use all Unfold functions as for example dummy_model = Unfold.UnfoldLinearModel(jl.Dict())"},{"id":79,"pagetitle":"🐍 Calling Unfold.jl directly from Python","title":"Example: Unfold model fitting from Python","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/juliacall_unfold/#Example:-Unfold-model-fitting-from-Python","content":" Example: Unfold model fitting from Python In this  notebook , you can find a more detailed example of how to use Unfold from Python to load data, fit an Unfold model and visualise the results in Python."},{"id":80,"pagetitle":"🐍 Calling Unfold.jl directly from Python","title":"Important limitations","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/juliacall_unfold/#Important-limitations","content":" Important limitations Python doesnt not offer the full expressions that are available in Julia. So there are some things you need to give special attention: @formula : we havent found a way to call macros yet, even though we think it should be possible. For now please use  f = jl.seval(\"@formula(0~1+my+cool+design)\") . Later versions might support something like  f = @formula(\"0~1+my+cool+design)\"  directly Specifying the design : Since Unfold 0.7 we officially switched to the [\"eventtypeA\"=>(formula,basisfunction),\n\"eventtypeB\"=>(otherformula,otherbasisfunction)] Array-based syntax, from a Dict-based syntax. Unfortunately,  =>  (a pair) is not supported in Python and one needs to do some rewriting: jl.convert(jl.Pair,(formula,basisfunction)) which makes the code less readable. We are thinking of ways to remedy this - but right now there is now way around. For now, it is also possible to use the old syntax e.g. in python {\"eventtypeA\"=>(formula,basisfunction),\"eventtypeB\"=>(otherformula,otherbasisfunction)} which is clearly easier to read :) UnfoldSim.design : we need a  Dict  with a  Symbol  , one has to do something like  condition_dict_jl = {convert(jl.Symbol,\"condA\"):[\"car\", \"face\"]}  to do so. We will [try to allow strings}(https://github.com/unfoldtoolbox/UnfoldSim.jl/issues/96) here as well, removing this constraint. When preprocessing your raw data through MNE Python, take the following into consideration: The  Raw object  contains the  first_samp  attribute which is an integer representing the number of time samples that passed between the onset of the hardware acquisition system and the time when data recording started. The Raw data doesn't include these time samples, meaning that the first sample is the beginning of the data aquisition. From the Raw object you can obtain an events array from the annotations through  mne.events from annotations() . The events array, however, does include first samp, meaning that the annotated events in events array don't match the Raw object anymore. Alternatively, it might be easier to convert the annotations to a pandas dataframe directly (`to data frame()`), or even better, load the \"* events.tsv\" from a BIDS dataset. In the latter case, all columns will be preserved, which MNE's read_annotation drops. This page was generated using  Literate.jl ."},{"id":83,"pagetitle":"Save and load Unfold models","title":"Save and load Unfold models","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/unfold_io/#unfold_io","content":" Save and load Unfold models Unfold.jl allows storing Unfold models in a memory-efficient way using (compressed) .jld2 files."},{"id":84,"pagetitle":"Save and load Unfold models","title":"Simulate EEG data and fit an Unfold model","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/unfold_io/#Simulate-EEG-data-and-fit-an-Unfold-model","content":" Simulate EEG data and fit an Unfold model Click to expand"},{"id":85,"pagetitle":"Save and load Unfold models","title":"Simulate some example data using UnfoldSim.jl","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/unfold_io/#Simulate-some-example-data-using-UnfoldSim.jl","content":" Simulate some example data using UnfoldSim.jl using UnfoldSim\ndata, events = UnfoldSim.predef_eeg(; n_repeats = 10)\nfirst(events, 5) 5×3 DataFrame Row continuous condition latency Float64 String Int64 1 2.77778 car 62 2 -5.0 face 132 3 -1.66667 car 196 4 -5.0 car 249 5 5.0 car 303"},{"id":86,"pagetitle":"Save and load Unfold models","title":"Fit an Unfold model","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/unfold_io/#Fit-an-Unfold-model","content":" Fit an Unfold model using Unfold\nbasisfunction = firbasis(τ = (-0.5, 1.0), sfreq = 100, name = \"stimulus\")\nf = @formula 0 ~ 1 + condition + continuous\nbfDict = Dict(Any => (f, basisfunction))\nm = fit(UnfoldModel, bfDict, events, data); ┌ Warning: using `Dict(:A=>(@formula,times/basisfunction))` is deprecated, please use `[:A=>(@formula,times/basisfunction)]` from now on\n└ @ Unfold ~/work/Unfold.jl/Unfold.jl/src/fit.jl:74"},{"id":87,"pagetitle":"Save and load Unfold models","title":"Save and load the fitted Unfold model","ref":"/UnfoldDocs/Unfold.jl/stable/generated/HowTo/unfold_io/#Save-and-load-the-fitted-Unfold-model","content":" Save and load the fitted Unfold model The following code saves the model in a compressed .jld2 file. The default option of the  save  function is  compress=false . For memory efficiency the designmatrix is set to missing. If needed, it can be reconstructed when loading the model. save_path = mktempdir(; cleanup = false) # create a temporary directory for the example\nsave(joinpath(save_path, \"m_compressed.jld2\"), m; compress = true); The  load  function allows to retrieve the model again. By default, the designmatrix is reconstructed. If it is not needed set  generate_Xs=false ` which improves time-efficiency. m_loaded = load(joinpath(save_path, \"m_compressed.jld2\"), UnfoldModel, generate_Xs = true); This page was generated using  Literate.jl ."},{"id":90,"pagetitle":"Non-Linear effects","title":"[Non-linear effects]](@id nonlinear)","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/nonlinear_effects/#[Non-linear-effects]](@id-nonlinear)","content":" [Non-linear effects]](@id nonlinear) import BSplineKit\nusing Unfold\nusing CairoMakie\nusing DataFrames\nusing Random\nusing Colors\nusing Missings"},{"id":91,"pagetitle":"Non-Linear effects","title":"Generating a non-linear signal","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/nonlinear_effects/#Generating-a-non-linear-signal","content":" Generating a non-linear signal We start with generating data variables rng = MersenneTwister(2) # make repeatable\nn = 20 # number of datapoints\nevts = DataFrame(:x => rand(rng, n))\nsignal = -(3 * (evts.x .- 0.5)) .^ 2 .+ 0.5 .* rand(rng, n)\n\nplot(evts.x, signal) Looks perfectly non-linear. Great!"},{"id":92,"pagetitle":"Non-Linear effects","title":"Compare linear & non-linear fit","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/nonlinear_effects/#Compare-linear-and-non-linear-fit","content":" Compare linear & non-linear fit First, we have to reshape  signal  data to a 3d array, so it will fit to Unfold format:  1 channel x 1 timepoint x 20 datapoints. signal = reshape(signal, length(signal), 1, 1)\nsignal = permutedims(signal, [3, 2, 1])\nsize(signal) (1, 1, 20) Next we define three different models:  linear ,  4 splines  and  10 splines . Note difference in formulas: one  x , the other  spl(x, 4) . design_linear = [Any => (@formula(0 ~ 1 + x), [0])];\ndesign_spl3 = [Any => (@formula(0 ~ 1 + spl(x, 4)), [0])];\ndesign_spl10 = [Any => (@formula(0 ~ 1 + spl(x, 10)), [0])]; Next, fit the parameters. uf_linear = fit(UnfoldModel, design_linear, evts, signal);\nuf_spl3 = fit(UnfoldModel, design_spl3, evts, signal); Extract the fitted values using Unfold.effects. p_linear = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_linear);\np_spl3 = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_spl3);\np_spl10 = Unfold.effects(Dict(:x => range(0, stop = 1, length = 100)), uf_spl10);\nfirst(p_linear, 5) 5×5 DataFrame Row yhat channel x time eventname Float64 Int64 Float64 Int64 DataType 1 0.0328538 1 0.0 0 Any 2 0.0273313 1 0.010101 0 Any 3 0.0218088 1 0.020202 0 Any 4 0.0162863 1 0.030303 0 Any 5 0.0107638 1 0.040404 0 Any Plot them. pl = plot(evts.x, signal[1, 1, :])\nlines!(p_linear.x, p_linear.yhat)\nlines!(p_spl3.x, coalesce.(p_spl3.yhat, NaN))\nlines!(p_spl10.x, coalesce.(p_spl10.yhat, NaN))\npl We see here, that the linear effect (blue line) underfits the data, the yellow  spl(x, 10)  overfits it, but the green  spl(x, 4)  fits it perfectly."},{"id":93,"pagetitle":"Non-Linear effects","title":"Looking under the hood","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/nonlinear_effects/#Looking-under-the-hood","content":" Looking under the hood Let's have a brief look how the splines manage what they are managing. The most important bit to understand is, that we are replacing  x  by a set of coefficients  spl(x) . These new coefficients each tile the range of  x  (in our case, from [0-1]) in overlapping areas, while each will be fit by one coefficient. Because the ranges are overlapping, we get a smooth function. Maybe this becomes clear after looking at a  basisfunction : term_spl = Unfold.formulas(uf_spl10)[1].rhs.terms[2] spl(x, 10) This is the spline term. Note, this is a special type available in the BSplineKit.jl extension in Unfold.jl. It's abstract type is  AbstractSplineTerm  defined in Unfold.jl typeof(term_spl) UnfoldBSplineKitExt.BSplineTerm{StatsModels.ContinuousTerm{Float64}, Int64} const splFunction = Base.get_extension(Unfold, :UnfoldBSplineKitExt).splFunction\nsplFunction([0.2], term_spl) 1×10 Matrix{Float64}:\n 0.492619  0.438047  0.0670761  0.00225775  0.0  0.0  0.0  0.0  0.0  0.0 Each column of this 1-row matrix is a coefficient for our regression model. lines(disallowmissing(splFunction([0.2], term_spl))[1, :]) Note: We have to use  disallowmissing , because our splines return a  missing  whenever we ask it to return a value outside its defined range, e.g.: splFunction([-0.2], term_spl) 1×10 Matrix{Union{Missing, Float64}}:\n missing  missing  missing  missing  …  missing  missing  missing  missing Because it never has seen any data outside and can't extrapolate! Back to our main issue. Let's plot the whole basis set basisSet = splFunction(0.0:0.01:1, term_spl)\nbasisSet = disallowmissing(basisSet[.!any(ismissing.(basisSet), dims = 2)[:, 1], :]) # remove missings\nax = Axis(Figure()[1, 1])\n[lines!(ax, basisSet[:, k]) for k = 1:size(basisSet, 2)]\ncurrent_figure() Notice how we flipped the plot around, i.e. now on the x-axis we do not plot the coefficients, but the  x -values. Now each line is one basis-function of the spline. Unfold returns us one coefficient per basis-function β = coef(uf_spl10)[1, 1, :]\nβ = Float64.(disallowmissing(β)) 10-element Vector{Float64}:\n -0.43629459354570777\n -0.3477308181329035\n  0.4538614574712754\n -0.4065207930158754\n  0.7346158579524353\n  0.9252913204020701\n  0.27167896791779556\n -0.046335871160806175\n -0.5822988416277803\n -0.6202082891592833 But because we used an intercept, we have to do some remodelling in the  basisSet . X = hcat(ones(size(basisSet, 1)), basisSet[:, 1:5], basisSet[:, 7:end]) 71×10 Matrix{Float64}:\n 1.0  0.972634     0.027217  0.000148709  …  0.0         0.0       0.0\n 1.0  0.705645     0.274339  0.0196948       0.0         0.0       0.0\n 1.0  0.492619     0.438047  0.0670761       0.0         0.0       0.0\n 1.0  0.327462     0.530129  0.135118        0.0         0.0       0.0\n 1.0  0.204084     0.56237   0.216645        0.0         0.0       0.0\n 1.0  0.116392     0.546557  0.304483     …  0.0         0.0       0.0\n 1.0  0.0582934    0.494476  0.391456        0.0         0.0       0.0\n 1.0  0.0236969    0.417914  0.470391        0.0         0.0       0.0\n 1.0  0.00651001   0.328658  0.534112        0.0         0.0       0.0\n 1.0  0.000640778  0.238493  0.575444        0.0         0.0       0.0\n ⋮                                        ⋱                        \n 1.0  0.0          0.0       0.0             0.500742    0.335973  0.0\n 1.0  0.0          0.0       0.0             0.472071    0.412937  0.0\n 1.0  0.0          0.0       0.0             0.423651    0.500839  0.0\n 1.0  0.0          0.0       0.0          …  0.354694    0.596875  0.00252938\n 1.0  0.0          0.0       0.0             0.272257    0.677546  0.0249338\n 1.0  0.0          0.0       0.0             0.186241    0.711843  0.0899373\n 1.0  0.0          0.0       0.0             0.106554    0.668749  0.220272\n 1.0  0.0          0.0       0.0             0.0431012   0.517244  0.438668\n 1.0  0.0          0.0       0.0          …  0.00579053  0.226308  0.767859 Now we can weight the spline by the  basisfunction . weighted = (β .* X') 10×71 Matrix{Float64}:\n -0.436295    -0.436295    -0.436295    …  -0.436295     -0.436295\n -0.338215    -0.245375    -0.171299       -0.0          -0.0\n  0.0123527    0.124512     0.198813        0.0           0.0\n -6.04533e-5  -0.00800637  -0.0272678      -0.0          -0.0\n  1.39303e-7   0.00023577   0.00165858      0.0           0.0\n  0.0          0.0          0.0         …   0.0           0.0\n  0.0          0.0          0.0             0.000268113   1.15869e-5\n -0.0         -0.0         -0.0            -0.00199713   -0.000268309\n -0.0         -0.0         -0.0            -0.30119      -0.131779\n -0.0         -0.0         -0.0            -0.272066     -0.476232 Plotting them creates a nice looking plot! ax = Axis(Figure()[1, 1])\n[lines!(weighted[k, :]) for k = 1:10]\ncurrent_figure() Now sum them up. lines(sum(weighted, dims = 1)[1, :])\nplot!(X * β, color = \"gray\") #(same as matrixproduct X*β directly!)\ncurrent_figure() And this is how you can think about splines. This page was generated using  Literate.jl ."},{"id":96,"pagetitle":"Predictions","title":"The predict-family","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/predict/#The-predict-family","content":" The predict-family # Setup\nusing Unfold\nusing UnfoldSim\nusing CairoMakie\n\ndat, evts = UnfoldSim.predef_eeg(noiselevel = 5)\ndesign = [\n    \"car\" => (@formula(0 ~ 1 + continuous), firbasis(τ = (-0.5, 1), sfreq = 100)),\n    \"face\" => (@formula(0 ~ 1 + continuous), firbasis(τ = (-0.3, 0.5), sfreq = 100)),\n]\n\nm = fit(UnfoldModel, design, evts, dat; eventcolumn = :condition);"},{"id":97,"pagetitle":"Predictions","title":"Overview","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/predict/#Overview","content":" Overview In a linear model  $EEG = Xβ + e$ , predictions boil down to finding  $\\hat{EEG} = Xβ$ , thus EEG data without any error term. Different types of predictions can be generated by modifying the  $X$  accordingly. Note We simulated only a single channel, all results generalize to the multi channel case"},{"id":98,"pagetitle":"Predictions","title":"Different types of predictions","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/predict/#Different-types-of-predictions","content":" Different types of predictions"},{"id":99,"pagetitle":"Predictions","title":"Time-Continuous case","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/predict/#Time-Continuous-case","content":" Time-Continuous case Let's start with the cases, where the EEG was not epoched before using Unfold, i.e. the EEG was analysed with e.g. FIR-deconvolution"},{"id":100,"pagetitle":"Predictions","title":"Continuous EEG","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/predict/#Continuous-EEG","content":" Continuous EEG In the most simple case, we can predict the continuously modelled EEG - This returns  $EEG = Xβ$ p = predict(m) # same as predict(m, overlap = true)\nlines(p[1, 1:1000])"},{"id":101,"pagetitle":"Predictions","title":"No-overlap","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/predict/#No-overlap","content":" No-overlap We can also predict each epoch without any overlap - This results in one prediction Array per event (in our case we have two events \"car\" and \"face\", thus  size(p) = 2 p = predict(m, overlap = false)\nsize(p) (2,) Each Array has the size (1, samples, epochs): size(p[1]) (1, 151, 1000) Visualizing the 1000 events series(range(-0.5, 1, step = 1 / 100), p[1][1, :, :]', solid_color = :orange)\nseries!(range(-0.3, 0.5, step = 1 / 100), p[2][1, :, :]', solid_color = :teal)\ncurrent_figure() Note At ~0.3s we can see a split between the predicted EEG single trials into 10 \"strands\" - this is the granularity of our continuous predictor. You could use  effects  to improve upon this granularity / customize it."},{"id":102,"pagetitle":"Predictions","title":"With-overlap, epoched","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/predict/#With-overlap,-epoched","content":" With-overlap, epoched Sometimes helpful is to add in the overlap we removed via the deconvolution. p = predict(m, epoch_to = [\"car\"], eventcolumn = :condition)\nseries(range(-0.5, 1, step = 1 / 100), p[1, :, 1:3]', solid_color = :orange)"},{"id":103,"pagetitle":"Predictions","title":"Partial-overlap","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/predict/#Partial-overlap","content":" Partial-overlap We can also include/exclude certain events with \"partial-overlap\", i.e. only overlap with kept events. p_car = predict(m, keep_basis = [\"car\"], eventcolumn = :condition)\np_face = predict(m, exclude_basis = [\"car\"], eventcolumn = :condition) # same as keep_basis=[\"face\"]\nf = lines(p_car[1, 1:1000])\nlines!(p_face[1, 1:1000])\nf In the plot, we see the two partial predictions for car and face. They are respectively \"0\" outside the basisfunction windows Note The above options can be combined as well, e.g. to get an  epoch_to ,  exclude_basis  version.  epoch_timewindow  can be specified as well. This page was generated using  Literate.jl ."},{"id":106,"pagetitle":"Window Length Effect","title":"Window length effects","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/window_length/#Window-length-effects","content":" Window length effects using Unfold, UnfoldSim\nusing CairoMakie, AlgebraOfGraphics, MakieThemes\nusing Random\nusing DataFrames, DataFramesMeta\nusing ColorSchemes, Colors Important For analyzing real-world EEG data we recommend that researchers should — a priori — make an educated guess about the length of the underlying EEG activity and select this as their EW. This also suggests to use event windows with different sizes between events (as is possible with Unfold). Further, as can be seen below, when choosing longer time-windows the overfit is only of moderate size, thus we additionally recommend to generally err on the longer side, to not miss any important activity.  For a more in depth explanation on this, you can read our 2023 CCN paper:  Skukies & Ehinger, 2023 set_theme!(theme_ggthemr(:fresh)) As opposed to classical averaged ERPs overlap corrected regression ERPs can be influenced by the chosen window length: Long estimation windows might capture all relevant event-related activity, but might introduce artifacts due to overfit, short estimation windows might not overfit, but also might not capture all (overlapping) activity, and thereby introduce bias. Thus a common question we get is, how to specify the length of the estimation windows."},{"id":107,"pagetitle":"Window Length Effect","title":"Init functions","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/window_length/#Init-functions","content":" Init functions First we need a function that simulates some continous data; conviently we can use UnfoldSim for this function gen_data(rng, noiselevel, sfreq)\n    noise = PinkNoise(; noiselevel = noiselevel)\n\n    dat, evts = UnfoldSim.predef_eeg(\n        rng;\n        sfreq = sfreq,\n        p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 0], Dict()),\n        n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 0], Dict()),\n        p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1 + continuous), [5, 0], Dict()),\n        n_repeats = 20,\n        noise = noise,\n    )\n    return dat, evts\nend; Next a convience function to calculate the estimates function calc_time_models(evts, dat, tWinList, sfreq)\n    mList = []\n    for twindow in tWinList\n        m = fit(\n            UnfoldModel,\n            [Any => (@formula(0 ~ 1), firbasis(twindow, sfreq))],\n            evts,\n            dat,\n        )\n        res = coeftable(m)\n        res.tWin .= string.(Ref(twindow[2]))\n        push!(mList, res)\n    end\n    return vcat(mList...)\nend;"},{"id":108,"pagetitle":"Window Length Effect","title":"Init variables","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/window_length/#Init-variables","content":" Init variables tWinList = [(-0.1, x) for x in [3, 2.5, 2, 1.5, 1, 0.5]]\nnoiselevel = 8.5\nsfreq = 250;"},{"id":109,"pagetitle":"Window Length Effect","title":"Generate data and calculate estimates","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/window_length/#Generate-data-and-calculate-estimates","content":" Generate data and calculate estimates dat, evts = gen_data(MersenneTwister(2), noiselevel, sfreq);\n\nres = calc_time_models(evts, dat, tWinList, sfreq); We also append some additional information to the results dataframe For comparison lets also generate the ground truth of our data; this is a bit cumbersome and you don't have to care (too much) about it dat_gt, evts_gt = UnfoldSim.predef_eeg(;\n    p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    sfreq = sfreq,\n    n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()),\n    n_repeats = 1,\n    noiselevel = 0,\n    return_epoched = true,\n);\ntime_gt = range(0, length = length(dat_gt[:, 1]), step = 1 / sfreq)\nunique_event = unique(res.tWin)\ndf_gt = DataFrame(\n    tWin = reduce(vcat, fill.(unique_event, length(dat_gt[:, 1]))),\n    eventname = Any,\n    channel = repeat([1], length(dat_gt[:, 1]) * length(unique_event)),\n    coefname = reduce(\n        vcat,\n        fill(\"GroundTruth\", length(dat_gt[:, 1]) * length(unique_event)),\n    ),\n    estimate = repeat(dat_gt[:, 1], length(unique_event)),\n    group = reduce(vcat, fill(nothing, length(dat_gt[:, 1]) * length(unique_event))),\n    stderror = reduce(vcat, fill(nothing, length(dat_gt[:, 1]) * length(unique_event))),\n    time = repeat(time_gt, length(unique_event)),\n); And append ground truth to our results df res_gt = vcat(res, df_gt);"},{"id":110,"pagetitle":"Window Length Effect","title":"Plot results","ref":"/UnfoldDocs/Unfold.jl/stable/generated/explanations/window_length/#Plot-results","content":" Plot results Choose which data to plot h_t =\n    AlgebraOfGraphics.data(res) * mapping(\n        :time,\n        :estimate,\n        color = :tWin,\n        group = (:tWin, :coefname) => (x, y) -> string(x[2]) * y,\n    ); We use the following to plot some length indicator lines untWin = unique(res_gt.tWin)\nsegDF = DataFrame(\n    :x => hcat(repeat([-0.1], length(untWin)), parse.(Float64, untWin))[:],\n    :y => repeat(reverse(1:length(untWin)), outer = 2),\n)\nsegDF.tWin .= \"0.0\"\nsegDF.tWin .= segDF.x[reverse(segDF.y .+ 6)]\nsegDF.y = segDF.y .* 0.2 .+ 6; Layer for indicator lines h_l =\n    AlgebraOfGraphics.data(@subset(segDF, :tWin .!= \"3.0\")) *\n    mapping(:x, :y, color = :tWin, group = :tWin => x -> string.(x)); Ground truth Layer h_gt =\n    AlgebraOfGraphics.data(df_gt) *\n    mapping(:time, :estimate, group = (:tWin, :coefname) => (x, y) -> string(x) * y) *\n    visual(Lines, linewidth = 5, color = Colors.Gray(0.6)); Add all visuals together and draw h1 =\n    h_gt + visual(Lines, colormap = get(ColorSchemes.Blues, 0.3:0.01:1.2)) * (h_l + h_t) |>\n    x -> draw(x, axis = (; xlabel = \"time [s]\", ylabel = \"estimate [a.u.]\")); Add zero grid lines h1 = hlines!(current_axis(), [0], color = Colors.Gray(0.8));\nh2 = vlines!(current_axis(), [0], color = Colors.Gray(0.8));\ntranslate!(h1, 0, 0, -1);\ntranslate!(h2, 0, 0, -1); Plot figure current_figure() This page was generated using  Literate.jl ."},{"id":113,"pagetitle":"Solver/optimizer implementations","title":"Solver implementation","ref":"/UnfoldDocs/Unfold.jl/stable/generated/references/solver/#solver_implementation","content":" Solver implementation This document describes how the  solver_main  is implemented and how to add custom solvers. some setup using Unfold, UnfoldSim, CairoMakie\nusing LinearAlgebra: cholesky"},{"id":114,"pagetitle":"Solver/optimizer implementations","title":"Solver main","ref":"/UnfoldDocs/Unfold.jl/stable/generated/references/solver/#Solver-main","content":" Solver main This function gis a eneral purpose solver-wrapper function. It calls   prepare_fun  and iterates over the first dimension of  data , repeatedly calling the  solver_fun . Without any bells and whistles (progress, history etc.) the function roughly looks like this: function _solver_min(X, data; prepare_fun, solver_fun!, stderror = false)\n    Ĥ, dataP, prepared = prepare_fun(X, data)\n    for ch = 1:size(dataP, 2)\n        for t = 1:size(dataP, 3)\n            ch == 1 || copyto!(view(Ĥ, ch, :, t), view(Ĥ, ch - 1, :, t))\n            solver_fun!(view(Ĥ, ch, :, t), view(dataP, :, ch, t), prepared...)\n        end\n    end\n    modelfit = stderror ? calculate_stderror(X, data, Ĥ) : nothing\n\n    return modelfit\n\nend _solver_min (generic function with 1 method) Before diving into the  prepare_fun  and  solver_fun!  functions, let's discuss first the inner loop  t=1:size(dataP,3) . This loop really only comes alife (that is  size(dataP,3)!=1 ) if a mass-univariate model is fitted, that is, when ndims(data)==3`. We still have it around for 2D, un-epoched data, to have exactly the same code in both cases."},{"id":115,"pagetitle":"Solver/optimizer implementations","title":"prepare_fun`","ref":"/UnfoldDocs/Unfold.jl/stable/generated/references/solver/#prepare_fun","content":" prepare_fun ` This function is the setup / prepare function. It is typically a chain of functions with similar input / output characteristica. The first fuction of the chain/pipeline should be a function taking  (X,data) and returning  (Ĥ::AbstractArray, dataP::AbstractArray, prepared::Tuple) . Ĥ  is used to save the beta/parameters inplace dataP  is the data in format ch x repeat x time (with size(time) = 1 if data initially was a Matrix/2D-array) prepared  is a tuple of all the other variables needed in the solver-step, e.g. the  pinv(X)  or  X'X  or simply  X The  prepare  function which is typiclly the first, just permutes the data & converts everything to GPU in case  data::CuArray . The next function in a pipeline then would take this  (Ĥ::AbstractArray, dataP::AbstractArray, prepared::Tuple)  inputs and process it further.`"},{"id":116,"pagetitle":"Solver/optimizer implementations","title":"solver_fun!","ref":"/UnfoldDocs/Unfold.jl/stable/generated/references/solver/#solver_fun!","content":" solver_fun! This function actually performs the fitting. It takes the inputs  (Ĥ::view(Matrix),data::view(Array),prepared::Tuple) Ĥ  is the current beta/parameters view, a vector/slice for one channel and one timepoint data  is similarly the current data view, a vector/slice for one channel and one timepoint prepared  is the tuple-output of the  prepare  function. The  solver_fun!  can output some history of the solver, e.g. a log for iterative solvers."},{"id":117,"pagetitle":"Solver/optimizer implementations","title":"Example (simple)","ref":"/UnfoldDocs/Unfold.jl/stable/generated/references/solver/#Example-(simple)","content":" Example (simple) let's setup our own solver: _my_solver!(Ĥ, data, X) = Ĥ .= Matrix(X) \\ data _my_solver! (generic function with 1 method) let's simulate some data and see this in action data, evts = UnfoldSim.predef_eeg()\nm = fit(\n    UnfoldModel,\n    @formula(0 ~ 1 + condition),\n    evts,\n    data,\n    firbasis((-0.1, 0.5), 100);\n    solver = (x, y) ->\n        Unfold.solver_main(x, y; solver_fun! = _my_solver!, show_time = true),\n) Unfold�[38;2;239;83;80m-�[39mType: �[38;2;206;147;216m::UnfoldLinearModelContinuousTime�[39m{{Float64}} \n �[1m Any�[22m �[38;2;239;83;80m=�[39m�[38;2;239;83;80m>�[39m �[38;2;239;83;80mAny�[39m: timeexpand(�[38;2;144;202;249m1�[39m �[38;2;239;83;80m+�[39m condition) for times �[38;2;239;83;80m[�[39m�[38;2;239;83;80m-�[39m�[38;2;144;202;249m0.1�[39m, �[38;2;239;83;80m-�[39m�[38;2;144;202;249m0.09�[39m ... �[38;2;144;202;249m0.5�[39m�[38;2;239;83;80m]�[39m \n \n�[1m�[32m✔�[22m�[39m model is fit.  size(coefs) (�[38;2;144;202;249m1�[39m, �[38;2;144;202;249m122�[39m) \n \nUseful functions: �[38;2;255;238;88m`design(uf)`�[39m, �[38;2;255;238;88m`designmatrix(uf)`�[39m, �[38;2;255;238;88m`coef(uf)`�[39m, �[38;2;255;238;88m`coeftable(uf)`�[39m Remember from this table the time for one solve (~700ms on my test-computer) this is the time per channel. series(coef(m))"},{"id":118,"pagetitle":"Solver/optimizer implementations","title":"Cholesky Example","ref":"/UnfoldDocs/Unfold.jl/stable/generated/references/solver/#Cholesky-Example","content":" Cholesky Example Note the following function is already implemented in Unfold.jl as well. See  ?Unfold.solver_predefined Given that the  prepare  function returns all necessary ingredients, this is a bit simple. So let's make it more complex for nicety, we need some unpacking wrappers _prepare_cholesky(all::Tuple) = _prepare_cholesky(all...)\n_prepare_cholesky(Ĥ, data, all::Tuple) = _prepare_cholesky(Ĥ, data, all...) _prepare_cholesky (generic function with 2 methods) this function effectively only pre-calculates the cholesky decomposition _prepare_cholesky(Ĥ, data, Xt, R_xx, R_xy) = (Ĥ, data, (Xt, cholesky(R_xx), R_xy)) _prepare_cholesky (generic function with 3 methods) now we have everything to put together our solver-pipeline _my_prepare =\n    (x, y) -> Unfold.prepare(collect(x), y) |> Unfold.prepare_XTX |> _prepare_cholesky #4 (generic function with 1 method) let's test (note we have to reshape the data) @time _my_prepare(modelmatrix(m), reshape(data, 1, :)) ([0.0 0.0 … 0.0 0.0], [0.31631798033146774; 0.40338935529989906; … ; -0.22230944464885682; -0.01320095208877194;;], ([0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], LinearAlgebra.Cholesky{Float64, Matrix{Float64}}([44.721359549995796 0.0 … 1.3416407864998738 1.050951949424901; 0.0 44.721359549995796 … 0.872066511224918 1.3416407864998738; … ; 60.0 39.0 … 22.350948931592846 0.0017222814568252079; 47.0 60.0 … 0.0 22.35013390954843], 'U', 0), [5.0e-324, 0.0, 5.0e-324, 1.0e-323, 5.0e-324, 5.0e-324, 1.5e-323, 1.0e-323, 5.0e-324, 2.0e-323  …  6.9442560272965e-310, 6.9442560246894e-310, 6.94425602469097e-310, 6.94425602469255e-310, 6.94425602469413e-310, 6.9442560246957e-310, 6.94425602183804e-310, 6.94425602449967e-310, 6.94425602468623e-310, 6.94425602468623e-310])) finally, we need a solver this is how we solve the single-channel equation function _my_cholesky!(beta, data, Xt, XtX_cholesky, R_xy)\n    @time Unfold.calc_Rxy!(R_xy, Xt, data)\n    @time beta .= XtX_cholesky \\ R_xy\nend\n\nm = fit(\n    UnfoldModel,\n    @formula(0 ~ 1 + condition),\n    evts,\n    data,\n    firbasis((-0.1, 0.5), 100);\n    solver = (x, y) -> Unfold.solver_main(\n        x,\n        y;\n        prepare_fun = _my_prepare,\n        solver_fun! = _my_cholesky!,\n        show_time = true,\n    ),\n) Unfold�[38;2;239;83;80m-�[39mType: �[38;2;206;147;216m::UnfoldLinearModelContinuousTime�[39m{{Float64}} \n �[1m Any�[22m �[38;2;239;83;80m=�[39m�[38;2;239;83;80m>�[39m �[38;2;239;83;80mAny�[39m: timeexpand(�[38;2;144;202;249m1�[39m �[38;2;239;83;80m+�[39m condition) for times �[38;2;239;83;80m[�[39m�[38;2;239;83;80m-�[39m�[38;2;144;202;249m0.1�[39m, �[38;2;239;83;80m-�[39m�[38;2;144;202;249m0.09�[39m ... �[38;2;144;202;249m0.5�[39m�[38;2;239;83;80m]�[39m \n \n�[1m�[32m✔�[22m�[39m model is fit.  size(coefs) (�[38;2;144;202;249m1�[39m, �[38;2;144;202;249m122�[39m) \n \nUseful functions: �[38;2;255;238;88m`design(uf)`�[39m, �[38;2;255;238;88m`designmatrix(uf)`�[39m, �[38;2;255;238;88m`coef(uf)`�[39m, �[38;2;255;238;88m`coeftable(uf)`�[39m This (on my test-computer) took only 97ms per channel, so it is ~7x faster per channel. series(coef(m)) This page was generated using  Literate.jl ."},{"id":121,"pagetitle":"Installing Julia + Unfold.jl","title":"Installation","ref":"/UnfoldDocs/Unfold.jl/stable/installation/#install_instruct","content":" Installation"},{"id":122,"pagetitle":"Installing Julia + Unfold.jl","title":"Installing Julia","ref":"/UnfoldDocs/Unfold.jl/stable/installation/#Installing-Julia","content":" Installing Julia The easiest way to install julia is using  juliaup TLDR; Windows:  winget install julia -s msstore Mac/Linux:  curl -fsSL https://install.julialang.org | sh We further recommend to use VSCode. Make sure to install the Julia-Plugin, and install Revise.jl -  a tutorial with screenshots can be found here"},{"id":123,"pagetitle":"Installing Julia + Unfold.jl","title":"Installing Unfold.jl","ref":"/UnfoldDocs/Unfold.jl/stable/installation/#Installing-Unfold.jl","content":" Installing Unfold.jl You can enter the package manager (similar to conda) using  ]  in the REPL (\"julia-commandline\"). This should result in  (currentFolder) pkg>  (with  currentFolder  being the project you currently work in) Hint if you see  (@v1.9) pkg>  instead, you still have to activate your environment. This can be done using: cd(\"/path/to/your/project\")   and  ]activate . or alternatively  ]activate /path/to/your/project/ Now you can do  pkg> add Unfold and after some installation: julia> using Unfold  in the REPL"},{"id":126,"pagetitle":"Solver benchmarks","title":"Benchmarks","ref":"/UnfoldDocs/Unfold.jl/stable/references/benchmarks/#Benchmarks","content":" Benchmarks We ran benchmarks on 2024-11-07 as described in  ./benchmark/cuda/solver_comparison.jl . Given that some were run on a GPU, we cannot run them on continuous-integration online. Important Allocations are only CPU allocations - GPU allocations were not counted. Solvers other than  default_multi  are currently  NOT  multi-threaded Solvers other than  default_multi  and  krylov_gpu  solve  $X'Xb = X'y$  instead of  $Xb=y$  directly. They are likely less accurate, but should be faster for multi-channel data, as we can precalulate cholesky, qr or similar & the to-be-inverted matrix is much smaller."},{"id":127,"pagetitle":"Solver benchmarks","title":"Small Model","ref":"/UnfoldDocs/Unfold.jl/stable/references/benchmarks/#Small-Model","content":" Small Model n_channels = 1,\nsfreq = 10,\nn_splines = 4,\nn_repeats = 10; gpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment true cholesky Float64 0.068 (1190, 130) 1 (0.2, 0.2) PosDefException(-1) false cholesky Float64 0.00056 0.00069 0.068 (1190, 130) 1 (0.2, 0.2) true intern Float64 0.00088 0.00017 0.068 (1190, 130) 1 (0.2, 0.2) false intern Float64 0.0011 0.00069 0.068 (1190, 130) 1 (0.2, 0.2) true qr Float64 0.0013 0.00019 0.068 (1190, 130) 1 (0.2, 0.2) false cg Float64 0.0015 0.00057 0.068 (1190, 130) 1 (0.2, 0.2) false default_multi Float64 0.0017 0.00016 0.068 (1190, 130) 1 (0.2, 0.2) false qr Float64 0.002 0.00076 0.068 (1190, 130) 1 (0.2, 0.2) true cg Float64 0.0054 0.00056 0.068 (1190, 130) 1 (0.2, 0.2) true pinv Float64 0.0054 0.00032 0.068 (1190, 130) 1 (0.2, 0.2) false pinv Float64 0.016 0.0016 0.068 (1190, 130) 1 (0.2, 0.2) true krylov_gpu Float64 0.032 0.0013 0.068 (1190, 130) 1 (0.2, 0.2)"},{"id":128,"pagetitle":"Solver benchmarks","title":"small-to-midsize: multi-channel","ref":"/UnfoldDocs/Unfold.jl/stable/references/benchmarks/#small-to-midsize:-multi-channel","content":" small-to-midsize: multi-channel n_channels = 128,\nsfreq = 100,\nn_splines = 4,\nn_repeats = 200;"},{"id":129,"pagetitle":"Solver benchmarks","title":"Float64","ref":"/UnfoldDocs/Unfold.jl/stable/references/benchmarks/#Float64","content":" Float64 gpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment true cholesky Float64 0.0068 (239522, 1210) 128 (0.2, 0.2) PosDefException(-1) true qr Float64 0.38 0.25 0.0068 (239522, 1210) 128 (0.2, 0.2) true pinv Float64 0.42 0.26 0.0068 (239522, 1210) 128 (0.2, 0.2) true intern Float64 0.7 0.25 0.0068 (239522, 1210) 128 (0.2, 0.2) true cg Float64 1.2 0.32 0.0068 (239522, 1210) 128 (0.2, 0.2) false cholesky Float64 1.5 0.31 0.0068 (239522, 1210) 128 (0.2, 0.2) false qr Float64 1.7 0.31 0.0068 (239522, 1210) 128 (0.2, 0.2) false cg Float64 2.0 0.3 0.0068 (239522, 1210) 128 (0.2, 0.2) false pinv Float64 2.1 0.38 0.0068 (239522, 1210) 128 (0.2, 0.2) true krylov_gpu Float64 5.9 0.4 0.0068 (239522, 1210) 128 (0.2, 0.2) false default_multi Float64 13.0 1.2 0.0068 (239522, 1210) 128 (0.2, 0.2) false intern Float64 13.0 1.7 0.0068 (239522, 1210) 128 (0.2, 0.2)"},{"id":130,"pagetitle":"Solver benchmarks","title":"Float32","ref":"/UnfoldDocs/Unfold.jl/stable/references/benchmarks/#Float32","content":" Float32 gpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment true cholesky Float32 0.0068 (239522, 1210) 128 (0.2, 0.2) PosDefException(-1) true krylov_gpu Float32 0.0068 (239522, 1210) 128 (0.2, 0.2) true pinv Float32 0.39 0.25 0.0068 (239522, 1210) 128 (0.2, 0.2) true qr Float32 0.62 0.24 0.0068 (239522, 1210) 128 (0.2, 0.2) true intern Float32 0.69 0.24 0.0068 (239522, 1210) 128 (0.2, 0.2) true cg Float32 1.2 0.31 0.0068 (239522, 1210) 128 (0.2, 0.2) false cholesky Float32 1.2 0.17 0.0068 (239522, 1210) 128 (0.2, 0.2) false cg Float32 1.3 0.16 0.0068 (239522, 1210) 128 (0.2, 0.2) false qr Float32 1.4 0.17 0.0068 (239522, 1210) 128 (0.2, 0.2) false pinv Float32 1.6 0.21 0.0068 (239522, 1210) 128 (0.2, 0.2) false intern Float32 13.0 0.86 0.0068 (239522, 1210) 128 (0.2, 0.2) false default_multi Float32 13.0 0.97 0.0068 (239522, 1210) 128 (0.2, 0.2)"},{"id":131,"pagetitle":"Solver benchmarks","title":"large, realistic model","ref":"/UnfoldDocs/Unfold.jl/stable/references/benchmarks/#large,-realistic-model","content":" large, realistic model     n_channels = 128,\n    sfreq = 500,\n    n_splines = (4, 4),\n    n_repeats = 500, gpu method el_type time GB percent_X_filled sizeDesign n_channels overlap comment true cholesky Float64 0.0015 (3001479, 9616) 128 (0.2, 0.2) PosDefException(-1) false cholesky Float64 0.0015 (3001479, 9616) 128 (0.2, 0.2) PosDefException(2760) false intern Float64 0.0015 (3001479, 9616) 128 (0.2, 0.2) SingularException(9599) true cg Float64 9.3 3.6 0.0015 (3001479, 9616) 128 (0.2, 0.2) true qr Float64 11.0 3.5 0.0015 (3001479, 9616) 128 (0.2, 0.2) true intern Float64 13.0 3.5 0.0015 (3001479, 9616) 128 (0.2, 0.2) false qr Float64 80.0 6.3 0.0015 (3001479, 9616) 128 (0.2, 0.2) true pinv Float64 80.0 4.2 0.0015 (3001479, 9616) 128 (0.2, 0.2) true krylov_gpu Float64 107.0 3.9 0.0015 (3001479, 9616) 128 (0.2, 0.2) false default_multi Float64 500.0 15.0 0.0015 (3001479, 9616) 128 (0.2, 0.2) false pinv Float64 520.0 11.0 0.0015 (3001479, 9616) 128 (0.2, 0.2) false cg Float64 939.0 5.7 0.0015 (3001479, 9616) 128 (0.2, 0.2)"},{"id":134,"pagetitle":"Overview of package extensions","title":"Package-extensions","ref":"/UnfoldDocs/Unfold.jl/stable/references/extensions/#Package-extensions","content":" Package-extensions In  Julia 1.9 Package Extensions were introduced. Unfold.jl is making use of them in four ways. Prior to using some functionality, you have to add + load specific package(s) for the functionality to be available. The reason for this is, that if you don't need e.g. GPU-support, you also will not need to install it."},{"id":135,"pagetitle":"Overview of package extensions","title":"GPU: Krylov,CUDA","ref":"/UnfoldDocs/Unfold.jl/stable/references/extensions/#GPU:-Krylov,CUDA","content":" GPU: Krylov,CUDA To use gpu support as described in @Ref(custom_solvers) you have to: using Krylov,CUDA\nusing Unfold"},{"id":136,"pagetitle":"Overview of package extensions","title":"RobustSolvers.jl","ref":"/UnfoldDocs/Unfold.jl/stable/references/extensions/#RobustSolvers.jl","content":" RobustSolvers.jl To use robust (outlier-\"safe\") solvers support as described in @Ref(custom_solvers) you have to: import RobustSolvers\nusing Unfold"},{"id":137,"pagetitle":"Overview of package extensions","title":"Non-linear effects: BSplineKit.jl","ref":"/UnfoldDocs/Unfold.jl/stable/references/extensions/#Non-linear-effects:-BSplineKit.jl","content":" Non-linear effects: BSplineKit.jl Finally to use non-linear effects/splines like in  @formula 0~1+spl(continuous,5)  you have to use: import BSplineKit\nusing Unfold Note In principle you should be able to load the package after loading Unfold. But sometimes this doesnt work, a  Base.retry_load_extensions()  call might help in these situations."},{"id":140,"pagetitle":"API: Functions","title":"Effects.effects","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Effects.effects-Union{Tuple{T}, Tuple{AbstractDict, T}} where T<:UnfoldModel","content":" Effects.effects  —  Method effects(design::AbstractDict, model::UnfoldModel; typical = mean) Calculates marginal effects for all term combinations in  design . Implementation based on Effects.jl package; likely could repackage in UnfoldEffects.jl; somebody wants to do it? This would make it easier to cross-maintain it to changes/bug fixes in the Effects.jl package.  design  is a dictionary containing those predictors (as keys) with levels (as values), that you want to evaluate. The  typical  refers to the value, which other predictors that are not specified in the dictionary, should take on. For MixedModels, the returned effects are based on the \"typical\" subject, i.e. all random effects are put to 0. Example  julia> f = @formula 0 ~ categoricalA + continuousA + continuousB\n julia> uf = fit(UnfoldModel, (Any => (f, times)), data, events)\n julia> d = Dict(:categorical => [\"levelA\", \"levelB\"], :continuous => [-2, 0, 2])\n julia> effects(d, uf) will result in 6 predicted values: A/-2, A/0, A/2, B/-2, B/0, B/2. source"},{"id":141,"pagetitle":"API: Functions","title":"FileIO.load","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#FileIO.load-Tuple{Any, Type{<:UnfoldModel}}","content":" FileIO.load  —  Method FileIO.load(file, ::Type{<:UnfoldModel}; generate_Xs=true) Load UnfoldModel from a .jld2 file. By default, the designmatrix is reconstructed. If it is not needed set  generate_Xs=false  which improves time-efficiency. source"},{"id":142,"pagetitle":"API: Functions","title":"FileIO.save","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#FileIO.save-Union{Tuple{T}, Tuple{Any, T}} where T<:UnfoldModel","content":" FileIO.save  —  Method FileIO.save(file, uf::T; compress=false) where {T<:UnfoldModel} Save UnfoldModel in a (by default uncompressed) .jld2 file. For memory efficiency the designmatrix is set to missing. If needed, it can be reconstructed when loading the model. source"},{"id":143,"pagetitle":"API: Functions","title":"StatsAPI.coefnames","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#StatsAPI.coefnames-Tuple{Unfold.TimeExpandedTerm}","content":" StatsAPI.coefnames  —  Method coefnames(term)\n coefnames of a TimeExpandedTerm concatenates the basis-function name with the kronecker product of the term name and the basis-function colnames. Separator is ' : ' Some examples for a firbasis:         basis 313 : (Intercept) : 0.1         basis 313 : (Intercept) : 0.2         basis_313 : (Intercept) : 0.3         ... source"},{"id":144,"pagetitle":"API: Functions","title":"StatsAPI.fit","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#StatsAPI.fit-Union{Tuple{T}, Tuple{Type{T}, StatsModels.FormulaTerm, DataFrames.AbstractDataFrame, AbstractArray, Union{Unfold.BasisFunction, AbstractArray}}} where T<:UnfoldModel","content":" StatsAPI.fit  —  Method fit(type::UnfoldModel,d::Vector{Pair},tbl::AbstractDataFrame,data::Array)\nfit(type::UnfoldModel,f::FormulaTerm,tbl::AbstractDataFrame,data::Array{T,3},times)\nfit(type::UnfoldModel,f::FormulaTerm,tbl::AbstractDataFrame,data::Array{T,2},basisfunction::BasisFunction) Generates Designmatrix & fits model, either mass-univariate (one model per epoched-timepoint) or time-expanded (modeling linear overlap). keyword arguments fit::Bool  (default:  true ) - fit the model after constructing the designmatrix. Setting this to  false  is sometimes helpful if you only want to inspect the designmatrix. contrasts::Dict : (default:  Dict() ) contrast to be applied to formula. Example:  Dict(:my_condition=>EffectsCoding()) . More information here: https://juliastats.org/StatsModels.jl/stable/contrasts/ eventcolumn::Union{Symbol,String}  (default  :event ) - the column in  tbl  to differentiate the basisfunctions as defined in  d::Vector{Pair} solver::function : (default:  solver_default ). The solver used for  y=Xb , e.g.  (X,y;kwargs...) -> solver_default(X,y;kwargs...) . There are faster & alternative solvers available, see  solver_predefined  for a list of options, see  solver benchmark  in the online documentation. To use the GPU, you can provide the data as a  CuArray  after  using CUDA . Please change the solver to e.g.  solver_predef(X,y;solver=:qr)  as lsmr+cuda => crash typically. It's worth though, speed increases >100x possible show_progress::Bool  (default  true ) - show progress via ProgressMeter - passed to  solver eventfields::Array: (optional, default [:latency] ) Array of symbols, representing column names in tbl`, which are passed to basisfunction event-wise. First field of array always defines eventonset in samples. If a  Vector[Pairs]  is provided, it has to have one of the following structures: For  deconvolution  analyses (use  Any=>(f,bf)  to match all rows of  tbl  in one basis functions). Assumes  data  is a continuous EEG stream, either a  Vector  or a  ch x time Matrix f1 = @formula(0~1+my_condition)\n[\n :A=>(f1,firbasis((-0.1,1),128), # sfreq = 128Hz\n :B=>(f2,firbasis((-3,2),128)\n] for  mass-univariate  analyses without deconvolution. Assumes  data  to be cut into epochs already (see  Unfold.epoch ). Follows  eeglab  standard  ch x time x trials : timesvector = range(-0.1,3,step=1/100)\n[\n :A=>(f1,timesvector),\n :B=>(f2,timesvector)\n] Notes The  type  can be specified directly as well e.g.  fit(type::UnfoldLinearModel)  instead of relying on the automatic inference The data is reshaped if it is missing one dimension to have the first dimension then  1  \"Channel\". Examples Mass Univariate Linear julia> data,evts = UnfoldSim.predef_eeg()\njulia> data_e,times = Unfold.epoch(data=data,tbl=evts,τ=(-1.,1.9),sfreq=100) # cut the data into epochs. data_e is now ch x times x epoch\n\njulia> f  = @formula 0~1+continuousA+continuousB\njulia> model = fit(UnfoldModel,f,evts,data_e,times)\n# or:\njulia> model = fit(UnfoldModel,[Any=>(f,times)],evts,data_e) Timexpanded Univariate Linear julia> basisfunction = firbasis(τ=(-1,1),sfreq=10)\njulia> model = fit(UnfoldModel,f,evts,data,basisfunction)\n# or\njulia> model = fit(UnfoldModel,[Any=>(f,basisfunction],evts,data) source"},{"id":145,"pagetitle":"API: Functions","title":"StatsAPI.modelmatrix","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#StatsAPI.modelmatrix","content":" StatsAPI.modelmatrix  —  Function StatsModels.modelmatrix(uf::UnfoldLinearModelContinuousTime, basisfunction = true) Setting the optional second args to false, will return the modelmatrix without the timeexpansion / basisfunction applied. source"},{"id":146,"pagetitle":"API: Functions","title":"StatsAPI.modelmatrix","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#StatsAPI.modelmatrix-Tuple{UnfoldLinearModel, Any}","content":" StatsAPI.modelmatrix  —  Method modelmatrix(uf::UnfoldLinearModel) returns the modelmatrix of the model. Concatenates them, except in the MassUnivariate cases, where a vector of modelmatrices is return Compare with  modelmatrices  which returns a vector of modelmatrices, one per event source"},{"id":147,"pagetitle":"API: Functions","title":"StatsAPI.predict","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#StatsAPI.predict-Tuple{Any, Vector{<:StatsModels.FormulaTerm}, Vector{<:DataFrames.DataFrame}}","content":" StatsAPI.predict  —  Method function predict(\n    uf::UnfoldModel,\n    f::Vector{<:FormulaTerm},\n    evts::Vector{<:DataFrame};\n    overlap::Bool = true,\n    kwargs...\n) Returns a predicted (\"y_hat = X*b\")  Array . uf  is an  <:UnfoldModel f  is a (vector of) formulas, typically  Unfold.formulas(uf) , but formulas can be modified e.g. by  effects . evts  is a (vector of) events, can be  Unfold.events(uf)  to return the (possibly continuous-time) predictions of the model. Can be a custom even kwargs: if  overlap = true  (default), overlap based on the  latency  column of  evts  will be simulated, or in the case of  !ContinuousTimeTrait  just X*coef is returned. if  overlap = false , returns predictions without overlap (models with  ContinuousTimeTrait  (=> with basisfunction / deconvolution) only), via  predict_no_overlap if  keep_basis  or  exclude_basis  is defined, then  predict_partial_overlap  is called, which allows to selective introduce overlap based on specified (or excluded respective) events/basisfunctions epoch_to  and   epoch_timewindow : calculate (partial) overlap controlled predictions, but returns them at the specified  epoch_at  event, with the times  epoch_timewindow  (default is taken from the basisfunction) in samples. eventcolumn  can be specified as well if different from the default  event . Hint: all  kwargs  can be  Vector , or if e.g.  string  types are provided, will be put into a  length==1  vector. Output If  overlap=false , returns a 3D-Array If  overlap=true  and  epoch_to = nothing  (default), returns a 2D-array If  overlap=true  and  epoch_to != nothing , returns a 3D array source"},{"id":148,"pagetitle":"API: Functions","title":"StatsModels.modelcols","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#StatsModels.modelcols-Tuple{Unfold.TimeExpandedTerm, Any}","content":" StatsModels.modelcols  —  Method modelcols(term, tbl)\n calculates the actual designmatrix for a timeexpandedterm. Multiple dispatch on StatsModels.modelcols source"},{"id":149,"pagetitle":"API: Functions","title":"Unfold._modelcols","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold._modelcols-Tuple{StatsModels.FormulaTerm, Any}","content":" Unfold._modelcols  —  Method _modelcols(form::FormulaTerm, events) source"},{"id":150,"pagetitle":"API: Functions","title":"Unfold._modelcols","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold._modelcols-Tuple{Vector, Vector}","content":" Unfold._modelcols  —  Method _modelcols(forms::Vector,events::Vector) A wrapper around StatsModels.modelcols that is only needed for easy multiple dispatch source"},{"id":151,"pagetitle":"API: Functions","title":"Unfold.apply_basisfunction","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.apply_basisfunction-Tuple{Any, Unfold.BasisFunction, Any, Any}","content":" Unfold.apply_basisfunction  —  Method apply_basisfunction(\n    form,\n    basisfunction,\n    eventfields,\n    eventname\n)\n timeexpand the rhs-term of the formula with the basisfunction source"},{"id":152,"pagetitle":"API: Functions","title":"Unfold.combine_yhat!","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.combine_yhat!-Union{Tuple{T}, Tuple{Vector{<:Array{T}}, Array{T}}} where T","content":" Unfold.combine_yhat!  —  Method combine_yhat(list,single) combines single into list, if either list or single contains missing, automatically casts the respective counter-part to allow missings as well source"},{"id":153,"pagetitle":"API: Functions","title":"Unfold.design_to_modeltype","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.design_to_modeltype-Tuple{Any, Unfold.BasisFunction}","content":" Unfold.design_to_modeltype  —  Method !!! Important:    this is an ugly hack dating back to the time where UnfoldMixedModels was still an extension. We are overloading this function in UnfoldMixedModels.jl with a more specific type, to switch between MixedModels-Unfold types and not... source"},{"id":154,"pagetitle":"API: Functions","title":"Unfold.designmatrix","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.designmatrix-Tuple{Any, Any, Any}","content":" Unfold.designmatrix  —  Method designmatrix(type, f, tbl; kwargs...) call without basis function, continue with basisfunction =  nothing source"},{"id":155,"pagetitle":"API: Functions","title":"Unfold.designmatrix","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.designmatrix-Tuple{Type{<:UnfoldModel}, Union{Tuple, StatsModels.FormulaTerm}, Any, Any}","content":" Unfold.designmatrix  —  Method designmatrix(\n    unfoldmodeltype,\n    f,\n    tbl,\n    basisfunction;\n    contrasts,\n    eventname,\n    kwargs...\n)\n designmatrix(type, f, tbl; kwargs...) Return a  DesignMatrix  used to fit the models. Arguments type::UnfoldModel f::FormulaTerm: Formula to be used in this designmatrix tbl: Events (usually a data frame) to be modelled basisfunction::BasisFunction: basisfunction to be used in modeling (if specified) contrasts::Dict: (optional) contrast to be applied to formula eventfields::Array: (optional) Array of symbols which are passed to basisfunction event-wise. First field of array always defines eventonset in samples. Default is [:latency] Examples julia>  designmatrix(UnfoldLinearModelContinuousTime,Dict(Any=>(f,basisfunction1),tbl) source"},{"id":156,"pagetitle":"API: Functions","title":"Unfold.designmatrix","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.designmatrix-Tuple{Type{<:UnfoldModel}, Vector{<:Pair}, Any}","content":" Unfold.designmatrix  —  Method designmatrix(\n    T::Type{<:UnfoldModel},\n    design_array::Vector{<:Pair},\n    tbl;\n    eventcolumn = :event,\n    contrasts = Dict{Symbol,Any}(),\n    kwargs..., iteratively calls  designmatrix  for each event in the design_array, and returns a list of  <:AbstractDesignMatrix source"},{"id":157,"pagetitle":"API: Functions","title":"Unfold.designmatrix","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.designmatrix-Tuple{UnfoldModel, Any}","content":" Unfold.designmatrix  —  Method designmatrix(\n    uf::UnfoldModel,\n    tbl;\n    eventcolumn = :event,\n    contrasts = Dict{Symbol,Any}(),\n    kwargs..., Main function called from  fit(UnfoldModel...) , generates the designmatrix, returns a list of  <:AbstractDesignMatrix source"},{"id":158,"pagetitle":"API: Functions","title":"Unfold.drop_missing_epochs","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.drop_missing_epochs-Union{Tuple{T}, Tuple{Any, AbstractArray{T, 3}}} where T","content":" Unfold.drop_missing_epochs  —  Method [X,y] = drop_missing_epochs(X, y::Array) Helper function to remove epochs of  y  that contain missings. Drops them from both  X  and   y . Often used in combination with  Unfold.epoch X can be anything that has two dimensions (Matrix, DataFrame etc) source"},{"id":159,"pagetitle":"API: Functions","title":"Unfold.empty_modelmatrix","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.empty_modelmatrix-Tuple{AbstractDesignMatrix}","content":" Unfold.empty_modelmatrix  —  Method empty_modelmatrix(d::AbstractDesignMatrix) returns an empty modelmatrix of the type DesignMatrix type of  d source"},{"id":160,"pagetitle":"API: Functions","title":"Unfold.epoch","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.epoch-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Any}} where T<:Union{Missing, Number}","content":" Unfold.epoch  —  Method epoch(data::Array{T,1},evts::DataFrame,τ::Tuple/Vector,sfreq;kwargs..., Basic function to epoch data; all input also available as kwargs. Additional kwarg:  eventtime =:latency, which defines the column in  evts  that is used to cut the data (in samples). For uneven sample-times we use  round() ` source"},{"id":161,"pagetitle":"API: Functions","title":"Unfold.equalize_size","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.equalize_size-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractMatrix{T}}} where T<:(Union{Missing, var\"#s132\"} where var\"#s132\"<:Number)","content":" Unfold.equalize_size  —  Method equalize_size(X, data)\n Equates the length of data and designmatrix by cutting the shorter one The reason we need this is because when generating the designmatrix, we do not know how long the data actually are. We only assume that event-latencies are synchronized with the data source"},{"id":162,"pagetitle":"API: Functions","title":"Unfold.firbasis","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.firbasis","content":" Unfold.firbasis  —  Function firbasis(τ, sfreq; ...)\nfirbasis(τ, sfreq, name; interpolate, scale_duration)\n Generate a sparse FIR basis around the  τ  timevector at sampling rate  sfreq . This is useful if you cannot make any assumptions on the shape of the event responses. If unrounded events are supplied, they are split between samples. E.g. event-latency = 1.2 will result in a \"0.8\" and a \"0.2\" entry. Advanced: second input can be duration in samples - careful:  times(firbasis)  always assumes duration = 1. Therefore, issues with LMM and predict will appear! keyword arguments interpolate  (Bool, default false): if true, interpolates events between samples linearly. This results in  predict  functions to return a trailling 0 scale_duration (Union{Bool,Interpolations-Interpolator}, default false):     if true, scales the response by the fit-kwargs eventfields second entry. That is, the FIR becomes a stepfunction instead of a impulse response.     if Interpolations.interpolator, e.g. Interpolations.Linear() - uses the fit-kwargs eventfields second entry to stretch the FIR kernel based on imresize`. This implements Hassall Examples Generate a FIR basis function from -0.1s to 0.3s at 100Hz julia>  f = firbasis([-0.1,0.3],100) Evaluate at an event occuring at sample 103.3 julia>  f(103.3) source"},{"id":163,"pagetitle":"API: Functions","title":"Unfold.firkernel","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.firkernel-Tuple{Any, Any}","content":" Unfold.firkernel  —  Method firkernel(ev, times; interpolate, scale_duration)\n Calculate a sparse firbasis second input can be duration in samples - careful:  times(firbasis)  always assumes duration = 1. Therefore, issues with LMM and predict will appear! Examples julia>  f = firkernel(103.3,range(-0.1,step=0.01,stop=0.31))\njulia>  f_dur = firkernel([103.3 4],range(-0.1,step=0.01,stop=0.31)) source"},{"id":164,"pagetitle":"API: Functions","title":"Unfold.formulas","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.formulas-Tuple{Vector{<:Pair}}","content":" Unfold.formulas  —  Method formulas(design::Vector{<:Pair}) returns vector of formulas, no schema has been applied (those formulas never saw the data). Also no timeexpansion has been applied (in the case of timecontinuous models) source"},{"id":165,"pagetitle":"API: Functions","title":"Unfold.get_basis_colnames","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.get_basis_colnames-Tuple{AbstractArray{<:StatsModels.FormulaTerm}}","content":" Unfold.get_basis_colnames  —  Method get_basis_colnames(m)\nget_basis_colnames(formulas) returns list of colnames - e.g. times for firbasis. source"},{"id":166,"pagetitle":"API: Functions","title":"Unfold.get_basis_indices","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.get_basis_indices-Tuple{Any, Vector}","content":" Unfold.get_basis_indices  —  Method get_basis_indices(uf, basisnames::Vector) returns a boolean vector with length spanning all coefficients, which coefficient is defined by  basisnames  (vector of names) source"},{"id":167,"pagetitle":"API: Functions","title":"Unfold.get_basis_names","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.get_basis_names-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T<:UnfoldModel","content":" Unfold.get_basis_names  —  Method get_basisnames(model::UnfoldModel) Return the basisnames for all predictor terms as a vector. The returned vector contains the name of the event type/basis, repeated by their actual coefficient number (after StatsModels.apply_schema / timeexpansion). If a model has more than one event type (e.g. stimulus and fixation), the vectors are concatenated. source"},{"id":168,"pagetitle":"API: Functions","title":"Unfold.hrfbasis","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.hrfbasis-Tuple{Float64}","content":" Unfold.hrfbasis  —  Method hrfbasis(TR; parameters, name)\n Generate a Hemodynamic-Response-Functio (HRF) basis with inverse-samplingrate \"TR\" (=1/FS) Optional Parameters p:                                                            defaults                                                           {seconds}         p(1) - delay of response (relative to onset)          6         p(2) - delay of undershoot (relative to onset)       16         p(3) - dispersion of response                         1         p(4) - dispersion of undershoot                       1         p(5) - ratio of response to undershoot                6         p(6) - onset {seconds}                                0         p(7) - length of kernel {seconds}                    32 Examples Generate a HRF basis function object with Sampling rate 1/TR. And evaluate it at an event occuring at TR 103.3 with duration of 4.1 TRs julia>  f = hrfbasis(2.3)\njulia>  f(103.3,4.1)\n source"},{"id":169,"pagetitle":"API: Functions","title":"Unfold.hrfkernel","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.hrfkernel-Tuple{Any, Any, Any}","content":" Unfold.hrfkernel  —  Method hrfkernel(e, TR, p)\n Calculate a HRF kernel. Input e can be [onset duration] Examples julia>  f = hrfkernel(103.3,2.3,[6. 16. 1. 1. 6. 0. 32.]) source"},{"id":170,"pagetitle":"API: Functions","title":"Unfold.linearize","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.linearize-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","content":" Unfold.linearize  —  Method linearize(x)\n Flatten a 1D array from of a 2D/3D array. Also drops the empty dimension source"},{"id":171,"pagetitle":"API: Functions","title":"Unfold.matrix_by_basisname","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.matrix_by_basisname-Tuple{AbstractMatrix, Any, Vector}","content":" Unfold.matrix_by_basisname  —  Method Returns a view of the Matrix  y , according to the indices of the timeexpanded  basisname source"},{"id":172,"pagetitle":"API: Functions","title":"Unfold.modelmatrices","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.modelmatrices-Tuple{AbstractDesignMatrix}","content":" Unfold.modelmatrices  —  Method modelmatrices(X::AbstractDesignMatrix)\nmodelmatrices(X::Vector{<:AbstractDesignMatrix})\nmodelmatrices(modelmatrix::AbstractMatrix) Returns the modelmatrices (also called designmatrices) separately for the events. This is similar to  StatsModels.modelcols , but merely access the precomputed designmatrix. If the designmatrix needs to be computed, please use  modelcols Compare to  modelmatrix  which further concatenates the designmatrices (in the ContinuousTime case). source"},{"id":173,"pagetitle":"API: Functions","title":"Unfold.predict_no_overlap","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.predict_no_overlap-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T, Any, Vector, Vector}} where T<:UnfoldModel","content":" Unfold.predict_no_overlap  —  Method predict_no_overlap(, uf, coefs, f, evts)\n in ContinuousTime case (typically the deconvolution model), we return idealized predictions without overlap between events. in the Not-ContinuousTime case (typically the MassUnivariate model), we return predictions for each event independently. In that case, the function is unfortunately a missnomer, as overlap cannot be removed from mass-univariate models. source"},{"id":174,"pagetitle":"API: Functions","title":"Unfold.predict_partial_overlap","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.predict_partial_overlap-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T, Any}} where T<:UnfoldModel","content":" Unfold.predict_partial_overlap  —  Method predict_partial_overlap(, uf, args; kwargs...)\n Returns predicted time-continuous values, but only for a subset of events. This is achieved by excluding the part of the designmatrix that belongs to the basisfunctions/events you do not want to have in your model. Typically called via  predict , for configuration, keyword-arguments and usage see there. One difference is, that we require the  coefs(uf::UnfoldModel)  already exctracted. Due to the time-continuous nature, running it with a model not containing the  ContinuousTimeTrait  it will throw an error. source"},{"id":175,"pagetitle":"API: Functions","title":"Unfold.predicttable","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.predicttable","content":" Unfold.predicttable  —  Function predicttable(model<:UnfoldModel,events=Unfold.events(model),args...;kwargs...) Shortcut to call efficiently call (pseudocode)  result_to_table(predict(...)) . Returns a tidy DataFrame with the predicted results. Loops all input to  predict , but really only makes sense to use if you specify either: overlap = false  (the default) or  epoch_to = \"eventname\" . source"},{"id":176,"pagetitle":"API: Functions","title":"Unfold.prepare","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.prepare-Union{Tuple{T}, Tuple{Any, AbstractMatrix{<:Union{Missing, T}}}} where T<:Number","content":" Unfold.prepare  —  Method prepare(X, data)\n convert and permutedim input to follow the following output: Ĥ, Y, X = prepare(X, data) where  Ĥ  is used to save the beta,  Y  is the data in format ch x repeat x time (with size(time) = 1 if data is a Matrix), and  X . if data is a CuArray, everything is transformed to CuArrays as well (via UnfoldCUDAExt.jl, CUDA needs to be loaded) same datatype between X and data is enforced source"},{"id":177,"pagetitle":"API: Functions","title":"Unfold.prepare_XTX","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.prepare_XTX-Tuple{Tuple}","content":" Unfold.prepare_XTX  —  Method prepare_XTX(all)\n instead of solving y = Xb, we solve X'Xb = X'y. This function calculates X'X and instantiates X'y to be used in the solver-step, to facilitate X'y calculations later, X' is also calculated. source"},{"id":178,"pagetitle":"API: Functions","title":"Unfold.prepare_pinv","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.prepare_pinv-Tuple{Tuple}","content":" Unfold.prepare_pinv  —  Method prepare_pinv(all)\n calculates pinv of the designmatrix for later use in the solver-step. This is helpful in case you have many chanels source"},{"id":179,"pagetitle":"API: Functions","title":"Unfold.result_to_table","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.result_to_table-Tuple{Any, Any, Vector{<:DataFrames.DataFrame}}","content":" Unfold.result_to_table  —  Method result_to_table(model<:UnfoldModel, eff::AbstractArray, events::Vector{<:DataFrame})\nresult_to_table(\n    eff::AbstractArray,\n    events::Vector{<:DataFrame},\n    times::Vector{<:Vector{<:Number}},\n    eventnames::Vector)\nresult_to_table(\n    eff::Vector{<:AbstractArray},\n    events::Vector{<:DataFrame},\n    times::Vector,\n    eventnames::Vector,\n) Converts an array-result (prediction or coefficient) together with the events, to a tidy dataframe. To support multi-event models, we expect everything to be put into  Vectors  - this should be refactored at some point to be compatible with broadcasting, but it is not right now. args eff : A vector that contains the array(s) to be converted to a tidy dataframe. Each event in your events dataframe your have it's own array (i.e. the array should have  length(eff) == length(unique(events.event)) ). Each array should be 3D, with channel x time x predictor  events : A vector of event-dataframes, each need to match  size(eff,3) . Each individual event ( unique(events.event) ) should have it's own dataframe. E.g.  [[df_event1::DataFrame], [df_event1::DataFrame]] times : A vector of time-vectors with length(eff) , each time-vector needs to match size.(eff,2) eventnames`: A vector of eventnames, either symbols or strings, should be a single entry per event source"},{"id":180,"pagetitle":"API: Functions","title":"Unfold.solver_default","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.solver_default-Tuple{Any, AbstractMatrix}","content":" Unfold.solver_default  —  Method solver_default(X, y; kwargs...)\n default solvers. If data is continuous (2D), we solve Xb = y via lsmr If data is epoched (3D) we solve Xb = y via pinv We highly recommend to check out  solver_predefined  for faster options by rather solving X'Xb = X'y via QR, cholesky, pinv or ``-solver. A benchmark is available in the online documentation. Please see  ?solver_main  for keyword arguments of the solver (like  stderror ,  multithreading ,  show_time ,  show_progress ) source"},{"id":181,"pagetitle":"API: Functions","title":"Unfold.solver_predefined","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.solver_predefined-Tuple{Any, AbstractMatrix}","content":" Unfold.solver_predefined  —  Method solver_predefined(X, y_in; solver, kwargs...)\n helper function that returns solver with appropriate prepare-pipelines and fitting solver-functions. X is a (typically sparse) designmatrix, y is a 2D or 3D array. solver  : one of  :cg ,  :pinv ,  :intern ,  :qr ,  :cholesky ,  :lsmr  (default) Only  lsmr  solves Xb = y via an iterative solver and should be more accurate in principle. The other predefined-solvers solve X'Xb = X'y which is often computationally much cheaper, and because X'X can be precalculated, it should be cheaper to apply. Testing this empirically is somewhat complicated, as depending on your sparsity structure (≈ your design) and the size of your data (sfreq & minutes) the best solver and the reached accuracy can change quite a bit. GPU All solvers except :lsmr support GPU calculations. For lsmr on the GPU try  solver_krylov  instead source"},{"id":182,"pagetitle":"API: Functions","title":"Unfold.spdiagm_diag","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.spdiagm_diag-Union{Tuple{T}, Tuple{Any, Vararg{Pair{<:Integer, T}}}} where T","content":" Unfold.spdiagm_diag  —  Method Speed improved version of spdiagm, takes a single float value instead of a vector, like a version of spdiagm that takes in a UniformScaling e.g. sz = 5 ix = [1,3,10] spdiagm_diag(sz,(.-ix.=>1)...) source"},{"id":183,"pagetitle":"API: Functions","title":"Unfold.time_expand_allBasesSameCols","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.time_expand_allBasesSameCols-Tuple{FIRBasis, Any, Any}","content":" Unfold.time_expand_allBasesSameCols  —  Method Helper function to decide whether all bases have the same number of columns per event source"},{"id":184,"pagetitle":"API: Functions","title":"Unfold.timeexpand_cols","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.timeexpand_cols-NTuple{4, Any}","content":" Unfold.timeexpand_cols  —  Method timeexpand_cols(basisfunction, bases, ncolsBasis, ncolsX)\n calculates in which rows the individual event-basisfunctions should go in Xdc see also timeexpand rows timeexpand vals source"},{"id":185,"pagetitle":"API: Functions","title":"Unfold.timeexpand_rows","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.timeexpand_rows-NTuple{4, Any}","content":" Unfold.timeexpand_rows  —  Method timeexpand_rows(onsets, bases, shift, ncolsX)\n calculates in which rows the individual event-basisfunctions should go in Xdc timeexpand rows timeexpand vals source"},{"id":186,"pagetitle":"API: Functions","title":"Unfold.times","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.times-Union{Tuple{T}, Tuple{Type{SimpleTraits.Not{Unfold.ContinuousTimeTrait{T}}}, T}} where T<:UnfoldModel","content":" Unfold.times  —  Method times(model<:UnfoldModel) returns arrays of time-vectors, one for each basisfunction / parallel-fitted-model (MassUnivarite case) source"},{"id":187,"pagetitle":"API: Functions","title":"Unfold.unfold_apply_schema","ref":"/UnfoldDocs/Unfold.jl/stable/references/functions/#Unfold.unfold_apply_schema-Tuple{Any, Any, Any}","content":" Unfold.unfold_apply_schema  —  Method wrapper to make apply_schema mixed models as extension possible Note: type is not necessary here, but for LMM it is for multiple dispatch reasons! source"},{"id":190,"pagetitle":"API: Types","title":"Unfold.AbstractModelFit","ref":"/UnfoldDocs/Unfold.jl/stable/references/types/#Unfold.AbstractModelFit","content":" Unfold.AbstractModelFit  —  Type Abstract Type to report modelresults source"},{"id":191,"pagetitle":"API: Types","title":"Unfold.BasisFunction","ref":"/UnfoldDocs/Unfold.jl/stable/references/types/#Unfold.BasisFunction","content":" Unfold.BasisFunction  —  Type See FIRBasis for an examples a BasisFunction should implement: kernel() # kernel(b::BasisFunction,sample) => returns the designmatrix for that event height() # number of samples in continuous time, NaN if not defined width()  # number of coefficient columns (e.g. HRF 1 to 3, FIR=height(),except if interpolate=true ) colnames() # unique names of expanded columns times() # vector of times along expanded columns, length = height() name() # name of basisfunction collabel() [default \"colname_basis\"] # name for coeftable shift_onset() [default 0] source"},{"id":192,"pagetitle":"API: Types","title":"Unfold.DesignMatrixLinearModel","ref":"/UnfoldDocs/Unfold.jl/stable/references/types/#Unfold.DesignMatrixLinearModel","content":" Unfold.DesignMatrixLinearModel  —  Type DesignMatrix Type that keeps an Array of   formulas , designmatrices  modelmatrix  (Array or Array of Arrays in case of MixedModel) and  events -dataframe source"},{"id":193,"pagetitle":"API: Types","title":"Unfold.FIRBasis","ref":"/UnfoldDocs/Unfold.jl/stable/references/types/#Unfold.FIRBasis","content":" Unfold.FIRBasis  —  Type Defines a FIRBasisfunction which can be called for each event, defining the time-expanded basis kernel mutable struct FIRBasis <: Unfold.BasisFunction times : vector of times along rows of kernel-output (in seconds) name : name of the event, should be the actual eventName in  eventcolumn  of the dataframes later shift_onset : by how many samples do we need to shift the event onsets? This number is determined by how many 'negative' timepoints the basisfunction defines interpolate : should we linearly interpolate events not on full samples? scale_duration : should we scale kernel to the duration? If yes, with which method (tipp: most users would you want to call firbasis, not generate it manually) Examples julia>  b = FIRBasis(range(0,1,length=10),\"basisA\",-1) source"},{"id":194,"pagetitle":"API: Types","title":"Unfold.LinearModelFit","ref":"/UnfoldDocs/Unfold.jl/stable/references/types/#Unfold.LinearModelFit","content":" Unfold.LinearModelFit  —  Type Contains the results of linearmodels (continuous and not) source"},{"id":195,"pagetitle":"API: Types","title":"Unfold.TimeExpandedTerm","ref":"/UnfoldDocs/Unfold.jl/stable/references/types/#Unfold.TimeExpandedTerm","content":" Unfold.TimeExpandedTerm  —  Type Object with a  term  and an applicable  BasisFunction  and a eventfield that are later passed to the basisfunction. struct TimeExpandedTerm{T<:StatsModels.AbstractTerm} <: StatsModels.AbstractTerm term : Term that the basis function is applied to. This is regularly called in other functions to get e.g. term-coefnames and timeexpand those basisfunction : Kernel that determines what should happen to the designmatrix of the term eventfields : Which fields of the event-table should be passed to the basisfunction.Important: The first entry has to be the event-latency in samples! Examples julia>  b = TimeExpandedTerm(term,kernel,[:latencyTR,:durationTR]) source"},{"id":196,"pagetitle":"API: Types","title":"Unfold.UnfoldLinearModel","ref":"/UnfoldDocs/Unfold.jl/stable/references/types/#Unfold.UnfoldLinearModel","content":" Unfold.UnfoldLinearModel  —  Type Concrete type to implement an Mass-Univariate LinearModel.  .design  contains the formula + times dict  .designmatrix  contains a  DesignMatrix modelfit  is a  Any  container for the model results source"},{"id":197,"pagetitle":"API: Types","title":"Unfold.UnfoldLinearModelContinuousTime","ref":"/UnfoldDocs/Unfold.jl/stable/references/types/#Unfold.UnfoldLinearModelContinuousTime","content":" Unfold.UnfoldLinearModelContinuousTime  —  Type Concrete type to implement an deconvolution LinearModel.  .design  contains the formula + times dict  .designmatrix  contains a  DesignMatrix modelfit  is a  Any  container for the model results source"},{"id":198,"pagetitle":"API: Types","title":"Unfold.UnfoldModel","ref":"/UnfoldDocs/Unfold.jl/stable/references/types/#Unfold.UnfoldModel","content":" Unfold.UnfoldModel  —  Type using Base: @deprecate_binding The main abstract model-type of the toolbox. E.g.  UnfoldLinearModel  is a concrete type of this source"},{"id":201,"pagetitle":"rERP (mass univariate)","title":"Mass Univariate Linear Models (no overlap correction)","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_mu/#lm_massunivariate","content":" Mass Univariate Linear Models (no overlap correction) In this notebook we will fit regression models to simulated EEG data. We will see that we need some type of overlap correction, as the events are close in time to each other, so that the respective brain responses overlap. If you want more detailed introduction to this topic check out  our paper ."},{"id":202,"pagetitle":"rERP (mass univariate)","title":"Setting up & loading the data","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_mu/#Setting-up-and-loading-the-data","content":" Setting up & loading the data using DataFrames\nusing Unfold\nusing UnfoldMakie, CairoMakie # for plotting\nusing UnfoldSim"},{"id":203,"pagetitle":"rERP (mass univariate)","title":"Load Data","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_mu/#Load-Data","content":" Load Data We'll start with some predefined simulated continuos EEG data. We have 2000 events, 1 channel and one condition with two levels data, evts = UnfoldSim.predef_eeg()"},{"id":204,"pagetitle":"rERP (mass univariate)","title":"Inspection","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_mu/#Inspection","content":" Inspection The data has only little noise. The underlying signal pattern is a positive-negative-positive spike. times_cont = range(0,length=200,step=1/100) # we simulated with 100hz for 0.5 seconds\n\nf,ax,h = plot(times_cont,data[1:200])\nvlines!(evts[evts.latency .<= 200, :latency] ./ 100;color=:black) # show events, latency in samples!\nax.xlabel = \"time [s]\"\nax.ylabel = \"voltage [µV]\"\nf To inspect the event dataframe we use show(first(evts, 6), allcols = true) 6×3 DataFrame\n Row │ continuous  condition  latency\n     │ Float64     String     Int64\n─────┼────────────────────────────────\n   1 │   2.77778   car             62\n   2 │  -5.0       face           132\n   3 │  -1.66667   car            196\n   4 │  -5.0       car            249\n   5 │   5.0       car            303\n   6 │  -0.555556  car            366 Every row is an experimental event. Note that  :latency  refers to time in samples, (in BIDS-specification,   :onset  would typically refer to seconds)."},{"id":205,"pagetitle":"rERP (mass univariate)","title":"Traditional Mass Univariate Analysis","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_mu/#Traditional-Mass-Univariate-Analysis","content":" Traditional Mass Univariate Analysis To perform a mass univariate analysis, you must complete the following steps: Split data into epochs Specify a formula Fit a linear model to each time point & channel Visualize the results."},{"id":206,"pagetitle":"rERP (mass univariate)","title":"1. Split data into epochs","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_mu/#1.-Split-data-into-epochs","content":" 1. Split data into epochs Initially, you have data with a duration that represents the whole experimental trial. You need to cut the data into small regular epochs related to the some event, e.g. start of fixation. # Unfold supports multi-channel, so we could provide matrix ch x time, which we can create like this from a vector:\ndata_r = reshape(data, (1,:))\n# cut the data into epochs\ndata_epochs, times = Unfold.epoch(data = data, tbl = evts, τ = (-0.4, 0.8), sfreq = 100); # channel x timesteps x trials\nsize(data_epochs) (1, 121, 2000) τ  specifies the epoch size. sfreq  - sampling rate, converts  τ  to samples. typeof(data_epochs) Array{Union{Missing, Float64}, 3} Note In julia,  missing  is supported throughout the ecosystem. Thus, we can have partial trials and they will be incorporated / ignored at the respective functions. Helpful functions are the julia-base  disallowmissing  and the internal  Unfold.drop_missing_epochs  functions"},{"id":207,"pagetitle":"rERP (mass univariate)","title":"2. Specify a formula","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_mu/#2.-Specify-a-formula","content":" 2. Specify a formula Define a formula to be applied to each time point (and each channel) relative to the event.  condition  and  continuous  are the names of the event-describing columns in  evts  that we want to use for modelling. f = @formula 0 ~ 1 + condition + continuous # note the formulas left side is `0 ~ ` for technical reasons`"},{"id":208,"pagetitle":"rERP (mass univariate)","title":"3. Fit a linear model to each time point & channel","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_mu/#3.-Fit-a-linear-model-to-each-time-point-and-channel","content":" 3. Fit a linear model to each time point & channel Fit the \" UnfoldModel \" (the  fit  syntax is used throughout the Julia ecosystem, with the first element indicating what kind of model to fit) m = fit(UnfoldModel, f, evts, data_epochs, times); ┌ Warning: Missings in data - we remove any trial from data and designmatrix\n└ @ Unfold ~/work/Unfold.jl/Unfold.jl/src/solver/prepare.jl:19 Alternative way to call this model is below. This syntax allows you to fit multiple events at once. For example, replacing  Any  with  :fixation =>...  will fit this model specifically to the fixation event type. m = fit(UnfoldModel, [Any=>(f, times)], evts, data_epochs); ┌ Warning: Missings in data - we remove any trial from data and designmatrix\n└ @ Unfold ~/work/Unfold.jl/Unfold.jl/src/solver/prepare.jl:19 Inspect the fitted model: m Note these functions to discover the model:  design ,  designmatrix ,  modelfit  and most importantly,  coeftable . Info There are of course further methods, e.g. `coef`, `ranef`, `Unfold.formula`, `modelmatrix` which might be helpful at some point, but not important now. Using  coeftable , we can get a  tidy  DataFrames, very useful for your further analysis. first(coeftable(m), 6) 6×7 DataFrame Row channel coefname estimate eventname group stderror time Int64 String Float64 DataType Nothing Nothing Float64 1 1 (Intercept) 0.328882 Any -0.4 2 1 (Intercept) 0.462337 Any -0.39 3 1 (Intercept) 0.694753 Any -0.38 4 1 (Intercept) 1.04318 Any -0.37 5 1 (Intercept) 1.47384 Any -0.36 6 1 (Intercept) 1.9311 Any -0.35"},{"id":209,"pagetitle":"rERP (mass univariate)","title":"4. Visualize the results","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_mu/#4.-Visualize-the-results","content":" 4. Visualize the results Tidy DataFrames are easy to visualize using e.g. AlgebraOfGraphics.jl. Function  plot_erp  from  UnfoldMakie makes it even easier. results = coeftable(m)\nplot_erp(results) As you can see, there is a lot going on, even in the baseline period! This is because the signal was simulated with overlapping events. In the next tutorial you will learn how to fix this."},{"id":212,"pagetitle":"rERP (overlap correction)","title":"Linear Model with Overlap Correction","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_overlap/#lm_overlap","content":" Linear Model with Overlap Correction Note We recommend you briefly go over the mass-univariate linear modelling tutorial In this notebook we will fit regression models to (simulated) EEG data. We will see that we need some type of overlap correction, as the events are close in time to each other, so that the respective brain responses overlap. If you want more detailed introduction to this topic check out  our paper ."},{"id":213,"pagetitle":"rERP (overlap correction)","title":"Setting up & loading the data","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_overlap/#Setting-up-and-loading-the-data","content":" Setting up & loading the data using Unfold\nusing UnfoldSim\nusing UnfoldMakie,CairoMakie\nusing DataFrames\n\ndata, evts = UnfoldSim.predef_eeg()"},{"id":214,"pagetitle":"rERP (overlap correction)","title":"Overlap Correction","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_overlap/#Overlap-Correction","content":" Overlap Correction For an overlap correction analysis we will do one additional step: define a temporal basisfunction. The steps are as following: specify a temporal basisfunction specify a formula fit a linear model for each channel (one for all timepoints!) visualize the results."},{"id":215,"pagetitle":"rERP (overlap correction)","title":"Timeexpanded / Deconvolved ModelFit","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_overlap/#Timeexpanded-/-Deconvolved-ModelFit","content":" Timeexpanded / Deconvolved ModelFit"},{"id":216,"pagetitle":"rERP (overlap correction)","title":"1. specify a temporal basisfunction","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_overlap/#1.-specify-a-temporal-basisfunction","content":" 1. specify a temporal basisfunction By default, we would want to use a FIR basisfunction. See  Basis Functions  for more details. basisfunction = firbasis(τ=(-0.4,.8),sfreq=100)"},{"id":217,"pagetitle":"rERP (overlap correction)","title":"2. specify a formula","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_overlap/#2.-specify-a-formula","content":" 2. specify a formula We specify the same formula as before f  = @formula 0~1+condition+continuous"},{"id":218,"pagetitle":"rERP (overlap correction)","title":"3. fit the linear model","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_overlap/#3.-fit-the-linear-model","content":" 3. fit the linear model The formula and basisfunction is not enough on their own. We also need to specify which event and which formula matches - this is important in cases where there are multiple events with different formulas bf_vec = [Any=>(f,basisfunction)] Note The  Any  means to use all rows in  evts . In case you have multiple events, you'd want to specify multiple basisfunctions e.g.    bfDict = [\"stimulus\"=>(f1,basisfunction1),                 \"response\"=>(f2,basisfunction2)]    You likely have to specify a further argument to  fit :  eventcolumn=\"type\"  with  type  being the column in  evts  that codes for the event (stimulus / response in this case) Now we are ready to fit a  UnfoldLinearModel . Not that instead of  times  as in the mass-univariate case, we have to provide the  BasisFunction  type now. m = fit(UnfoldModel,bf_vec,evts,data);"},{"id":219,"pagetitle":"rERP (overlap correction)","title":"4. Visualize the model","ref":"/UnfoldDocs/Unfold.jl/stable/tutorials/lm_overlap/#4.-Visualize-the-model","content":" 4. Visualize the model Similarly to the previous tutorial, we can visualize the model results = coeftable(m)\nplot_erp(results) Cool! All overlapping activity has been removed and we recovered the simulated underlying signal."},{"id":222,"pagetitle":"UnfoldMixedModels.jl Documentation","title":"UnfoldMixedModels.jl Documentation","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/#UnfoldMixedModels.jl-Documentation","content":" UnfoldMixedModels.jl Documentation Welcome to  UnfoldMixedModels.jl : a Julia package to analyse timeseries with Linear Mixed Models. This is an standalone-addon to  Unfold.jl  with similar syntax, but optimized for LMMs / Hierarchical Models."},{"id":223,"pagetitle":"UnfoldMixedModels.jl Documentation","title":"Key features","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/#Key-features","content":" Key features MixedModels.jl:  Powered by the up-to-100x faster implementation of MixedModels.jl Subject and Item effects:  Fit the full spectrum of LMMs, random slopes and all! Beta: clusterpermutation:  Combine with  UnfoldStats.jl  and fit LMM clusterpermutation tests Alpha: Overlap:  Model overlap and LMMs (experimental!)"},{"id":224,"pagetitle":"UnfoldMixedModels.jl Documentation","title":"Installation","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/#Installation","content":" Installation julia> using Pkg; Pkg.add(\"UnfoldMixedModels\")"},{"id":225,"pagetitle":"UnfoldMixedModels.jl Documentation","title":"Usage example","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/#Usage-example","content":" Usage example using UnfoldMixedModels\nusing UnfoldSim\ndata, evts = UnfoldSim.predef_eeg(10;return_epoched=true) # 10 subjects\ndata = reshape(data,size(data,1),:) # concatenate subjects\n\ntimes = range(-0.1,0.5,size(data,1)) # arbitrary time-vector\n\nfLMM = @formula 0 ~ 1 + condition + (1 + condition|subject) + (1|item)\nfit(UnfoldModel, [Any=>(f, times)], evts, data)\nnothing #hide"},{"id":226,"pagetitle":"UnfoldMixedModels.jl Documentation","title":"Where to start: Learning roadmap","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/#Where-to-start:-Learning-roadmap","content":" Where to start: Learning roadmap"},{"id":227,"pagetitle":"UnfoldMixedModels.jl Documentation","title":"0. First first steps","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/#0.-First-first-steps","content":" 0. First first steps 📌 Goal: Familiarize yourself with rERP Unfold.jl fitting & MixedModels.jl / 🔗  Unfold.jl Quickstart  |  MixedModels.jl"},{"id":228,"pagetitle":"UnfoldMixedModels.jl Documentation","title":"1. First steps","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/#1.-First-steps","content":" 1. First steps 📌 Goal: Learn to fit a mass univariate Linear Mixed Model / 🔗  Mass Univariate Linear Mixed Models"},{"id":229,"pagetitle":"UnfoldMixedModels.jl Documentation","title":"2. Intermediate topics","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/#2.-Intermediate-topics","content":" 2. Intermediate topics 📌 Goal: Extract statistics and cluster permutation tests / 🔗  How To get P-Values for Mass-Univariate LMM  |  LMM Cluster Permutation tests We further recommend to skim this online book (from the authors of MixedModels.jl):  embraceuncertaintybook.com/ You should also learn about model simplification (keep it maximal ..?) and contrast codings. Enjoy!"},{"id":230,"pagetitle":"UnfoldMixedModels.jl Documentation","title":"Statement of need","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/#Statement-of-need","content":" Statement of need EEG researchers often analyse complex experimental procedures and want to generalize them to populations of subjects, items, schools etc. ( Generalization Crisis - Yarkoni 2020 ). In case of hierarchical structures (e.g. repeated trials in subjects, different stimuli used) the Linear Mixed Model has become very popular. Unfortunately, fitting such models can be quite involved, especially for EEG data which require massive-modelfitting for each sensor and channel. MixedModels.jl provides a fast way for fitting, and UnfoldMixedModels.jl provides the bookkeeping to do so in a massive way. Users can easily extract fixed and random effects over time and sensors, do statistical testing and even correction for multiple comparisons (via UnfoldStats.jl / MixedModelsPermutations.jl)."},{"id":233,"pagetitle":"Contributing guidelines","title":"Contributing guidelines","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/90-contributing/#contributing","content":" Contributing guidelines First of all, thanks for the interest! We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc. Be polite and respectful, and follow the code of conduct."},{"id":234,"pagetitle":"Contributing guidelines","title":"Bug reports and discussions","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/90-contributing/#Bug-reports-and-discussions","content":" Bug reports and discussions If you think you found a bug, feel free to open an  issue . Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please."},{"id":235,"pagetitle":"Contributing guidelines","title":"Working on an issue","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/90-contributing/#Working-on-an-issue","content":" Working on an issue If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it. Tip Feel free to ping us after a few days if there are no responses. If your solution involves code (or something that requires running the package locally), check the  developer documentation . Otherwise, you can use the GitHub interface directly to create your pull request."},{"id":238,"pagetitle":"Developer documentation","title":"Developer documentation","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/91-developer/#dev_docs","content":" Developer documentation Contributing guidelines If you haven't, please read the  Contributing guidelines  first. If you want to make contributions to this package that involves code, then this guide is for you."},{"id":239,"pagetitle":"Developer documentation","title":"First time clone","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/91-developer/#First-time-clone","content":" First time clone If this is the first time you work with this repository, follow the instructions below to clone the repository. Fork this repo Clone your repo (this will create a  git remote  called  origin ) Add this repo as a remote: git remote add upstream https://github.com/unfoldtoolbox/UnfoldMixedModels.jl This will ensure that you have two remotes in your git:  origin  and  upstream . You will create branches and push to  origin , and you will fetch and update your local  main  branch from  upstream . If you have writing rights in the GitHub repo If you have writing rights, you don't have to fork. Instead, simply clone and skip ahead. Whenever  upstream  is mentioned, use  origin  instead. !!! tip \" dev  command You can also recommend to use ]dev –local UnfoldMixedModels.jl to clone the package to ./dev/UnfoldMixedModels and add automatically add it to your julia project environment. You could also ]dev –local  https://link.com/myFork/UnfoldMixedModels.jl/`"},{"id":240,"pagetitle":"Developer documentation","title":"Linting and formatting","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/91-developer/#Linting-and-formatting","content":" Linting and formatting Install a plugin on your editor to use  EditorConfig . This will ensure that your editor is configured with important formatting settings. We use  https://pre-commit.com  to run the linters and formatters. In particular, the Julia code is formatted using  JuliaFormatter.jl , so please install it globally first: julia> # Press ]\npkg> activate\npkg> add JuliaFormatter To install  pre-commit , we recommend using  pipx  as follows: # Install pipx following the link\npipx install pre-commit With  pre-commit  installed, activate it as a pre-commit hook: pre-commit install To run the linting and formatting manually, enter the command below: pre-commit run -a Now, you can only commit if all the pre-commit tests pass ."},{"id":241,"pagetitle":"Developer documentation","title":"Testing","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/91-developer/#Testing","content":" Testing As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run  test : julia> # press ]\npkg> activate .\npkg> test Running single tests Instead fo running all tests, you can also run the  test/setup.jl  to load all required packages, and subsequently run single tests manually either by  include(\"test/test-fit.jl\")  or by opening the file and running the specific test/testblock you want to run."},{"id":242,"pagetitle":"Developer documentation","title":"Working on a new issue","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/91-developer/#Working-on-a-new-issue","content":" Working on a new issue Guides not Shackles We 100% prefer you to commit/submit/share what you have in a state you are comfortable with. If you want to follow (and learn) best-practices read ahead - but we also take your input as it is :) We try to keep a linear history in this repo, so it is important to keep your branches up-to-date. Fetch from the remote and fast-forward your local main git fetch upstream\ngit switch main\ngit merge --ff-only upstream/main Branch from  main  to address the issue (see below for naming) git switch -c 42-add-answer-universe Push the new local branch to your personal remote repository git push -u origin 42-add-answer-universe Create a pull request to merge your remote branch into the org main."},{"id":243,"pagetitle":"Developer documentation","title":"Branch naming","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/91-developer/#Branch-naming","content":" Branch naming If there is an associated issue, add the issue number. If there is no associated issue,  and the changes are small , add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update. If the changes are not small and there is no associated issue, then either create an issue first, or discuss in another channel with the maintainers. Use dash separated imperative wording related to the issue (e.g.,  14-add-tests ,  15-fix-model ,  16-remove-obsolete-files )."},{"id":244,"pagetitle":"Developer documentation","title":"Commit message","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/91-developer/#Commit-message","content":" Commit message Use imperative or present tense, for instance:  Add feature  or  Fix bug . Have informative titles. When necessary, add a body with details. If there are breaking changes, add the information to the commit message."},{"id":245,"pagetitle":"Developer documentation","title":"Before creating a pull request","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/91-developer/#Before-creating-a-pull-request","content":" Before creating a pull request Ideally: locally run the tests. Ideally: Make sure the pre-commit tests pass. Fetch any  main  updates from upstream and rebase your branch, if necessary: git fetch upstream\ngit rebase upstream/main BRANCH_NAME Then you can open a pull request and work with the reviewer to address any issues."},{"id":246,"pagetitle":"Developer documentation","title":"Building and viewing the documentation locally","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/91-developer/#Building-and-viewing-the-documentation-locally","content":" Building and viewing the documentation locally Following the latest suggestions, we recommend using  LiveServer  to build the documentation. Here is how you do it: Run  julia --project=docs  to open Julia in the environment of the docs. If this is the first time building the docs Press  ]  to enter  pkg  mode Run  pkg> dev .  to use the development version of your package Press backspace to leave  pkg  mode Run  julia> using LiveServer Run  julia> servedocs()"},{"id":249,"pagetitle":"P-values for mixedModels","title":"How To get P-Values for Mass-Univariate LMM","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/howto/lmm_pvalues/#lmm_pvalues","content":" How To get P-Values for Mass-Univariate LMM There are currently two ways to obtain p-values for LMMs: Wald's t-test and likelihood ratio tests (mass univariate only)."},{"id":250,"pagetitle":"P-values for mixedModels","title":"Setup","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/howto/lmm_pvalues/#Setup","content":" Setup using UnfoldMixedModels # we require to load MixedModels to load the PackageExtension\nusing DataFrames\nusing UnfoldSim\nusing CairoMakie\ndata_epoch, evts =\n    UnfoldSim.predef_2x2(; n_items = 52, n_subjects = 40, return_epoched = true)\ndata_epoch = reshape(data_epoch, size(data_epoch, 1), :) #\ntimes = range(0, 1, length = size(data_epoch, 1)) 0.0:0.010101010101010102:1.0"},{"id":251,"pagetitle":"P-values for mixedModels","title":"Define f0 & f1 and fit","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/howto/lmm_pvalues/#Define-f0-and-f1-and-fit","content":" Define f0 & f1 and fit f0 = @formula 0 ~ 1 + A + (1 + A | subject);\nf1 = @formula 0 ~ 1 + A + B + (1 + A | subject); # could also differ in random effects\n\nm0 = fit(UnfoldModel,[Any=>(f0,times)],evts,data_epoch);\nm1 = fit(UnfoldModel,[Any=>(f1,times)],evts,data_epoch);"},{"id":252,"pagetitle":"P-values for mixedModels","title":"Likelihood ratio","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/howto/lmm_pvalues/#Likelihood-ratio","content":" Likelihood ratio uf_lrt = likelihoodratiotest(data_epoch, m0, m1)\nuf_lrt[1] model-dof deviance χ² χ²-dof P(>χ²) �[38;2;144;202;249m1�[39m �[38;2;239;83;80m+�[39m A �[38;2;239;83;80m+�[39m (�[38;2;144;202;249m1�[39m �[38;2;239;83;80m+�[39m A �[38;2;239;83;80m|�[39m subject) 6 8012 �[38;2;144;202;249m1�[39m �[38;2;239;83;80m+�[39m A �[38;2;239;83;80m+�[39m B �[38;2;239;83;80m+�[39m (�[38;2;144;202;249m1�[39m �[38;2;239;83;80m+�[39m A �[38;2;239;83;80m|�[39m subject) 7 8011 1 1 0.3996 As you can see, we have some likelihood ratio outcomes, exciting!"},{"id":253,"pagetitle":"P-values for mixedModels","title":"Extract p-values","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/howto/lmm_pvalues/#Extract-p-values","content":" Extract p-values pvalue(uf_lrt) 100-element Vector{Vector{Float64}}:\n [0.39964251754876706]\n [0.4019640858609401]\n [0.4074237173863722]\n [0.4070454519554564]\n [0.42228971014118033]\n [0.483155056260971]\n [0.6339437552710293]\n [NaN]\n [NaN]\n [NaN]\n ⋮\n [0.34292883003473407]\n [0.33515969561309156]\n [0.33325396532570495]\n [0.3428036624385943]\n [0.3567742512609538]\n [0.37049189795207205]\n [0.38051461402659575]\n [0.3883891630406846]\n [0.39851721772119286] We have extracted the p-values and now need to make them usable.     The solution can be found in the documentation under  ?pvalue . pvals_lrt = vcat(pvalue(uf_lrt)...)\nnchan = 1\nntime = length(times)\nreshape(pvals_lrt, ntime, nchan)' # note the last transpose via ' ! 1×100 adjoint(::Matrix{Float64}) with eltype Float64:\n 0.399643  0.401964  0.407424  0.407045  …  0.380515  0.388389  0.398517 Perfecto, these are the LRT p-values of a model  condA  vs.  condA+condB  with same random effect structure."},{"id":254,"pagetitle":"P-values for mixedModels","title":"Walds T-Test","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/howto/lmm_pvalues/#Walds-T-Test","content":" Walds T-Test This method is easier to calculate but has limitations in accuracy and scope. It may also be less accurate due to the liberal estimation of degrees of freedom. Testing is limited in this case, as random effects cannot be tested and only single predictors can be used, which may not be appropriate for spline effects. It is important to note that this discussion is beyond the scope of this LMM package. res = coeftable(m1)\n# only fixed effects: what is not in a ranef group is a fixef.\nres = res[isnothing.(res.group), :]\n# calculate z-value\nres[:, :zvalue] = res.estimate ./ res.stderror 300-element Vector{Float64}:\n  4.446708326696426\n  4.437580860011641\n  4.446435058073349\n  4.492672997803976\n  4.494599457419684\n  4.4880483252027075\n  4.439652303422133\n  4.45518635490581\n  4.623068236549389\n  4.663764726700654\n  ⋮\n  0.5870708293447756\n  0.43759939804174963\n  0.2172917074185397\n  0.025591530320948425\n -0.11195974844949615\n -0.28040792854804225\n -0.22668554132390997\n -0.2646530795209725\n -0.3492299276363734 We obtained Walds z, but how to translate them to a p-value? Determining the necessary degrees of freedom for the z/t-distribution is a complex issue with much debate surrounding it. One approach is to use the number of subjects as an upper bound for the p-value (your df will be between  $n_{subject}$  and  $\\sum{n_{trials}}$ ). df = length(unique(evts.subject)) 40 Plug it into the t-distribution. using Distributions\nres.pvalue = pdf.(TDist(df),res.zvalue) 300-element Vector{Float64}:\n 0.00010520592926163251\n 0.00010817494439425095\n 0.00010529365405567558\n 9.142141916777313e-5\n 9.088393516836884e-5\n 9.272440215982806e-5\n 0.00010749405443829126\n 0.00010251943544603832\n 6.122445474960627e-5\n 5.398423858898151e-5\n ⋮\n 0.33251660178615255\n 0.3594809847897533\n 0.38698410798874533\n 0.39632387743397085\n 0.39391857391788004\n 0.38081351375847516\n 0.38615884540577883\n 0.3824900521283194\n 0.37247026276880874"},{"id":255,"pagetitle":"P-values for mixedModels","title":"Comparison of methods","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/howto/lmm_pvalues/#Comparison-of-methods","content":" Comparison of methods Cool! Let's compare both methods of p-value calculation! df = DataFrame(:walds => res[res.coefname.==\"B: b_tiny\", :pvalue], :lrt => pvals_lrt)\nf = Figure()\n\nscatter(f[1,1],times,res[res.coefname .== \"B: b_tiny\",:estimate],axis=(;xlabel=\"time\",title=\"coef: B:b_tiny\"))\nscatter(f[1,2],df.walds,df.lrt,axis=(;xlabel=\"walds-z pvalue\",ylabel=\"LRT pvalue\"))\nscatter(f[2,1],times,df.walds,axis=(;title=\"walds-z pvalue\",xlabel=\"time\"))\nscatter(f[2,2],times,df.lrt,axis=(;title=\"lrt pvalue\",xlabel=\"time\"))\n\nf Note that the Walds-z is typically too liberal (LRT also, but to a lesser exted). Best is to use the forthcoming MixedModelsPermutations.jl or go the route via R and use KenwardRogers (data not yet published)"},{"id":258,"pagetitle":"API: Functions","title":"MixedModels.likelihoodratiotest","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#MixedModels.likelihoodratiotest-Tuple{AbstractArray, Vararg{UnfoldLinearMixedModel}}","content":" MixedModels.likelihoodratiotest  —  Method likelihoodratiotest(data, m)\n Calculate likelihoodratiotest source"},{"id":259,"pagetitle":"API: Functions","title":"StatsAPI.fit!","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#StatsAPI.fit!-Union{Tuple{T}, Tuple{Union{UnfoldLinearMixedModel, UnfoldLinearMixedModelContinuousTime}, AbstractArray{T}}} where T","content":" StatsAPI.fit!  —  Method fit!(uf::UnfoldModel,data::Union{<:AbstractArray{T,2},<:AbstractArray{T,3}}) where {T<:Union{Missing, <:Number}} Fit a DesignMatrix against a 2D/3D Array data along its last dimension Data is typically interpreted as channel x time (with basisfunctions) or channel x time x epoch (for mass univariate) show_progress  (default:true), deactivate the progressmeter Returns an UnfoldModel object Examples source"},{"id":260,"pagetitle":"API: Functions","title":"StatsAPI.pvalue","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#StatsAPI.pvalue-Tuple{Vector{MixedModels.LikelihoodRatioTest}}","content":" StatsAPI.pvalue  —  Method pvalue(lrtvec)\n Unfold-Method: return pvalues of likelihoodratiotests, typically calculated: Examples julia> pvalue(likelihoodratiotest(m1,m2)) where m1/m2 are UnfoldLinearMixedModel's Tipp: if you only compare two models you can easily get a vector of p-values: julia> vcat(pvalues(likelihoodratiotest(m1,m2))...) Multiple channels are returned linearized at the moment, as we do not have access to the amount of channels after the LRT, you can do: julia> reshape(vcat(pvalues(likelihoodratiotest(m1,m2))...),ntimes,nchan)' source"},{"id":261,"pagetitle":"API: Functions","title":"StatsModels.modelcols","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#StatsModels.modelcols-Tuple{Unfold.TimeExpandedTerm{<:Union{var\"#s1\", var\"#s118\"} where {var\"#s1\"<:RandomEffectsTerm, var\"#s118\"<:MixedModels.AbstractReTerm}}, Any}","content":" StatsModels.modelcols  —  Method modelcols(term, tbl)\n This function timeexpands the random effects and generates a ReMat object source"},{"id":262,"pagetitle":"API: Functions","title":"Unfold.make_estimate","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#Unfold.make_estimate-Tuple{Union{UnfoldLinearMixedModel, UnfoldLinearMixedModelContinuousTime}}","content":" Unfold.make_estimate  —  Method Unfold.make_estimate(m::Union{UnfoldLinearMixedModel,UnfoldLinearMixedModelContinuousTime}, ) extracts betas (and sigma's for mixed models) with string grouping indicator returns as a ch x beta, or ch x time x beta (for mass univariate) source"},{"id":263,"pagetitle":"API: Functions","title":"Unfold.modelmatrices","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#Unfold.modelmatrices-Tuple{Tuple}","content":" Unfold.modelmatrices  —  Method modelmatrices(modelmatrix::Tuple) in the case of a Tuple (MixedModels - FeMat/ReMat Tuple), returns only the FeMat part source"},{"id":264,"pagetitle":"API: Functions","title":"UnfoldMixedModels.LinearMixedModel_wrapper","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#UnfoldMixedModels.LinearMixedModel_wrapper-Union{Tuple{TData}, Tuple{Any, AbstractVector{<:TData}, Any}} where TData<:Number","content":" UnfoldMixedModels.LinearMixedModel_wrapper  —  Method LinearMixedModel_wrapper(form, data, Xs; wts)\n Wrapper to generate a LinearMixedModel. Code taken from MixedModels.jl and slightly adapted. source"},{"id":265,"pagetitle":"API: Functions","title":"UnfoldMixedModels.fake_lmm","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#UnfoldMixedModels.fake_lmm-Union{Tuple{N}, Tuple{AbstractArray{<:Number, N}, UnfoldLinearMixedModel, Int64}} where N","content":" UnfoldMixedModels.fake_lmm  —  Method fake_lmm(data, m, k)\n Returns a partial LMM model (non-functional due to lacking data) to be used in likelihoodratiotests.  k  to selcet which of the modelfit's to fake source"},{"id":266,"pagetitle":"API: Functions","title":"UnfoldMixedModels.get_timeexpanded_random_grouping","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#UnfoldMixedModels.get_timeexpanded_random_grouping-Tuple{Any, Any, Any}","content":" UnfoldMixedModels.get_timeexpanded_random_grouping  —  Method get_timeexpanded_random_grouping(\n    tbl_group,\n    tbl_latencies,\n    basisfunction\n)\n Get the timeranges where the random grouping variable was applied source"},{"id":267,"pagetitle":"API: Functions","title":"UnfoldMixedModels.isa_lmm_formula","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#UnfoldMixedModels.isa_lmm_formula-Tuple{typeof(zerocorr)}","content":" UnfoldMixedModels.isa_lmm_formula  —  Method isa_lmm_formula iterates over all parts of a formula until either a  MixedModels.zerocorr , or a  |  was found. Then returns true, else returns false. source"},{"id":268,"pagetitle":"API: Functions","title":"UnfoldMixedModels.random_effect_groupings","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#UnfoldMixedModels.random_effect_groupings-Tuple{StatsModels.AbstractTerm}","content":" UnfoldMixedModels.random_effect_groupings  —  Method random_effect_groupings(t::MixedModels.AbstractReTerm) Returns the random effect grouping term (rhs), similar to coefnames, which returns the left hand sides source"},{"id":269,"pagetitle":"API: Functions","title":"UnfoldMixedModels.reorder_tidyσs","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/functions/#UnfoldMixedModels.reorder_tidyσs-Tuple{Any, Any}","content":" UnfoldMixedModels.reorder_tidyσs  —  Method reorder_tidyσs(t, f) This function reorders a MixedModels.tidyσs output, according to the formula and not according to the largest RandomGrouping. source"},{"id":272,"pagetitle":"API: Types","title":"UnfoldMixedModels.UnfoldLinearMixedModel","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/types/#UnfoldMixedModels.UnfoldLinearMixedModel","content":" UnfoldMixedModels.UnfoldLinearMixedModel  —  Type Concrete type to implement an Mass-Univariate LinearMixedModel.  .design  contains the formula + times dict  .designmatrix  contains a  DesignMatrix modelfit  is a  Any  container for the model results source"},{"id":273,"pagetitle":"API: Types","title":"UnfoldMixedModels.UnfoldLinearMixedModelContinuousTime","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/references/types/#UnfoldMixedModels.UnfoldLinearMixedModelContinuousTime","content":" UnfoldMixedModels.UnfoldLinearMixedModelContinuousTime  —  Type Concrete type to implement an deconvolution LinearMixedModel. Warning  This is to be treated with care, not much testing went into it. .design  contains the formula + times dict  .designmatrix  contains a  DesignMatrix .modelfit  is a  Any  container for the model results source"},{"id":276,"pagetitle":"lmmERP (mass univariate)","title":"Mass Univariate Linear Mixed Models","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_mu/#lmm_massunivariate","content":" Mass Univariate Linear Mixed Models using UnfoldMixedModels\nusing UnfoldSim\n\nusing UnfoldMakie, CairoMakie # plotting\nusing DataFrames\nusing CategoricalArrays This notebook is similar to the  Unfold.jl Mass Univariate Linear Models (no overlap correction) tutorial , but fits mass-univariate  mixed  models - that is, one model over all subjects, instead of one model per subject. This allows to include item effects, for example."},{"id":277,"pagetitle":"lmmERP (mass univariate)","title":"Mass Univariate Mixed Models","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_mu/#Mass-Univariate-**Mixed**-Models","content":" Mass Univariate  Mixed  Models Again we have 4 steps: Split data into epochs Specify a formula Fit a linear model to each time point & channel Visualize the results."},{"id":278,"pagetitle":"lmmERP (mass univariate)","title":"1. Epoching","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_mu/#1.-Epoching","content":" 1. Epoching data, evts = UnfoldSim.predef_eeg(10; return_epoched = true) # simulate 10 subjects\ndata = reshape(data, 1, size(data, 1), :) # concatenate the data into a long EEG dataset\ntimes = range(0, length = size(data, 2), step = 1 / 100)\ntransform!(evts, :subject => categorical => :subject); # :subject must be categorical, otherwise MixedModels.jl complains The  events  dataFrame has an additional column (besides being much taller):  subject first(evts, 6) 6×5 DataFrame Row subject item continuous condition latency Cat… String Float64 String Int64 1 S01 I038 2.77778 face 62 2 S01 I067 1.66667 car 132 3 S01 I032 -3.88889 face 196 4 S01 I013 -2.77778 face 249 5 S01 I058 2.77778 face 303 6 S01 I094 -1.66667 face 366"},{"id":279,"pagetitle":"lmmERP (mass univariate)","title":"2. Formula specification","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_mu/#2.-Formula-specification","content":" 2. Formula specification We define the formula. Importantly, we need to specify a random effect. We use  zerocorr  to speed up the calculation. f = @formula 0 ~ 1 + condition * continuous + zerocorr(1 + condition * continuous | subject);"},{"id":280,"pagetitle":"lmmERP (mass univariate)","title":"3. Model fitting","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_mu/#3.-Model-fitting","content":" 3. Model fitting We can now run the LinearMixedModel at each time point. m = fit(UnfoldModel, f, evts, data, times) \nProgress:   4%|█▉                                       |  ETA: 0:00:11\n   channel: 1\n      time: 2\n\n\n\n\n\nProgress: 100%|█████████████████████████████████████████| Time: 0:00:00\n   channel: 1\n      time: 45"},{"id":281,"pagetitle":"lmmERP (mass univariate)","title":"4. Visualization of results","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_mu/#4.-Visualization-of-results","content":" 4. Visualization of results Let's start with the  fixed  effects. We see the condition effects and some residual overlap activity in the fixed effects. results = coeftable(m)\n\nres_fixef = results[isnothing.(results.group), :]\nplot_erp(res_fixef) And now comes the  random  effect: res_ranef = results[results.group .== :subject, :]\nplot_erp(res_ranef)"},{"id":282,"pagetitle":"lmmERP (mass univariate)","title":"Statistics","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_mu/#Statistics","content":" Statistics Check out the  LMM p-value tutorial"},{"id":285,"pagetitle":"lmmERP (overlap correction)","title":"Overlap Correction with Linear Mixed Models","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_overlap/#lmm_overlap","content":" Overlap Correction with Linear Mixed Models using UnfoldMixedModels\n\nusing UnfoldSim\n\nusing CategoricalArrays\nusing UnfoldMakie, CairoMakie\nusing DataFrames This notebook is similar to the Linear Model with Overlap Correction tutorial, but fits  mixed  models with overlap correction Warning Limitation : This functionality is not ready for general use. There are still a lot of things to find out and tinker with. Don't use this if you haven't looked under the hood of the toolbox! Be aware of crashes / timeouts for non-trivial problems"},{"id":286,"pagetitle":"lmmERP (overlap correction)","title":"Get some data","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_overlap/#Get-some-data","content":" Get some data dat, evts = UnfoldSim.predef_2x2(; signalsize=20, n_items=16, n_subjects=16)\n\n# We also need to fix the latencies, they are now relative to 1:size(data, 1), but we want a continuous long EEG.\nsubj_idx = [parse(Int, split(string(s), 'S')[2]) for s in evts.subject]\nevts.latency .+= size(dat, 1) .* (subj_idx .- 1)\n\ndat = dat[:] # we need all data concatenated over subjects\nevts.subject  = categorical(Array(evts.subject))"},{"id":287,"pagetitle":"lmmERP (overlap correction)","title":"Linear Mixed Model Continuous Time","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_overlap/#Linear-**Mixed**-Model-Continuous-Time","content":" Linear  Mixed  Model Continuous Time Again we have 4 steps: Specify a temporal basisfunction Specify a formula Fit a linear model for each channel (one model for all timepoints!) Visualize the results."},{"id":288,"pagetitle":"lmmERP (overlap correction)","title":"1. Specify a temporal basisfunction","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_overlap/#1.-Specify-a-temporal-basisfunction","content":" 1. Specify a temporal basisfunction By default, we would want to use a FIR basis function. basisfunction = firbasis(τ=(-0.4, .8), sfreq=20, name=\"stimulus\")"},{"id":289,"pagetitle":"lmmERP (overlap correction)","title":"2. Specify the formula","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_overlap/#2.-Specify-the-formula","content":" 2. Specify the formula Define the formula and specify a random effect. Note We use  zerocorr  to prevent the model from computing all correlations between all timepoints and factors. f  = @formula 0 ~ 1 + A  *B + zerocorr(1 + A*B|subject); FormulaTerm\nResponse:\n  0\nPredictors:\n  1\n  A(unknown)\n  B(unknown)\n  A(unknown) & B(unknown)\n  (A,B,subject)->zerocorr((1 + A * B) | subject)"},{"id":290,"pagetitle":"lmmERP (overlap correction)","title":"3. Fit the model","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_overlap/#3.-Fit-the-model","content":" 3. Fit the model bfDict = [Any=>(f, basisfunction)]\n# Skipping this tutorial for now due to a significant error.\nm = fit(UnfoldModel, bfDict, evts, dat)\n\nresults = coeftable(m)\nfirst(results, 6) 6×7 DataFrame Row channel coefname estimate eventname group stderror time Int64 String Float64 Union… Union… Nothing Float64 1 1 (Intercept) 0.0728554 Any -0.4 2 1 (Intercept) 0.0941947 Any -0.35 3 1 (Intercept) 0.0694752 Any -0.3 4 1 (Intercept) 0.00866136 Any -0.25 5 1 (Intercept) -0.0422579 Any -0.2 6 1 (Intercept) -0.0524441 Any -0.15"},{"id":291,"pagetitle":"lmmERP (overlap correction)","title":"4. Visualize results","ref":"/UnfoldDocs/UnfoldMixedModels.jl/stable/tutorials/lmm_overlap/#4.-Visualize-results","content":" 4. Visualize results plot_erp(results; mapping=(; col = :group))"},{"id":294,"pagetitle":"Home","title":"UnfoldMakie.jl Documentation","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/#UnfoldMakie.jl-Documentation","content":" UnfoldMakie.jl Documentation Welcome to  UnfoldMakie.jl : a Julia package for visualizations of EEG/ERP data and Unfold.jl models."},{"id":295,"pagetitle":"Home","title":"Key features","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/#Key-features","content":" Key features 🎯  Focused : Specialized for (r)ERP visualization. 🎨  Customizable : Full control over colors, lines, layouts via Makie.jl flexibility. ⚡  Fast : Complex figures (e.g., 50 topoplots) generated ~20× faster than EEGLAB. 🔄  Interactive : Partial support for Observables.jl, enabling dynamic plots. 🗺️  Smart aesthetics : Scientific color maps by default (no misleading rainbows!). 📚  Well-documented : Extensive examples and user guides. For more highlights visit  this page ."},{"id":296,"pagetitle":"Home","title":"Installation","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/#Installation","content":" Installation julia> using Pkg; Pkg.add(\"UnfoldMakie\") For more detailed instructions please refer to  Installing Julia & Unfold Packages ."},{"id":297,"pagetitle":"Home","title":"Usage example","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/#Usage-example","content":" Usage example Start with ERP plot and topopplot series.  using UnfoldMakie, CairoMakie, Unfold\nresults = Unfold.coeftable(UnfoldMakie.example_data(\"UnfoldLinearModel\"))\nf = Figure(size=(550, 300))\nplot_erp!(f,\n    results,\n    mapping = (; col = :coefname, color = :coefname => \"Conditions\"),\n    axis = (; xlabel = \"Time [s]\"),\n    stderror = true,\n)\nf using UnfoldMakie, CairoMakie\ndat, positions = UnfoldMakie.example_data()\nplot_topoplotseries(\n    dat; bin_num = 9, nrows = 3,\n    positions = positions,\n    visual = (; label_scatter = false, contours = false),\n    axis = (; xlabel = \"Time windows [s]\"),\n    topolabels_rounding = (; digits = 2),\n)"},{"id":298,"pagetitle":"Home","title":"Where to start: Learning roadmap","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/#Where-to-start:-Learning-roadmap","content":" Where to start: Learning roadmap"},{"id":299,"pagetitle":"Home","title":"1. First step","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/#1.-First-step","content":" 1. First step 📌 Goal: Check why we need multiple plot types for Event-related potentials and what kind of plot types exist.  🔗  Plot types  |  Complex figures"},{"id":300,"pagetitle":"Home","title":"2. Intermediate topics","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/#2.-Intermediate-topics","content":" 2. Intermediate topics 📌 Goal: Check the most popular plots. 🔗  ERP plot  |  Topoplot"},{"id":301,"pagetitle":"Home","title":"3. Advanced topics","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/#3.-Advanced-topics","content":" 3. Advanced topics 📌 Goal: Learn about advanced customization 🔗  Visualize uncertainty in topoplot series"},{"id":302,"pagetitle":"Home","title":"Statement of need","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/#Statement-of-need","content":" Statement of need UnfoldMakie.jl is a Julia package for visualization of electroencephalography (EEG) data, with a focus on event-related potentials (ERPs) and regression-ERPs (rERPs). UnfoldMakie.jl fills a gap as one of the only dedicated EEG visualization libraries and offers ease of use, customization, speed, and detailed documentation. It allows for both explorative analysis (zooming/panning) and export to publication-ready vector graphics. This is achieved via multiple backends of  Makie.jl : vector graphics with  CairoMakie.jl , GPU-accelerated interactive graphics with  GLMakie.jl , and the browser-based  WGLMakie.jl . In an earlier study ( Mikheev et al., 2024 ), we asked novice and expert practitioners for insights into their ERP visualization practices. The results of this survey were used to develop and improve UnfoldMakie.jl. Further, UnfoldMakie.jl is agnostic (independent) of any specific analysis framework, but it nicely accompanies the rERP analysis package  Unfold.jl  ( Ehinger & Dimigen, 2019 ). The target audience of this package is anyone working with EEG, MEG, ERP, iEEG or other time-series data."},{"id":305,"pagetitle":"API: Functons","title":"UnfoldMakie.cart3d_to_spherical","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.cart3d_to_spherical-Tuple{Any, Any, Any}","content":" UnfoldMakie.cart3d_to_spherical  —  Method cart3d_to_spherical(x, y, z) Convert x, y, z electrode positions on a scalp to spherical coordinate representation.  Return Value: Matrix . source"},{"id":306,"pagetitle":"API: Functons","title":"UnfoldMakie.config_kwargs!","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.config_kwargs!-Tuple{PlotConfig}","content":" UnfoldMakie.config_kwargs!  —  Method config_kwargs!(cfg::PlotConfig; kwargs...) Takes NamedTuple of  Key => NamedTuple  as kwargs and merges the fields with the defaults. source"},{"id":307,"pagetitle":"API: Functons","title":"UnfoldMakie.data_binning","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.data_binning-Tuple{Any}","content":" UnfoldMakie.data_binning  —  Method data_binning(df; col_y = :erp, fun = mean, grouping = []) Group  DataFrame  according to topoplot coordinates and apply aggregation function. Arguments: df::AbstractTable   Requires columns  :cont_cuts ,  col_y  (default  :erp ), and all columns in  grouping  ( col_coord ,  row_coord ,  label ); col_y = :erp   The column to combine over (with  fun ); fun = mean()   Function to combine. grouping = []   Vector of symbols or strings, columns to group by the data before aggregation. Values of  nothing  are ignored. Return Value: DataFrame . source"},{"id":308,"pagetitle":"API: Functons","title":"UnfoldMakie.eeg_array_to_dataframe","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.eeg_array_to_dataframe-Tuple{Union{AbstractMatrix, AbstractVector{<:Number}}}","content":" UnfoldMakie.eeg_array_to_dataframe  —  Method eeg_array_to_dataframe(data::AbstractMatrix, label_aliases::AbstractVector)\neeg_array_to_dataframe(data::AbstractVector, label_aliases::AbstractVector)\neeg_array_to_dataframe(data::Union{AbstractMatrix, AbstractVector{<:Number}}) Helper function converting an array (Matrix or Vector) to a tidy  DataFrame  with columns  :estimate ,  :time  and  :label  (with aliases  :color ,  :group ,  :channel ). Format of Arrays: - times x condition for plot_erp. - channels x time for plot_butterfly, plot_topoplotseries. - channels for plot_topoplot. Return Value: DataFrame . source"},{"id":309,"pagetitle":"API: Functons","title":"UnfoldMakie.eeg_topoplot_series","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.eeg_topoplot_series-Tuple{Union{DataFrame, Observable, AbstractMatrix}}","content":" UnfoldMakie.eeg_topoplot_series  —  Method  eeg_topoplot_series(data::DataFrame,\n    fig,\n    data_inp::Union{<:Observable,<:AbstractMatrix};\n    layout = nothing,\n    topoplot_xlabels = nothing,\n    labels = nothing,\n    rasterize_heatmaps = true,\n    interactive_scatter = nothing,\n    highlight_scatter = false,\n    topo_axis = (;),\n    topo_attributes = (;),\n    positions,\n)\neeg_topoplot_series!(fig, data::DataFrame; kwargs..) Plot a series of topoplots.  The function takes the  combinefun = mean  over the  :time  column of  data . fig   Figure object.  data::Union{<:Observable,<:AbstractMatrix}   Matrix with size = (n channel, n topoplots). layout::Vector{Tuple{Int64, Int64}}   Vector of tuples with coordinates for each topoplot. topoplot_xlabels::Vector{String}   Vector of xlables for each topoplot.  topo_axis::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot axis.   To see all options just type  ?Axis  in REPL.   Defaults: (aspect = 1, title = \"\", xgridvisible = false, xminorgridvisible = false, xminorticksvisible = false, xticksvisible = false, xticklabelsvisible = false, xlabelvisible = true, ygridvisible = false, yminorgridvisible = false, yminorticksvisible = false, yticksvisible = false, yticklabelsvisible = false, leftspinevisible = false, rightspinevisible = false, topspinevisible = false, bottomspinevisible = false, xpanlock = true, ypanlock = true, xzoomlock = true, yzoomlock = true, xrectzoom = false, yrectzoom = false) topo_attributes::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot interoplation.   To see all options just type  ?Topoplot.topoplot  in REPL.   Defaults: interp_resolution = (128, 128), interpolation = CloughTocher(). positions::Vector{Point{2, Float32}}   Channel positions. The list of x and y positions for all unique electrodes.  Return Value: Tuple{Figure, Vector{Any}} . source"},{"id":310,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_butterfly","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_butterfly-Tuple{Union{AbstractDataFrame, AbstractMatrix}}","content":" UnfoldMakie.plot_butterfly  —  Method plot_butterfly(plot_data::Union{DataFrame, AbstractMatrix}; kwargs...)\nplot_butterfly(times::Vector, plot_data::Union{DataFrame, AbstractMatrix}; kwargs...)\nplot_butterfly!(f::Union{GridPosition, GridLayout, Figure}, plot_data::Union{DataFrame, AbstractMatrix}; kwargs...) Plot a Butterfly plot. Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{DataFrame, AbstractMatrix}   Data for the ERP plot visualization. kwargs...   Additional styling behavior.    Often used as:  plot_butterfly(df; visual = (; colormap = :romaO)) . Keyword arguments (kwargs) positions::Array = []   Adds a topoplot as an inset legend to the provided channel positions. Must be the same length as  plot_data .     To change the colors of the channel lines use the  topoposition_to_color  function. topolegend::Bool = true   Show an inlay topoplot with corresponding electrodes. Requires  positions . topopositions_to_color::x -> pos_to_color_RomaO(x)   Change the line colors. topo_axis::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot axis.   To see all options just type  ?Axis  in REPL.   Defaults: (width = Relative(0.35f0), height = Relative(0.35f0), halign = 0.05, valign = 0.95, aspect = 1) topo_attributes::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot interoplation.   To see all options just type  ?Topoplot.topoplot  in REPL.   Defaults: (head = (color = :black, linewidth = 1), label_scatter = (markersize = 10, strokewidth = 0.5), interpolation = TopoPlots.NullInterpolator()) mapping = (;)   For highlighting specific channels.   Example:  mapping = (; color = :highlight)) , where  :highlight  is variable with appopriate mapping. Return Value: Figure  displaying Butterfly plot. Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", ylabel = \"Voltage [µV]\", yticklabelsize = 14, xtickformat = \"{:.1f}\") -  use  kwargs...  of   Makie.Axis layout =  (show_legend = false, use_colorbar = true, use_legend = true, hidespines = (:r, :t), hidedecorations = Dict{Symbol, Bool}(:label => 0, :ticks => 0, :ticklabels => 0)) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y), color = (:channel, :channels, :trial, :trials), positions = (:pos, :positions, :position, :topo_positions, :x, nothing), labels = (:labels, :label, :topoLabels, :sensor, nothing), group = (:channel,)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = nothing, color = nothing) -  use  kwargs...  of  Makie.lines legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center, framevisible = false) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, label = \"\", flipaxis = true) -  use  kwargs...  of   AlgebraOfGraphics.colorbar! see also  plot_erp source"},{"id":311,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_channelimage","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_channelimage-Tuple{Union{DataFrame, AbstractMatrix}, Vector{Point{2, Float32}}, Vector{String}}","content":" UnfoldMakie.plot_channelimage  —  Method plot_channelimage!(f::Union{GridPosition, GridLayout, Figure}, data::Union{DataFrame,AbstractMatrix}, positions::Vector{Point{2,Float32}}, ch_names::Vector{String}; kwargs...)\nplot_channelimage(data::Union{DataFrame, AbstractMatrix}, positions::Vector{Point{2,Float32}}, ch_names::Vector{String}; kwargs...) Plot a Channel image Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{DataFrame, AbstractMatrix}   DataFrame or Matrix with data.   Data should has a format of 1 row - 1 channel.  positions::Vector{Point{2,Float32}}   A vector with EEG layout coordinates. ch_names::Vector{String}   Vector with channel names. times::Vector = range(-0.3, 1.2, length = size(data, 2))   Time range on x-axis. sorting_variables::Vector = [:y, :x]   Method to sort channels on y-axis.   For instance, you can sort by channel positions on the scalp (x, y) or channel name.  sorting_reverse::Vector = [:false, :false]  Should sorting variables be reversed or not? Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", ylabel = \"Channels\", yticklabelsize = 14) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = Makie.Reverse{String}(\"RdBu\"),) -  use  kwargs...  of  Makie.heatmap legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, label = \"Voltage [µV]\") -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Channel image. source"},{"id":312,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_circular_topoplots","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_circular_topoplots-Tuple{DataFrame}","content":" UnfoldMakie.plot_circular_topoplots  —  Method plot_circular_topoplots!(f, data::DataFrame; kwargs...) using ColorSchemes: topo using ColorSchemes: topo using ColorSchemes: topo     plot circular topoplots(data::DataFrame; kwargs...) Plot a circular EEG topoplot. Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::DataFrame   DataFrame with data keys (columns  :y, :yhat, :estimate ), and :position (columns  :pos, :position, :positions ). Keyword arguments (kwargs) predictor::Vector{Any} = :predictor   The circular predictor value, defines position of topoplot across the circle.   Mapped around  predictor_bounds . predictor_bounds::Vector{Int64} = [0, 360]   The bounds of the predictor. Relevant for the axis labels. positions::Vector{Point{2, Float32}} = nothing   Positions of the  plot_topoplot . center_label::String = \"\"   The text in the center of the cricle. plot_radius::String = 0.8   The radius of the circular topoplot series plot calucalted by formula:  radius = (minwidth * plot_radius) / 2 . labels::Vector{String} = nothing   Labels for the  plot_topoplots . topo_axis::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot axis.   To see all options just type  ?Axis  in REPL.   Defaults: (width = Relative(0.2f0), height = Relative(0.2f0), aspect = 1) topo_attributes::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot interoplation.   To see all options just type  ?Topoplot.topoplot  in REPL.   Defaults: interp_resolution = (128, 128), interpolation = CloughTocher() Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", aspect = 1) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = false, use_colorbar = true, hidespines = (), hidedecorations = Dict{Symbol, Bool}(:label => 0)) -  check this  page mapping =  (x = nothing, y = (:estimate, :yhat, :y), positions = (:pos, :positions, :position, nothing), labels = (:labels, :label, :sensor, nothing)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = Makie.Reverse{Symbol}(:RdBu), contours = (color = :white, linewidth = 2), enlarge = 1, label_scatter = true, label_text = false, bounding_geometry = GeometryBasics.Circle) -  use  kwargs...  of  Topoplot.eeg_topoplot legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, flipaxis = true, label = \"Voltage [µV]\", colormap = Makie.Reverse{Symbol}(:RdBu)) -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Circular topoplot series. source"},{"id":313,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_designmatrix","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_designmatrix-Tuple{Union{AbstractDesignMatrix, Vector{<:AbstractDesignMatrix}}}","content":" UnfoldMakie.plot_designmatrix  —  Method plot_designmatrix!(f::Union{GridPosition, GridLayout, Figure}, data::Unfold.DesignMatrix; kwargs...)\nplot_designmatrix(data::Unfold.DesignMatrix; kwargs...) Plot a designmatrix.  Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Unfold.DesignMatrix   Data for the plot visualization. Keyword arguments (kwargs) standardize_data::Bool = false   Indicates whether the data is standardized by pointwise division of the data with its sampled standard deviation. sort_data::Bool = false   Indicates whether the data is sorted. It uses  sortslices()  of Base Julia.  xticks::Num = nothing   Specifies the number of labels displayed on the x-axis. xticks = 0 : No labels are displayed. xticks = 1 : Only the first label is displayed. xticks = 2 : The first and last labels are displayed. 2 < xticks < number of labels : The labels are evenly distributed across the axis. xticks ≥ number of labels : All labels are displayed. Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Conditions\", ylabel = \"Trials\", xticklabelrotation = 0.39) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = :roma,) -  use  kwargs...  of  Makie.heatmap legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, flipaxis = true, label = \"\") -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Design matrix.  source"},{"id":314,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_erp","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_erp-Tuple{Union{DataFrame, AbstractMatrix, AbstractVector{<:Number}}}","content":" UnfoldMakie.plot_erp  —  Method plot_erp!(f::Union{GridPosition, GridLayout, Figure}, plot_data::Union{DataFrame, AbstractMatrix, AbstractVector{<:Number}}; kwargs...)\nplot_erp(times, plot_data::Union{DataFrame, AbstractMatrix, AbstractVector{<:Number}}; kwargs...) Plot an ERP plot.    Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{Union{DataFrame, AbstractMatrix, AbstractVector{<:Number}, Vector{Float32}}   Data for the ERP plot visualization. kwargs...   Additional styling behavior.    Often used as:  plot_erp(df; mapping = (; color = :coefname, col = :conditionA)) . Keyword arguments (kwargs) stderror::Bool = false   Add an error ribbon, with lower and upper limits based on the  :stderror  column. significance::DataFrame = nothing   Show significant time periods as horizontal bars.   Example:  DataFrame(from = [0.1, 0.3], to = [0.5, 0.7], coefname = [\"(Intercept)\", \"condition: face\"]) .   If  coefname  is not specified, the significance lines will be black. layout.use_colorbar = true   Enable or disable colorbar. layout.use_legend = true   Enable or disable legend. layout.show_legend = true   Enable or disable legend and colorbar. mapping = (;)   Specify  color ,  col  (column),  linestyle ,  group .   F.i.  mapping = (; col = :group)  will make a column for each group. visual = (; color = Makie.wong_colors, colormap = :roma)   For categorical color use  visual.color , for continuous -  visual.colormap . Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", ylabel = \"Voltage [µV]\", yticklabelsize = 14, xtickformat = \"{:.1f}\") -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true, use_legend = true, hidespines = (:r, :t), hidedecorations = Dict{Symbol, Bool}(:grid => 1, :label => 0, :ticks => 0, :ticklabels => 0)) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y), color = (:color, :coefname, nothing)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = :roma, color = ColorTypes.RGBA{Float32}[RGBA(0.0, 0.44705883, 0.69803923, 1.0), RGBA(0.9019608, 0.62352943, 0.0, 1.0), RGBA(0.0, 0.61960787, 0.4509804, 1.0), RGBA(0.8, 0.4745098, 0.654902, 1.0), RGBA(0.3372549, 0.7058824, 0.9137255, 1.0), RGBA(0.8352941, 0.36862746, 0.0, 1.0), RGBA(0.9411765, 0.89411765, 0.25882354, 1.0)]) -  use  kwargs...  of  Makie.lines legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center, framevisible = false) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, label = \"\", flipaxis = true) -  use  kwargs...  of   AlgebraOfGraphics.colorbar! Return Value: Figure  displaying the ERP plot. source"},{"id":315,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_erpgrid","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_erpgrid-Tuple{Union{DataFrame, Matrix{<:Real}}, Vector, Vector{String}}","content":" UnfoldMakie.plot_erpgrid  —  Method plot_erpgrid(data::Union{Matrix{<:Real}, DataFrame}, positions::Vector; kwargs...)\nplot_erpgrid!(f::Union{GridPosition, GridLayout, Figure}, data::Union{Matrix{<:Real}, DataFrame}, positions::Vector, ch_names::Vector{String}; kwargs...) Plot an ERP image. Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{Matrix{<:Real}, DataFrame}   Data for the plot visualization.   Data should has a format of 1 row - 1 channel.  positions::Vector{Point{2,Float}}   Electrode positions. ch_names::Vector{String}   Vector with channel names. hlines_grid_axis::NamedTuple = (;)   Here you can flexibly change configurations of the hlines on all subaxes.   To see all options just type  ?hlines  in REPL.   Defaults: (color = :gray, linewidth = 0.5) vlines_grid_axis::NamedTuple = (;)   Here you can flexibly change configurations of the vlines on all subaxes.   To see all options just type  ?vlines  in REPL.   Defaults: (color = :gray, linewidth = 0.5, ymin = 0.2, ymax = 0.8) lines_grid_axis::NamedTuple = (;)   Here you can flexibly change configurations of the lines on all subaxes.   To see all options just type  ?lines  in REPL.   Defaults: (color = :deepskyblue3,) labels_grid_axis::NamedTuple = (;)   Here you can flexibly change configurations of the labels on all subaxes.   To see all options just type  ?text  in REPL.   Defaults: (color = :gray, fontsize = 12, align = (:left, :top), space = :relative) indicator_grid_axis::NamedTuple = (;)   Here you can change configurations of inidcator axis.   Defaults: (fontsize = 12, xlim = [-0.04, 1.0], ylim = [-0.04, 1.0], arrows start = Point{2, Float32}[[0.0, 0.0], [0.0, 0.0]], arrows dir = Vec{2, Float32}[[0.0, 0.1], [0.1, 0.0]], arrows kwargs = (arrowsize = 10,), text x coords = (0.02, 0), text x kwargs = (text = \"Time [s]\", align = (:left, :top), fontsize = 12), text y coords = (-0.008, 0.01), text y_kwargs = (text = \"Voltage [µV]\", align = (:left, :baseline), fontsize = 12, rotation = 1.5707963267948966)) subaxes::NamedTuple = (;)   Here you can flexibly change configurations of all subaxes. F.e. make them wider or shorter   To see all options just type  ?Axis  in REPL.   Defaults: (width = Relative(0.1f0), height = Relative(0.1f0)) Keyword arguments (kwargs) drawlabels::Bool = false   Draw channels labels over each waveform.  times::Vector = 1:size(data, 2)   Vector of  size() . Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (width = GridLayoutBase.Relative(1.05f0), height = GridLayoutBase.Relative(1.05f0)) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = :roma,) -  use  kwargs...  of  Makie.lines legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966) -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying ERP grid. source"},{"id":316,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_erpimage","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_erpimage-Tuple{Any}","content":" UnfoldMakie.plot_erpimage  —  Method plot_erpimage!(f::Union{GridPosition, GridLayout, Figure}, data::AbstractMatrix{Float64}; kwargs...)\nplot_erpimage!(f::Union{GridPosition, GridLayout, Figure}, data::Observable{<:AbstractMatrix}; kwargs...)\nplot_erpimage!(f::Union{GridPosition, GridLayout, Figure}, times::Observable{<:AbstractVector}, data::Observable{<:AbstractMatrix{<:Real}}; kwargs...)\n\nplot_erpimage(times::AbstractVector, data::Union{<:Observable{Matrix{<:Real}}, Matrix{<:Real}}; kwargs...)\nplot_erpimage(data::Matrix{Float64}; kwargs...) Plot an ERP image. Arguments: f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{DataFrame, Vector{Float32}}   Data for the plot visualization. Keyword arguments (kwargs) erpblur::Number = 10   Number indicating how much blur is applied to the image.    Gaussian blur of the  ImageFiltering  module is used.   Non-Positive values deactivate the blur. sortvalues::Vector{Int64} = false   Parameter over which plot will be sorted. Using  sortperm()  of Base Julia. sortperm()  computes a permutation of the array's indices that puts the array in sorted order.  sortindex::Vector{Int64} = nothing   Sorting over index values. meanplot::bool = false   Add a line plot below the ERP image, showing the mean of the data. show_sortval::bool = false   Add a plot on the right from ERP image, showing the distribution of the sorting data. sortval_xlabel::String = \"Sorting variable\"   If  show_sortval = true  controls xlabel. axis.ylabel::String = \"Trials\"   If  sortvalues = true  the default text will change to \"Sorted trials\", but it could be changed to any values specified manually. meanplot_axis::NamedTuple = (;)   Here you can flexibly change configurations of meanplot.   To see all options just type  ?Axis  in REPL.   Defaults: (height = 100, xlabel = \"Time\", xlabelpadding = 0, xautolimitmargin = (0, 0)) sortplot_axis::NamedTuple = (;)   Here you can flexibly change configurations of meanplot.   To see all options just type  ?Axis  in REPL.   Defaults: (ylabelvisible = true, yticklabelsvisible = false) Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", ylabel = \"Trials\") -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = Makie.Reverse{String}(\"RdBu\"),) -  use  kwargs...  of  Makie.heatmap legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, label = \"Voltage [µV]\") -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the ERP image.  source"},{"id":317,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_parallelcoordinates","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_parallelcoordinates-Tuple{Union{DataFrame, AbstractMatrix}}","content":" UnfoldMakie.plot_parallelcoordinates  —  Method plot_parallelcoordinates(data::Union{DataFrame, AbstractMatrix}; kwargs...)\nplot_parallelcoordinates!(f::Union{GridPosition, GridLayout, Figure}, data::Union{DataFrame, AbstractMatrix}; kwargs) Plot a PCP (parallel coordinates plot). Dimensions: conditions, channels, time, trials.  Arguments: f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{DataFrame, AbstractMatrix}   Data for the plot visualization. Keyword arguments (kwargs) normalize::Symbol = nothing   If  :minmax , normalize each axis to their respective min-max range. ax_labels::Vector{String} = nothing   Specify axis labels.    Should be a vector of labels with length equal to the number of unique  mapping.x  values.   Example:  ax_labels = [\"Fz\", \"Cz\", \"O1\", \"O2\"] . ax_ticklabels::Symbol = :outmost   Specify tick labels on axis. :all  - show all labels on all axes. :left  - show all labels on the left axis, but only min and max on others.  :outmost  - show labels on min and max of all other axes.  :none  - remove all labels.  bend::Bool = false   Change straight lines between the axes to curved (\"bent\") lines using spline interpolation.   Note: While this makes the plot look cool, it is not generally recommended to bent the lines, as interpretation   suffers, and the resulting visualizations can be potentially missleading. visual.alpha::Number = 0.5   Change of line transparency. Defining the axes mapping.x = :channel, mapping.y = :estimate .   Overwrite what should be on the x and the y axes. mapping.color = :colorcolumn   Split conditions by color. The default color is  :black . Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Channels\", ylabel = \"Time\", title = \"\", xlabelpadding = 14, ylabelpadding = 26) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = :channel, y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = ColorTypes.RGBA{Float32}[RGBA(0.0, 0.44705883, 0.69803923, 1.0), RGBA(0.9019608, 0.62352943, 0.0, 1.0), RGBA(0.0, 0.61960787, 0.4509804, 1.0), RGBA(0.8, 0.4745098, 0.654902, 1.0), RGBA(0.3372549, 0.7058824, 0.9137255, 1.0), RGBA(0.8352941, 0.36862746, 0.0, 1.0), RGBA(0.9411765, 0.89411765, 0.25882354, 1.0)], color = :black, alpha = 0.3) -  use  kwargs...  of  Makie.lines legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center, title = \"Conditions\", merge = true, framevisible = false) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966) -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Parallel coordinates plot. source"},{"id":318,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_splines","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_splines-Tuple{UnfoldModel}","content":" UnfoldMakie.plot_splines  —  Method plot_splines(m::UnfoldModel; kwargs...)\nplot_splines!(f::Union{GridPosition, GridLayout, Figure}, m::UnfoldModel; kwargs...) Visualization of spline terms in an UnfoldModel. Two subplots are generated for each spline term: 1) the basis function of the spline; 2) the density of the underlying covariate. Multiple spline terms are arranged across columns. Dashed lines indicate spline knots. Arguments: f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. m::UnfoldModel   UnfoldModel with splines. spline_axis::NamedTuple = (;)   Here you can flexibly change configurations of spline subplots.   To see all options just type  ?Axis  in REPL.   Defaults: (ylabel = \"Spline value\", xlabelvisible = false, xticklabelsvisible = false, ylabelvisible = true)     density_axis::NamedTuple = (;)   Here you can flexibly change configurations of density subplots.   To see all options just type  ?Axis  in REPL.   Defaults: (xautolimitmargin = (0, 0), ylabel = \"Density value\") superlabel_config::NamedTuple = (;)   Here you can flexibly change configurations of the Label on the top of the plot.   To see all options just type  ?Label  in REPL.   Defaults: (fontsize = 20, padding = (0, 0, 40, 0)) Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  NamedTuple() -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = :viridis,) -  use  kwargs...  of  Makie.series legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center, title = \"Splines\", framevisible = false) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966) -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  with splines and their density for basis functions. source"},{"id":319,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_topoplot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_topoplot-Tuple{Union{AbstractDataFrame, Observable{<:AbstractVector}, Observable{<:DataFrame}, AbstractVector}}","content":" UnfoldMakie.plot_topoplot  —  Method plot_topoplot!(f::Union{GridPosition, GridLayout, Figure}, data::Union{<:Observable{<:DataFrame},<:AbstractDataFrame,<:AbstractVector}; positions::Vector, labels = nothing, kwargs...)\nplot_topoplot(data::Union{<:Observable{<:DataFrame},<:AbstractDataFrame,<:AbstractVector}; position::Vector, labels = nothing, kwargs...) Plot a topoplot. Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{<:Observable{<:DataFrame},<:AbstractDataFrame,<:AbstractVector}   Data for the plot visualization. positions::Vector{Point{2, Float32}}   Positions used if  data  is not a  DataFrame . Positions are generated from  labels  if  positions = nothing . labels::Vector{String} = nothing   Labels used if  data  is not a DataFrame. high_chan = nothing  - channnel(s) to highlight by color. high_color = :darkgreen  - color for highlighting.  topo_axis::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot axis.   To see all options just type  ?Axis  in REPL.   Defaults: (width = Relative(1.0f0), height = Relative(1.0f0), halign = 0.05, valign = 0.95, aspect = DataAspect()) topo_attributes::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot interoplation.   To see all options just type  ?Topoplot.topoplot  in REPL.   Defaults: interp_resolution = (128, 128), interpolation = CloughTocher() Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", aspect = Makie.DataAspect()) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true, hidespines = (), hidedecorations = Dict{Symbol, Bool}(:label => 0)) -  check this  page mapping =  (x = nothing, y = (:estimate, :yhat, :y), positions = (:pos, :positions, :position, nothing), labels = (:labels, :label, :sensor, nothing)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = Makie.Reverse{Symbol}(:RdBu), contours = (color = :white, linewidth = 2), enlarge = 1, label_scatter = true, label_text = false, bounding_geometry = GeometryBasics.Circle) -  use  kwargs...  of  Topoplot.eeg_topoplot legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, flipaxis = true, label = \"Voltage [µV]\") -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Topoplot. source"},{"id":320,"pagetitle":"API: Functons","title":"UnfoldMakie.plot_topoplotseries","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.plot_topoplotseries-Tuple{Union{DataFrame, Observable{<:DataFrame}}}","content":" UnfoldMakie.plot_topoplotseries  —  Method plot_topoplotseries(f::Union{GridPosition, GridLayout, Figure}, data::Union{<:Observable{<:DataFrame},DataFrame}; kwargs...)\nplot_topoplotseries!(data::Union{<:Observable{<:DataFrame},DataFrame}; kwargs...) Multiple miniature topoplots in regular distances.  Arguments f::Union{GridPosition, GridLayout, GridLayoutBase.GridSubposition, Figure} Figure ,  GridLayout ,  GridPosition , or  GridLayoutBase.GridSubposition  to draw the plot. data::Union{<:Observable{<:DataFrame},DataFrame}   DataFrame with data or Observable DataFrame.   Requires a  time  column by default, but can be overridden by specifying  mapping=(; x=:my_column)  with any continuous or categorical column.  Keyword arguments (kwargs) bin_width::Real = nothing   Number specifing the width of bin of continuous x-value in its units. bin_num::Real = nothing   Number of topoplots.   Either  bin_width , or  bin_num  should be specified. Error if they are both specified   If  mapping.col  or  mapping.row  are categorical  bin_width  and  bin_num  stay as  nothing . combinefun::Function = mean   Specify how the samples within  bin_width  are summarised.   Example functions:  mean ,  median ,  std .  rasterize_heatmaps::Bool = true   Force rasterization of the plot heatmap when saving in  svg  format.   Except for the interpolated heatmap, all lines/points are vectors.   This is typically what you want, otherwise you get ~128x128 vectors per topoplot, which makes everything very slow. col_labels::Bool ,  row_labels::Bool = true   Shows column and row labels in faceting mode. (not implemented) positions::Vector{Point{2, Float32}} = nothing   Specify channel positions. Requires the list of x and y positions for all unique electrodes. labels::Vector{String} = nothing   Show labels for each electrode. interactive_scatter = nothing   Enable interactive mode.   If you create  obs_tuple = Observable((0, 0, 0))  and pass it into  interactive_scatter  you can update the observable tuple with the indices of the clicked topoplot markers. (0, 0, 0)  corresponds to the (row of topoplot layout, column of topoplot layout, electrode).  topo_axis::NamedTuple = (;)   Here you can flexibly change configurations of topoplots.   To see all options just type  ?Axis  in REPL. mapping = (; col = :time , row = nothing, layout = nothing) mapping.col  - specify x-value, can be any continuous or categorical variable. mapping.row  - specify y-value, can be any continuous or categorical variable (not implemented yet). mapping.layout  - arranges topoplots by rows when equals  :time . topo_attributes::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot interoplation.   To see all options just type  ?Topoplot.topoplot  in REPL.   Defaults: interp_resolution = (128, 128), interpolation = CloughTocher() topolabels_rounding = (; sigdigits = 3)   Rounding of the topo_axis labels. sigdigits  - number of significant digits. digits  - number of digits after the decimal point.   Only one of  sigdigits  or  digits  should be provided. Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time windows\", aspect = Makie.DataAspect(), title = \"\", titlesize = 16, titlefont = :bold, ylabel = \"\", ylabelpadding = 25, xlabelpadding = 25, xpanlock = true, ypanlock = true, xzoomlock = true, yzoomlock = true, xrectzoom = false, yrectzoom = false) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true, hidespines = (), hidedecorations = Dict{Symbol, Bool}(:label => 0)) -  check this  page mapping =  (x = nothing, y = (:estimate, :yhat, :y), positions = (:pos, :positions, :position, nothing), labels = (:labels, :label, :sensor, nothing), col = (:time,), row = (nothing,)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = Makie.Reverse{Symbol}(:RdBu), contours = (color = :white, linewidth = 2), enlarge = 1, label_scatter = false, label_text = false, bounding_geometry = GeometryBasics.Circle, levels = nothing) -  use  kwargs...  of  Topoplot.eeg_topoplot legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, flipaxis = true, label = \"Voltage [µV]\") -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Topoplot series. source"},{"id":321,"pagetitle":"API: Functons","title":"UnfoldMakie.rel_to_abs_bbox","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.rel_to_abs_bbox-Tuple{Any, Any}","content":" UnfoldMakie.rel_to_abs_bbox  —  Method rel_to_abs_bbox(org, rel) Takes a rectangle  org  consiting of coordinates of origins and applies the relative transformation tuple  rel . Return Value: Makie.BBox . source"},{"id":322,"pagetitle":"API: Functons","title":"UnfoldMakie.supportive_defaults","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.supportive_defaults-Tuple{Symbol}","content":" UnfoldMakie.supportive_defaults  —  Method supportive_defaults(cfg_symb::Symbol) Default configurations for the supporting axis. Similar to PlotConfig, but these configurations are not shared by all plots. Such supporting axes allow users to flexibly see defaults in docstrings and manipulate them using corresponding axes. For developers: to make them updateable in the function, use  update_axis .  Return value: NamedTuple . source"},{"id":323,"pagetitle":"API: Functons","title":"UnfoldMakie.to_positions","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.to_positions-Tuple{AbstractMatrix}","content":" UnfoldMakie.to_positions  —  Method to_positions(x, y, z; sphere = [0, 0, 0.])\nto_positions(pos::AbstractMatrix; sphere = [0, 0, 0.]) Projects 3D electrode positions to a 2D layout. Reimplementation of the MNE algorithm. Assumes  size(pos) = (3, nChannels)  when input is  AbstractMatrix . Tip: You can get positions directly from an MNE object after loading PyMNE and enabling the UnfoldMakie PyMNE extension. Return Value: Vector{Point2{Float64}} .  source"},{"id":324,"pagetitle":"API: Functons","title":"UnfoldMakie.update_axis","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.update_axis-Tuple{NamedTuple}","content":" UnfoldMakie.update_axis  —  Method update_axis(support_axis::NamedTuple; kwargs...) Update values of  NamedTuple{key = value} . Used for supportive axes to make users be able to flexibly change them. source Internally, we use a  PlotConfig  struct to keep track of common plotting options, so that all functions have a similar API."},{"id":325,"pagetitle":"API: Functons","title":"UnfoldMakie.PlotConfig","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.PlotConfig","content":" UnfoldMakie.PlotConfig  —  Type PlotConfig(<plotname>) Contains several different fields that can modify various aspects of the plot. source"},{"id":326,"pagetitle":"API: Functons","title":"UnfoldMakie.PCPTicks","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/api/#UnfoldMakie.PCPTicks","content":" UnfoldMakie.PCPTicks  —  Type PCPTicks Used to inject extrema ticks and round them if necessary. source"},{"id":329,"pagetitle":"Code principles","title":"Clear Code","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/code_principles/#Clear-Code","content":" Clear Code Code should be clear and concise. Variables in the code should have meaningful names. Function naming should follow established theories and naming conventions. Avoid functions longer than 50 lines to improve code readability. Write modular code by breaking complex tasks into smaller, reusable functions. Avoid deep nesting of loops and conditionals. Avoid putting more than 5 functions in a single file. Avoid pull requests that affect more than 10 files. Maintain consistent indentation and formatting across all files. Enforce it with linters (e.g., JuliaFormatter). Write meaningful commit messages that explain what changed and why (e.g., \"Refactored plot function for better readability\" instead of \"fix\"). Minimize external dependencies. Only use external libraries when necessary to avoid compatibility issues and to reduce installation and loading time."},{"id":330,"pagetitle":"Code principles","title":"Backward Compatibility","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/code_principles/#Backward-Compatibility","content":" Backward Compatibility Backward compatibility means that newer versions of your software should work with old code written for older versions without major changes. Provide a clear changelog for new versions, detailing new features, fixes, and potential breaking changes. Avoid breaking changes whenever possible. Ensure consistent output formats. If your function previously returned a dictionary, avoid switching it to a list unless necessary. Use deprecation warnings. If a feature will be removed in future versions, notify users with warnings instead of immediately breaking their code. Use versioned documentation. Keep documentation for previous versions accessible so users with older codebases can still find relevant information. Avoid removing or renaming functions or their arguments. If you must remove a function or its argument, keep the old name as an alias or mark it as deprecated before removal. Write unit tests to prevent unexpected behavior whenever you add new features."},{"id":331,"pagetitle":"Code principles","title":"User-Friendliness","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/code_principles/#User-Friendliness","content":" User-Friendliness Every function exposed to the user should have docstrings specifying all parameters, their types, and input/output arguments. Ensure the documentation includes visual and code examples where applicable, especially if the figure is commonly used and/or complex. Users should have the ability to customize all parts of the figure. Most users will not check the default settings, so it is important to encourage them to label key details of the figure. Comment the code, especially if the code is not self-explanatory. But don't overuse it. Provide meaningful error messages that guide users toward solutions. Test the usability of your code with non-expert users to identify pain points. Written by  Vladimir Mikheev This page was generated using  Literate.jl ."},{"id":334,"pagetitle":"Installing Julia & UnfoldMakie.jl","title":"Getting Julia","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/installation/#Getting-Julia","content":" Getting Julia You can install Julia by following the instructions from the  official website ."},{"id":335,"pagetitle":"Installing Julia & UnfoldMakie.jl","title":"Setup UnfoldMakie.jl","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/installation/#Setup-UnfoldMakie.jl","content":" Setup UnfoldMakie.jl After installing Julia, you can execute the  julia.exe ."},{"id":336,"pagetitle":"Installing Julia & UnfoldMakie.jl","title":"Generate a Project","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/installation/#Generate-a-Project","content":" Generate a Project If you do not yet have a project you can generate one. First you type  ]  into the Julia console to switch from  julia  to  (@VERSION) pkg . Here you can generate a project by using the command: generate \"FOLDER_PATH\" Note that the specific folder in which you want to generate the project does not already exist."},{"id":337,"pagetitle":"Installing Julia & UnfoldMakie.jl","title":"Activate your Project","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/installation/#Activate-your-Project","content":" Activate your Project Before you can add the necessary modules to use UnfoldMakie you have to activate your project in the  (@VERSION) pkg  environment. The command is: activate \"FOLDER_PATH\""},{"id":338,"pagetitle":"Installing Julia & UnfoldMakie.jl","title":"Install the UnfoldMakie Module","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/installation/#Install-the-UnfoldMakie-Module","content":" Install the UnfoldMakie Module When your project is activated you can add the module. The command is: add UnfoldMakie"},{"id":339,"pagetitle":"Installing Julia & UnfoldMakie.jl","title":"Using the Project in a Pluto Notebook","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/installation/#Using-the-Project-in-a-Pluto-Notebook","content":" Using the Project in a Pluto Notebook In case you want to use this generated project in a notebook (e.g.  Pluto  or  Jupyter ), you can activate this in the notebook in the following manner: begin\n   using Pkg\n   Pkg.activate(\"FOLDER_PATH\")\n   Pkg.resolve()\nend Use slash  /  for the folder path. This page was generated using  Literate.jl ."},{"id":342,"pagetitle":"Key features","title":"Features of UnfoldMakie.jl","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/key_features/#features","content":" Features of UnfoldMakie.jl Or why this package is cool and you should use it. Focused. UnfoldMakie.jl  focuses exclusively on visualizing (r)ERPs, unlike other toolboxes such as  EEGLAB ,  FieldTrip ,  Brainstorm , or  MNE . This makes it easier to understand, use, and maintain the package in the future. Customizable.  The majority of EEG researchers perceive the flexibility of coding as the most important feature of the EEG toolbox. Consequently, users of  UnfoldMakie.jl  have great flexibility in customizing most aspects of the plots, such as colors, line styles, and axis decorations. Combining plots.  The layout system for subplots in  Makie.jl  makes it easy to combine and align various plot types. Flexible mapping.  With  AlgebraOfGraphics.jl , it is easy to map conditions, groups, channels, or other features to a large variety of aesthetics like linestyle, color, marker, and others. It works similarly to the popular R package  ggplot2 . Flexible data input.  All functions support basic  Arrays  and tidy  DataFrames . Fast.  Julia and  Makie.jl  allow fast plotting of figures with very complex layouts. For example, it can plot one figure with 50 topoplots in 1.9 seconds (1.6 sec with DelaunayMesh interpolation), which is approximately 20 times faster compared to  EEGLAB . (Although the Python-based  MNE  is faster by one second.) For more details, see  this page . Faster updating. Makie.jl  is incredibly fast at updating figures, which is beneficial for developing interactive tools and creating animations.  UnfoldMakie.jl  can create and save a topoplot gif file with 50 frames in 1.7 times less time than  MNE  (Table 2). Interactive.  Several plots in our package have interactive features. They are supported by  Observables.jl , which allows for fast data exchange and quick plot updating. Scientific color maps.  According to our previous study  (Mikheev, 2024) , 40% of EEG researchers are not aware of the issue of perceptually non-uniform color maps.  UnfoldMakie.jl  uses scientific color maps throughout. Documented.  There is extensive documentation with many usage examples and docstrings. This page was generated using  Literate.jl ."},{"id":345,"pagetitle":"Plot types","title":"The Dilemma of Multidimensionality","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/plot_types/#The-Dilemma-of-Multidimensionality","content":" The Dilemma of Multidimensionality Note Please read the paper  The Art of Brainwaves , if you want to know how we come up with these plot types. EEG – multidimensional data and could be presented differently. Possible dimensions: Voltage (must have) Time Number of channels (1-128) Spatial layout of channels Experimental conditions Trials/subjects Each way of ERP presentation is a choice of dimensions. Hard to show meaningfully more than 3 dimensions."},{"id":346,"pagetitle":"Plot types","title":"Plot types","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/plot_types/#Plot-types","content":" Plot types Each plot type can represent several dimensions. Here we represented 8 plot types. This page was generated using  Literate.jl ."},{"id":349,"pagetitle":"Benchmarks","title":"Speed measurement","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/speed/#Speed-measurement","content":" Speed measurement Here we will compare the speed of plotting UnfoldMakie with MNE (Python) and EEGLAB (MATLAB). Three cases are measured: Single topoplot Topoplot series with 50 topoplots Topoplott animation with 50 timestamps Note that the results of benchmarking on your computer and on Github may differ. using UnfoldMakie\nusing TopoPlots\nusing BenchmarkTools\nusing Observables\nusing CairoMakie\nusing PythonPlot;\nusing PyMNE;     CondaPkg Found dependencies: /home/runner/.julia/packages/PyMNE/HGgbW/CondaPkg.toml\n    CondaPkg Found dependencies: /home/runner/.julia/packages/PythonCall/WMWY0/CondaPkg.toml\n    CondaPkg Found dependencies: /home/runner/.julia/packages/PythonPlot/oS8x4/CondaPkg.toml\n    CondaPkg Initialising pixi\n             │ /home/runner/.julia/artifacts/cefba4912c2b400756d043a2563ef77a0088866b/bin/pixi\n             │ init\n             │ --format pixi\n             └ /home/runner/work/UnfoldMakie.jl/UnfoldMakie.jl/docs/.CondaPkg\n✔ Created /home/runner/work/UnfoldMakie.jl/UnfoldMakie.jl/docs/.CondaPkg/pixi.toml\n    CondaPkg Wrote /home/runner/work/UnfoldMakie.jl/UnfoldMakie.jl/docs/.CondaPkg/pixi.toml\n             │ [dependencies]\n             │ openssl = \">=3, <3.6\"\n             │ uv = \">=0.4\"\n             │ libstdcxx-ng = \">=3.4,<13.0\"\n             │ matplotlib = \">=1\"\n             │\n             │     [dependencies.python]\n             │     channel = \"conda-forge\"\n             │     build = \"*cpython*\"\n             │     version = \">=3.8,<4, >=3.4,<4\"\n             │\n             │ [project]\n             │ name = \".CondaPkg\"\n             │ platforms = [\"linux-64\"]\n             │ channels = [\"conda-forge\", \"anaconda\"]\n             │ channel-priority = \"strict\"\n             │ description = \"automatically generated by CondaPkg.jl\"\n             │\n             │ [pypi-dependencies]\n             └ mne = \">=1.4\"\n    CondaPkg Installing packages\n             │ /home/runner/.julia/artifacts/cefba4912c2b400756d043a2563ef77a0088866b/bin/pixi\n             │ install\n             └ --manifest-path /home/runner/work/UnfoldMakie.jl/UnfoldMakie.jl/docs/.CondaPkg/pixi.toml\n✔ The default environment has been installed. Data input dat, positions = TopoPlots.example_data()\ndf = UnfoldMakie.eeg_array_to_dataframe(dat[:, :, 1], string.(1:length(positions)));"},{"id":350,"pagetitle":"Benchmarks","title":"Topoplots","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/speed/#Topoplots","content":" Topoplots UnfoldMakie.jl @benchmark plot_topoplot(dat[:, 320, 1]; positions = positions) BenchmarkTools.Trial: 135 samples with 1 evaluation per sample.\n Range  ( min  …  max ):   32.930 ms  …  168.949 ms    ┊  GC  ( min … max ):  0.00% … 58.72%\n Time   ( median ):      33.670 ms                ┊  GC  ( median ):     0.00%\n Time   ( mean  ±  σ ):    36.943 ms  ±   18.225 ms    ┊  GC  ( mean ± σ ):   5.39% ±  8.47%\n\n   █ ▁ ▁                                                            \n   █ █ █ ▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▁▁▁▄ ▄\n  32.9 ms        Histogram:  log( frequency )  by time        159 ms  < \n\n Memory estimate :  9.10 MiB , allocs estimate :  138086 . UnfoldMakie.jl with DelaunayMesh @benchmark plot_topoplot(\n    dat[:, 320, 1];\n    positions = positions,\n    topo_interpolation = (; interpolation = DelaunayMesh()),\n) BenchmarkTools.Trial: 136 samples with 1 evaluation per sample.\n Range  ( min  …  max ):   32.633 ms  …  186.605 ms    ┊  GC  ( min … max ):  0.00% … 55.03%\n Time   ( median ):      33.417 ms                ┊  GC  ( median ):     0.00%\n Time   ( mean  ±  σ ):    36.813 ms  ±   19.258 ms    ┊  GC  ( mean ± σ ):   5.41% ±  8.18%\n\n   █ ▃                                                              \n   █ █ ▅ ▅▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁▄ ▄\n  32.6 ms        Histogram:  log( frequency )  by time        162 ms  < \n\n Memory estimate :  9.10 MiB , allocs estimate :  138091 . MNE posmat = collect(reduce(hcat, [[p[1], p[2]] for p in positions])')\npypos = Py(posmat).to_numpy()\npydat = Py(dat[:, 320, 1])\n\n@benchmark begin\n    f = PythonPlot.figure()\n    PyMNE.viz.plot_topomap(\n        pydat,\n        pypos,\n        sphere = 1.1,\n        extrapolate = \"box\",\n        cmap = \"RdBu_r\",\n        sensors = false,\n        contours = 6,\n    )\n    f.show()\nend BenchmarkTools.Trial: 306 samples with 1 evaluation per sample.\n Range  ( min  …  max ):   11.783 ms  …  646.629 ms    ┊  GC  ( min … max ):  0.00% … 0.00%\n Time   ( median ):      12.161 ms                ┊  GC  ( median ):     0.00%\n Time   ( mean  ±  σ ):    16.340 ms  ±   48.843 ms    ┊  GC  ( mean ± σ ):   0.00% ± 0.00%\n\n  ▄█ ▇  ▄▆▁                                                         \n  ██ █ ████▅▆▄▆▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▁ ▁▁▁▁▁▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄ ▆\n  11.8 ms        Histogram:  log( frequency )  by time       22.1 ms  < \n\n Memory estimate :  4.12 KiB , allocs estimate :  124 ."},{"id":351,"pagetitle":"Benchmarks","title":"Topoplot series","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/speed/#Topoplot-series","content":" Topoplot series Note that UnfoldMakie and MNE have different defaults for displaying topoplot series. UnfoldMakie in  plot_topoplot  averages over time samples. MNE in  plot_topopmap  displays single samples without averaging. UnfoldMakie.jl @benchmark begin\n    plot_topoplotseries(\n        df;\n        bin_num = 50,\n        positions = positions,\n        axis = (; xlabel = \"Time windows [s]\"),\n    )\nend BenchmarkTools.Trial: 3 samples with 1 evaluation per sample.\n Range  ( min  …  max ):   1.873 s  …    2.067 s    ┊  GC  ( min … max ):  0.00% … 8.80%\n Time   ( median ):      1.943 s               ┊  GC  ( median ):     3.54%\n Time   ( mean  ±  σ ):    1.961 s  ±  98.518 ms    ┊  GC  ( mean ± σ ):   4.26% ± 4.43%\n\n   █                    █                                     █  \n   █ ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁ ▁ ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  1.87 s          Histogram: frequency by time         2.07 s  < \n\n Memory estimate :  399.95 MiB , allocs estimate :  5785067 . MNE easycap_montage = PyMNE.channels.make_standard_montage(\"standard_1020\")\nch_names = pyconvert(Vector{String}, easycap_montage.ch_names)[1:64]\ninfo = PyMNE.create_info(PyList(ch_names), ch_types = \"eeg\", sfreq = 1)\ninfo.set_montage(easycap_montage)\nsimulated_epochs = PyMNE.EvokedArray(Py(dat[:, :, 1]), info)\n\n@benchmark simulated_epochs.plot_topomap(1:50) BenchmarkTools.Trial: 6 samples with 1 evaluation per sample.\n Range  ( min  …  max ):   696.940 ms  …     2.066 s    ┊  GC  ( min … max ):  0.00% … 0.00%\n Time   ( median ):      703.423 ms                ┊  GC  ( median ):     0.00%\n Time   ( mean  ±  σ ):    928.999 ms  ±  557.127 ms    ┊  GC  ( mean ± σ ):   0.00% ± 0.00%\n\n   █                                                                 \n   █ ▁▁▁▁▁▁▁▁▁ ▁ ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▅ ▁\n  697 ms            Histogram: frequency by time           2.07 s  < \n\n Memory estimate :  3.06 KiB , allocs estimate :  98 . MATLAB Running MATLAB on a GitHub Action is not easy. So we benchmarked three consecutive executions (on a screenshot) on a server with an AMD EPYC 7452 32-core processor. Note that Github and the server we used for MATLAB benchmarking are two different computers, which can give different timing results."},{"id":352,"pagetitle":"Benchmarks","title":"Animation","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/explanations/speed/#Animation","content":" Animation The main advantage of Julia is the speed with which the figures are updated. timestamps = range(1, 50, step = 1)\nframerate = 50 50 UnfoldMakie with .gif @benchmark begin\n    f = Makie.Figure()\n    dat_obs = Observable(dat[:, 1, 1])\n    plot_topoplot!(f[1, 1], dat_obs, positions = positions)\n    record(f, \"topoplot_animation_UM.gif\", timestamps; framerate = framerate) do t\n        dat_obs[] = @view(dat[:, t, 1])\n    end\nend BenchmarkTools.Trial: 2 samples with 1 evaluation per sample.\n Range  ( min  …  max ):   4.020 s  …    4.035 s    ┊  GC  ( min … max ):  0.73% … 1.39%\n Time   ( median ):      4.028 s               ┊  GC  ( median ):     1.06%\n Time   ( mean  ±  σ ):    4.028 s  ±  10.801 ms    ┊  GC  ( mean ± σ ):   1.06% ± 0.47%\n\n   █                                                          █  \n   █ ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▁ ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  4.02 s          Histogram: frequency by time         4.04 s  < \n\n Memory estimate :  680.84 MiB , allocs estimate :  961870 . MNE with .gif @benchmark begin\n    fig, anim = simulated_epochs.animate_topomap(\n        times = Py(timestamps),\n        frame_rate = framerate,\n        blit = false,\n        image_interp = \"cubic\", # same as CloughTocher\n    )\n    anim.save(\"topomap_animation_mne.gif\", writer = \"ffmpeg\", fps = framerate)\nend BenchmarkTools.Trial: 1 sample with 1 evaluation per sample.\n Single result which took  9.042 s  (0.00% GC) to evaluate,\n with a memory estimate of  4.07 KiB , over  150  allocations. Note, that due to some bugs in (probably)  PythonCall  topoplot is black and white. This page was generated using  Literate.jl ."},{"id":355,"pagetitle":"Include multiple figures in one","title":"Complex figures","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/complex_figures/#Complex-figures","content":" Complex figures This section discusses how users can incorporate multiple plots into a single figure."},{"id":356,"pagetitle":"Include multiple figures in one","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/complex_figures/#Setup","content":" Setup Library load using UnfoldMakie\nusing CairoMakie\nusing DataFramesMeta\nusing UnfoldSim\nusing Unfold\nusing MakieThemes\nusing TopoPlots Data input d_topo, positions = UnfoldMakie.example_data(\"TopoPlots.jl\")\nuf_deconv = UnfoldMakie.example_data(\"UnfoldLinearModelContinuousTime\")\nuf = UnfoldMakie.example_data(\"UnfoldLinearModel\");\nresults = coeftable(uf)\nuf_5chan = UnfoldMakie.example_data(\"UnfoldLinearModelMultiChannel\")\ndata, positions = TopoPlots.example_data()\ndat_e, evts, times = UnfoldMakie.example_data(\"sort_data\")\nd_singletrial, _ = UnfoldSim.predef_eeg(; return_epoched = true); \nProgress:   4%|█▉                                       |  ETA: 0:00:09\nProgress: 100%|█████████████████████████████████████████| Time: 0:00:00"},{"id":357,"pagetitle":"Include multiple figures in one","title":"Basic complex figure","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/complex_figures/#Basic-complex-figure","content":" Basic complex figure By using the !-version of the plotting function and inserting a grid position instead of an entire figure, we can create complex plot that combines several figures. We will start by creating a figure with  Makie.Figure . Now any plot can be added to  f  by placing a grid position, such as  f[1, 1] . Also we used a specified theme  fresh . f = Figure()\nwith_theme(theme_ggthemr(:fresh)) do\n\n    plot_erp!(f[1, 1], coeftable(uf_deconv))\n    plot_erp!(\n        f[1, 2],\n        effects(Dict(:condition => [\"car\", \"face\"]), uf_deconv),\n        mapping = (; color = :condition),\n    )\n    plot_butterfly!(f[2, 1:2], d_topo; positions = positions,\n        topo_attributes = (; label_scatter = (; markersize = 5)),\n        topo_axis = (; height = Relative(0.5), width = Relative(0.5)))\nend\nf"},{"id":358,"pagetitle":"Include multiple figures in one","title":"A very complex figure","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/complex_figures/#A-very-complex-figure","content":" A very complex figure We can create a large figure with any type of plot using predefined data. With so many plots at once, it's better to set a fixed resolution in your image to arrange the plots evenly. Click to expand begin\n    f = Figure(size = (2000, 2000))\n\n    plot_butterfly!(f[1, 1:3], d_topo; positions = positions)\n\n    pvals = DataFrame(\n        from = [0.1, 0.15],\n        to = [0.2, 0.5], # if coefname not specified, line should be black\n        coefname = [\"(Intercept)\", \"category: face\"],\n    )\n    plot_erp!(f[2, 1:2], results, significance = pvals, stderror = true)\n\n    plot_designmatrix!(f[2, 3], designmatrix(uf))\n\n    plot_topoplot!(f[3, 1], data[:, 150, 1]; positions = positions)\n    plot_topoplotseries!(\n        f[4, 1:3],\n        d_topo;\n        bin_width = 0.1,\n        positions = positions,\n        mapping = (; label = :channel),\n    )\n\n    res_effects = effects(Dict(:continuous => -5:0.5:5), uf_deconv)\n\n    plot_erp!(\n        f[2, 4:5],\n        res_effects;\n        mapping = (; y = :yhat, color = :continuous, group = :continuous => nonnumeric),\n        legend = (; nbanks = 2),\n    )\n\n    plot_parallelcoordinates(f[3, 2:3], uf_5chan; mapping = (; color = :coefname))\n\n    plot_erpimage!(f[1, 4:5], times, d_singletrial)\n    plot_circular_topoplots!(\n        f[3:4, 4:5],\n        d_topo[in.(d_topo.time, Ref(-0.3:0.1:0.5)), :];\n        positions = positions,\n        predictor = :time,\n        predictor_bounds = [-0.3, 0.5],\n    )\nend GridPosition(GridLayout[4, 5] (9 children), GridLayoutBase.Span(3:4, 4:5), GridLayoutBase.Inner()) f"},{"id":359,"pagetitle":"Include multiple figures in one","title":"Complex figure in two columns and with background color","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/complex_figures/#Complex-figure-in-two-columns-and-with-background-color","content":" Complex figure in two columns and with background color Click to expand function complex_figure3()\n    f = Figure(size = (1200, 1700))\n    ga = f[1, 1]\n    gc = f[2, 1]\n    ge = f[3, 1]\n    gg = f[4, 1]\n    gi = f[5:6, 1]\n    gb = f[1, 2]\n    gd = f[2, 2]\n    gf = f[3, 2]\n    gh = f[4, 2]\n    gj = f[5:6, 2]\n\n    d_topo, pos = UnfoldMakie.example_data(\"TopoPlots.jl\")\n    data, positions = TopoPlots.example_data()\n    df = UnfoldMakie.eeg_array_to_dataframe(data[:, :, 1], string.(1:length(positions)))\n    channels_30 = UnfoldMakie.example_montage(\"channels_30\")\n\n    m = UnfoldMakie.example_data(\"UnfoldLinearModel\")\n    results = coeftable(m)\n\n    results.coefname =\n        replace(results.coefname, \"condition: face\" => \"face\", \"(Intercept)\" => \"car\")\n    results = filter(row -> row.coefname != \"continuous\", results)\n\n    plot_erp!(\n        ga,\n        results;\n        :stderror => true,\n        mapping = (; color = :coefname => \"Conditions\"),\n        axis = (; backgroundcolor = colorant\"#F4F3EF\", xlabel = \"Time [ms]\"),\n    )\n    hlines!(0, color = :gray, linewidth = 1)\n    vlines!(0, color = :gray, linewidth = 1)\n    plot_butterfly!(\n        gb,\n        d_topo;\n        positions = pos,\n        topo_axis = (; height = Relative(0.4), width = Relative(0.4)),\n        axis = (; backgroundcolor = colorant\"#F4F3EF\", xlabel = \"Time [ms]\"),\n    )\n    hlines!(0, color = :gray, linewidth = 1)\n    vlines!(0, color = :gray, linewidth = 1)\n    plot_topoplot!(\n        gc,\n        data[:, 340, 1];\n        positions = positions,\n        topo_axis = (; backgroundcolor = colorant\"#F4F3EF\"),\n        axis = (; xlabel = \"[340 ms]\"),\n    )\n\n    plot_topoplotseries!(\n        gd,\n        df;\n        bin_width = 80,\n        positions = positions,\n        visual = (label_scatter = false,),\n        layout = (; use_colorbar = true),\n        topo_axis = (; backgroundcolor = colorant\"#F4F3EF\"),\n        axis = (; backgroundcolor = colorant\"#F4F3EF\", xlabel = \"Time [ms]\"),\n    )\n\n    plot_erpgrid!(\n        ge,\n        data[:, :, 1],\n        positions;\n        indicator_grid_axis = (;\n            ylim = [-0.05, 0.6], xlim = [-0.04, 1], text_x_kwargs = (; text = \"s\"),\n            text_y_kwargs = (; text = \"µV\"),\n        ),\n        axis = (; backgroundcolor = colorant\"#F4F3EF\",),\n    )\n\n    dat_e, evts, times = UnfoldMakie.example_data(\"sort_data\")\n    plot_erpimage!(\n        gf,\n        times,\n        dat_e;\n        sortvalues = evts.Δlatency,\n        axis = (; xlabel = \"Time [ms]\"),\n    )\n    m1 = UnfoldMakie.example_data(\"UnfoldLinearModelwith1Spline\")\n    plot_splines!(\n        gg,\n        m1;\n        spline_axis = (; backgroundcolor = colorant\"#F4F3EF\"),\n        density_axis = (; backgroundcolor = colorant\"#F4F3EF\"),\n    )\n    r1, positions = UnfoldMakie.example_data()\n    r2 = deepcopy(r1)\n    r2.coefname .= \"B\" # create a second category\n    r2.estimate .+= rand(length(r2.estimate)) * 0.1\n    results_plot = vcat(r1, r2)\n    plot_parallelcoordinates(\n        gh,\n        subset(results_plot, :channel => x -> x .< 8, :time => x -> x .< 0);\n        mapping = (; color = :coefname),\n        normalize = :minmax,\n        ax_labels = [\"FP1\", \"F3\", \"F7\", \"FC3\", \"C3\", \"C5\", \"P3\", \"P7\"],\n        axis = (; backgroundcolor = colorant\"#F4F3EF\", ylabel = \"Time [ms]\"),\n    )\n    df_circ = DataFrame(\n        :estimate => eachcol(Float64.(data[:, 100:40:300, 1])),\n        :circular_variable => [0, 50, 80, 120, 180, 210],\n        :time => 100:40:300,\n    )\n    df_circ = flatten(df_circ, :estimate)\n    plot_circular_topoplots!(\n        gi,\n        df_circ;\n        positions = pos,\n        center_label = \"Time [s]\",\n        predictor = :time,\n        topo_attributes = (; label_scatter = false,),\n        topo_axis = (; backgroundcolor = colorant\"#F4F3EF\"),\n        axis = (; backgroundcolor = colorant\"#F4F3EF\"),\n        predictor_bounds = [80, 320],\n        colorbar = (; height = 180),\n    )\n    plot_channelimage!(\n        gj,\n        data[1:30, :, 1],\n        positions[1:30],\n        channels_30;\n        axis = (; xlabel = \"Time [ms]\"),\n    )\n\n    for (label, layout) in\n        zip(\n        [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"],\n        [ga, gb, gc, gd, ge, gf, gg, gh, gi, gj],\n    )\n        Label(\n            layout[1, 1, TopLeft()],\n            label,\n            fontsize = 26,\n            font = :bold,\n            padding = (20, 20, 22, 0),\n            halign = :right,\n        )\n    end\n    f\nend complex_figure3 (generic function with 1 method) with_theme(Theme(; backgroundcolor = colorant\"#F4F3EF\")) do\n    complex_figure3()\nend This page was generated using  Literate.jl ."},{"id":362,"pagetitle":"Customize channel labels","title":"Customizing channel labels","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/customize_labels/#Customizing-channel-labels","content":" Customizing channel labels using CairoMakie, TopoPlots, MakieThemes\nusing UnfoldMakie Changing fonts and font size dat, positions = TopoPlots.example_data()\nlabels = [\"s$i\" for i = 1:size(dat, 1)]\n\nwith_theme(Theme(; fontsize = 25, fonts = (; regular = \"Ubuntu Mono\"))) do\n    plot_topoplot(\n        dat[:, 340, 1];\n        labels,\n        positions,\n        visual = (; label_text = true),\n        axis = (; xlabel = \"340 ms\"),\n    )\nend"},{"id":363,"pagetitle":"Customize channel labels","title":"But also check that the font you choose is available on your PC or GitHub.","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/customize_labels/#But-also-check-that-the-font-you-choose-is-available-on-your-PC-or-GitHub.","content":" But also check that the font you choose is available on your PC or GitHub. This page was generated using  Literate.jl ."},{"id":366,"pagetitle":"Hide decorations and axis spines","title":"Hiding decorations and spines","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/hide_deco/#Hiding-decorations-and-spines","content":" Hiding decorations and spines You have several options for efficiently hiding decorations and axis spines in a plot.  Packages and data using TopoPlots\nusing UnfoldMakie\nusing CairoMakie\nusing DataFrames\nusing UnfoldSim\n\ndata, pos = UnfoldMakie.example_data(\"TopoPlots.jl\")\ndat, evts = UnfoldSim.predef_eeg(; noiselevel = 10, return_epoched = true);"},{"id":367,"pagetitle":"Hide decorations and axis spines","title":"Hiding","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/hide_deco/#Hiding","content":" Hiding First, you can specify the axis settings with  axis = (; ...) . Makie.Axis  provides multiple variables for different aspects of the plot. This means that removing all decorations is only possible by setting many variables each time. Second,  Makie  does provide methods like  hidespines!  and  hidedecorations! . Unforunately, user may lose access to a plot after it is drawn in. Third,  hidespines!  and  hidedecorations!  can be called by setting variables with  layout = (; hidespines = (), hidedecorations = ()) . You still will able to specify it flexibly:  hidespines = (:r, :t)  will remove the top and right borders. f = Figure()\nplot_butterfly!(\n    f[1, 1],\n    data;\n    positions = pos,\n    topo_axis = (; height = Relative(0.4), width = Relative(0.4)),\n    axis = (; title = \"With decorations\"),\n)\nplot_butterfly!(\n    f[2, 1],\n    data;\n    positions = pos,\n    topo_axis = (; height = Relative(0.4), width = Relative(0.4)),\n    axis = (; title = \"Without decorations\"),\n    layout = (; hidedecorations = (:label => true, :ticks => true, :ticklabels => true)),\n)\nf You can also completely remove all spines, decorations, color bars, and even padding. f = Figure(; figure_padding = 0)\nplot_erpimage!(\n    f,\n    dat;\n    layout = (; hidespines = (), hidedecorations = (), use_colorbar = false),\n)"},{"id":368,"pagetitle":"Hide decorations and axis spines","title":"Showing","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/hide_deco/#Showing","content":" Showing Some plots hide features by default. This could be reverted by setting the variables to  nothing data, positions = TopoPlots.example_data()\nplot_topoplot(\n    data[:, 340, 1];\n    positions = positions,\n    layout = (; hidespines = nothing, hidedecorations = nothing),\n) For more information on the input of these functions refer to the  Makie dokumentation on Axis. This page was generated using  Literate.jl ."},{"id":371,"pagetitle":"Change colormap of butterfly plot","title":"Change colormap of Butterfly plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/position2color/#pos2color","content":" Change colormap of Butterfly plot  You want to change the colors of the lines and markers on the inserted topoplot. To do that you need to change the color scheme (aka color map) of the butterfly plot. You can find th elist of colormaps for Makie  here ."},{"id":372,"pagetitle":"Change colormap of butterfly plot","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/position2color/#Setup","content":" Setup using UnfoldMakie\nusing CairoMakie\nusing DataFramesMeta\nusing Colors\n\nresults, positions = UnfoldMakie.example_data(\"TopoPlots.jl\"); By default the plot looks like this: plot_butterfly(results; positions = positions)"},{"id":373,"pagetitle":"Change colormap of butterfly plot","title":"Color schemes","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/position2color/#Color-schemes","content":" Color schemes"},{"id":374,"pagetitle":"Change colormap of butterfly plot","title":"MNE style","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/position2color/#MNE-style","content":" MNE style We can change the color scale by specifying a function that maps from an  (x, y)  tuple to a color.  UnfoldMakie  currently provides three different color scales: pos2colorRGB  (same as MNE-Python), pos2colorHSV  (HSV color space), pos2colorRomaO . While  RGB  &  HSV  have the advantage of being 2D color maps,  Roma0  has the advantage of being perceptually uniform. Also you can specify a uniform color. plot_butterfly(\n    results;\n    positions = positions,\n    topopositions_to_color = pos -> UnfoldMakie.pos_to_color_RGB(pos),\n)"},{"id":375,"pagetitle":"Change colormap of butterfly plot","title":"HSV-Space","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/position2color/#HSV-Space","content":" HSV-Space plot_butterfly(\n    results;\n    positions = positions,\n    topopositions_to_color = UnfoldMakie.pos_to_color_HSV,\n)"},{"id":376,"pagetitle":"Change colormap of butterfly plot","title":"Uniform Color","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/position2color/#Uniform-Color","content":" Uniform Color You can make all lines \"gray\", or any other arbitrary color. Also you can make it a function of electrode position. plot_butterfly(\n    results;\n    positions = positions,\n    topopositions_to_color = x -> Colors.RGB(0.5),\n)"},{"id":377,"pagetitle":"Change colormap of butterfly plot","title":"Transparency","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/position2color/#Transparency","content":" Transparency Unlike RGB, RGBA has a fourth channel, alpha, which is responsible for transparency. Here are two examples of how to manipulate it. f = Figure()\nplot_butterfly!(\n    f[1, 1],\n    results;\n    positions = positions,\n    topopositions_to_color = x -> (RGBA(UnfoldMakie.pos_to_color_RomaO(x), 1)),\n)\n\nplot_butterfly!(\n    f[2, 1],\n    results;\n    positions = positions,\n    topopositions_to_color = x -> (GrayA(UnfoldMakie.pos_to_color_RomaO(x), 0.5)),\n)\nf This page was generated using  Literate.jl ."},{"id":380,"pagetitle":"Convert electrode positions from 3D to 2D","title":"Convert electrode positions form 3D to 2D","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/positions/#Convert-electrode-positions-form-3D-to-2D","content":" Convert electrode positions form 3D to 2D Sometimes you have 3D montage but you need 2D montage. How to convert one to another? The function  to_positions  should help. using UnfoldMakie\nusing CairoMakie\nusing TopoPlots\nusing PyMNE;"},{"id":381,"pagetitle":"Convert electrode positions from 3D to 2D","title":"Get positions from MNE","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/positions/#Get-positions-from-MNE","content":" Get positions from MNE Generate an MNE structure  taken from mne documentation biosemi_montage = PyMNE.channels.make_standard_montage(\"biosemi64\")\nn_channels = length(biosemi_montage.ch_names)\nfake_info =\n    PyMNE.create_info(ch_names = biosemi_montage.ch_names, sfreq = 250.0, ch_types = \"eeg\")\ndata = rand(n_channels, 1) * 1e-6\nfake_evoked = PyMNE.EvokedArray(data, fake_info)\nfake_evoked.set_montage(biosemi_montage)\n\npos = to_positions(fake_evoked) 64-element Vector{Point{2, Float64}}:\n [0.34935274876763384, 0.8914697618166454]\n [0.2285454515991697, 0.8299153694246765]\n [0.3239207434789678, 0.8210416675361911]\n [0.38009721906796695, 0.7346772379558053]\n [0.28116929732806945, 0.7288908776450373]\n [0.19598811803244962, 0.729048111114921]\n [0.13267223773863893, 0.7340421555641459]\n [0.07111784534666996, 0.6132348583956815]\n [0.1381378125628734, 0.6118022611559795]\n [0.2400936018380034, 0.6086174147856195]\n ⋮\n [0.612772564740614, 0.34981504242270145]\n [0.5864401194985318, 0.2239606378043266]\n [0.6853680412384293, 0.2297469981150946]\n [0.7705492205340492, 0.22958976464521094]\n [0.8338651008278599, 0.22459572019598625]\n [0.8710458357539724, 0.19758233504967118]\n [0.7379918869673291, 0.12872250633545543]\n [0.6426165950875308, 0.13759620822394072]\n [0.6171845897988648, 0.06716811394348651]"},{"id":382,"pagetitle":"Convert electrode positions from 3D to 2D","title":"Projecting from 3D montage to 2D","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/positions/#Projecting-from-3D-montage-to-2D","content":" Projecting from 3D montage to 2D pos3d = hcat(values(pyconvert(Dict, biosemi_montage.get_positions()[\"ch_pos\"]))...)\n\npos2 = to_positions(pos3d)\n\nf = Figure(size = (600, 300))\nscatter(f[1, 1], pos3d[1:2, :], axis = (title = \"Dropping third dimension\",))\nscatter(f[1, 2], pos2, axis = (title = \"Projection form 3D to 2D\",))\nf As you can see, the \"naive\" transformation of simply dropping the third dimension does not really work (left). Instead, we have to project the channels onto a sphere and unfold it (right). This page was generated using  Literate.jl ."},{"id":385,"pagetitle":"Visualize uncertainty in topoplot series","title":"Visualize uncertainty in topoplot series","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/uncertain_topo/#Visualize-uncertainty-in-topoplot-series","content":" Visualize uncertainty in topoplot series Click to expand using Base: channeled_tasks\nusing Unfold\nusing UnfoldMakie\nusing UnfoldSim\nusing DataFrames\nusing CairoMakie\nusing TopoPlots\nusing Statistics\nusing Random\nusing Animations Representing uncertainty is one of the most difficult tasks in visualization. It is especially difficult for heatmaps and topoplots. Here we will present new ways to show uncertainty for topoplots series. Uncertainty in EEG data usually comes from subjects and trials: Subjects can vary in phisological or behavioral characteristics; Something can change between trials (electrode connection can get worse, etc.)."},{"id":386,"pagetitle":"Visualize uncertainty in topoplot series","title":"Data input","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/uncertain_topo/#Data-input","content":" Data input dat, positions = TopoPlots.example_data()\ndf = UnfoldMakie.eeg_array_to_dataframe(dat[:, :, 1], string.(1:length(positions)));\ndf_uncert = UnfoldMakie.eeg_array_to_dataframe(dat[:, :, 2], string.(1:length(positions))); Generate data with 227 channels, 50 trials, 500 mseconds for bootstrapping noiselevel is important for adding variability it your data df_toposeries, pos_toposeries =\n    UnfoldMakie.example_data(\"bootstrap_toposeries\"; noiselevel = 7);\ndf_toposeries = df_toposeries[df_toposeries.trial .<= 15, :];\nrng = MersenneTwister(1); Please cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce"},{"id":387,"pagetitle":"Visualize uncertainty in topoplot series","title":"Uncertainty via additional row","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/uncertain_topo/#Uncertainty-via-additional-row","content":" Uncertainty via additional row In this case we alread have two datasets:  df  with mean estimates and  df_uncert  with variability estimation. f = Figure()\nplot_topoplotseries!(\n    f[1, 1],\n    df;\n    bin_num = 5,\n    positions = positions,\n    axis = (; xlabel = \"\"),\n    colorbar = (; label = \"Voltage estimate\"),\n)\nplot_topoplotseries!(\n    f[2, 1],\n    df_uncert;\n    bin_num = 5,\n    positions = positions,\n    visual = (; colormap = :viridis),\n    colorbar = (; label = \"Voltage uncertainty\"),\n)\nf"},{"id":388,"pagetitle":"Visualize uncertainty in topoplot series","title":"Markers for uncertainty","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/uncertain_topo/#Markers-for-uncertainty","content":" Markers for uncertainty In this case we will use the marker size to show the uncertainty of the estimate. df_uncert_chan = groupby(df_uncert[df_uncert.time.==50, :], [:channel])\ndf_uncert_chan = combine(df_uncert_chan, :estimate => mean => :estimate)\nplot_topoplot(\n    dat[:, 50, 1];\n    positions,\n    axis = (; xlabel = \"50 ms\"),\n    topo_attributes = (;\n        label_scatter = (;\n            markersize = df_uncert.estimate * 300,\n            marker = :circle,\n            color = :white,\n            strokecolor = :tomato,\n        )\n    ),\n)"},{"id":389,"pagetitle":"Visualize uncertainty in topoplot series","title":"Uncertainty via animation","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/uncertain_topo/#Uncertainty-via-animation","content":" Uncertainty via animation In this case, we need to boostrap the data, so we'll use raw data with single trials. To show the uncertainty of the estimate, we will compute 10 different means of the boostrapped data. More specifically: 1) create N boostrapped data sets using random sampling with replacement across trials; 2) compute their means; 3) do a toposeries animation iterating over these means. Click to expand for supportive functions With this function we will bootstrap the data.  rng  - random number generated. Be sure to send the same rng from outside the function. bootstrap_toposeries(df; kwargs...) = bootstrap_toposeries(MersenneTwister(), df; kwargs...)\nfunction bootstrap_toposeries(rng::AbstractRNG, df)\n    df1 = groupby(df, [:time, :channel])\n    len_estimate = length(df1[1].estimate)\n    bootstrap_ix = rand(rng, 1:len_estimate, len_estimate) # random sample with replacement\n    tmp = vcat([d.estimate[bootstrap_ix] for d in df1]...)\n    df1 = DataFrame(df1)\n\n    df1.estimate .= tmp\n    return df1\nend bootstrap_toposeries (generic function with 2 methods) function for easing - smooth transition between frames in animation.  update_ratio  - transition ratio between time1 and time2.  at  - create animation object: 0 and 1 are time points, old and new are data vectors. function ease_between(old, new, update_ratio; easing_function = sineio())\n    anim = Animation(0, old, 1, new; defaulteasing = easing_function)\n    return at(anim, update_ratio)\nend ease_between (generic function with 1 method) dat_obs = Observable(df_toposeries)\nf = Figure()\nplot_topoplotseries!(\n    f[1, 1],\n    dat_obs;\n    bin_num = 5,\n    nrows = 2,\n    positions = pos_toposeries,\n    axis = (; xlabel = \"Time [msec]\"),\n) GridPosition(GridLayout[1, 1] (1 children), GridLayoutBase.Span(1:1, 1:1), GridLayoutBase.Inner()) Basic toposeries record(f, \"bootstrap_toposeries.mp4\"; framerate = 2) do io\n    for i = 1:10\n        dat_obs[] = bootstrap_toposeries(rng, df_toposeries)\n        recordframe!(io)\n    end\nend; Toposeries without contour dat_obs = Observable(df_toposeries)\nf = Figure()\nplot_topoplotseries!(\n    f[1, 1],\n    dat_obs;\n    bin_num = 5,\n    nrows = 2,\n    positions = pos_toposeries,\n    visual = (; contours = false),\n    axis = (; xlabel = \"Time [msec]\"),\n)\nrecord(f, \"bootstrap_toposeries_nocontours.mp4\"; framerate = 2) do io\n    for i = 1:10\n        dat_obs[] = bootstrap_toposeries(rng, df_toposeries)\n        recordframe!(io)\n    end\nend; Toposeries with easing (smooth transition between frames) dat_obs = Observable(bootstrap_toposeries(rng, df_toposeries))\nf = Figure()\nplot_topoplotseries!(\n    f[1, 1],\n    dat_obs;\n    bin_num = 5,\n    nrows = 2,\n    positions = pos_toposeries,\n    visual = (; contours = false),\n    axis = (; xlabel = \"Time [msec]\"),\n)\nrecord(f, \"bootstrap_toposeries_easing.mp4\"; framerate = 10) do io\n    for n_bootstrapping = 1:10\n        recordframe!(io)\n        new_df = bootstrap_toposeries(rng, df_toposeries)\n        old_estimate = deepcopy(dat_obs.val.estimate)\n        for update_ratio in range(0, 1, length = 8)\n\n            dat_obs.val.estimate .=\n                ease_between(old_estimate, new_df.estimate, update_ratio)\n            notify(dat_obs)\n            recordframe!(io)\n        end\n    end\nend;"},{"id":390,"pagetitle":"Visualize uncertainty in topoplot series","title":"Static version of animation","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/how_to/uncertain_topo/#Static-version-of-animation","content":" Static version of animation function draw_topoplots(rng, df_toposeries)\n    fig = Figure(size = (800, 600))\n\n    merged_df = DataFrame()\n    for i = 1:2, j = 1:3\n        boo = bootstrap_toposeries(rng, df_toposeries)\n        boo.condition .= string((i - 1) * 3 + j) # Assign condition number\n        merged_df = vcat(merged_df, boo)\n\n    end\n    plot_topoplotseries!(\n        fig,\n        merged_df;\n        nrows = 2,\n        mapping = (; col = :condition),\n        axis = (; titlesize = 20, title = \"Bootstrapped means\", xlabel = \"\"),\n        positions = pos_toposeries,\n    )\n    fig\nend\n\ndraw_topoplots(rng, df_toposeries) This page was generated using  Literate.jl ."},{"id":393,"pagetitle":"Butterfly plot","title":"Butterfly Plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/butterfly/#bfp_vis","content":" Butterfly Plot Butterfly plot  is a plot type for visualisation of Event-related potentials. It can fully represent time and channels dimensions using lines. With addition of topoplot inset it can also represent location of channels. It called \"butterfly\" because the envelope of channels reminds butterfly wings🦋. The configurations of  ERP plots  and Butterfly plots are somehow similar."},{"id":394,"pagetitle":"Butterfly plot","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/butterfly/#Setup","content":" Setup Package loading The following modules are necessary for run this tutorial: using UnfoldMakie\nusing Unfold\nusing CairoMakie\nusing DataFrames\nusing Colors Note that  DataFramesMeta  is also used here in order to be able to use  @subset  for testing (filtering). Data We filter the data to make it more clearly represented: df, pos = UnfoldMakie.example_data(\"TopoPlots.jl\")\nfirst(df, 3) 3×7 DataFrame Row estimate time channel coefname topo_positions se pval Float64 Float64 Int64 String Any Float64 Float64 1 0.020321 -0.3 1 A (0.493714, 0.544031) 0.122875 0.266091 2 0.017548 -0.298 1 A (0.493714, 0.544031) 0.124345 0.29664 3 0.0150747 -0.296 1 A (0.493714, 0.544031) 0.124828 0.323592"},{"id":395,"pagetitle":"Butterfly plot","title":"Plot Butterfly Plots","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/butterfly/#Plot-Butterfly-Plots","content":" Plot Butterfly Plots The default butterfly plot: plot_butterfly(df, axis = (; xlabel = \"Time [s]\")) The butterfly plot with corresponding topoplot. You need to provide the channel positions. plot_butterfly(df; positions = pos, axis = (; xlabel = \"Time [s]\")) You want to change size of topoplot markers and size of topoplot: plot_butterfly(\n    df;\n    positions = pos,\n    topo_attributes = (; label_scatter = (; markersize = 30)),\n    topo_axis = (; height = Relative(0.4), width = Relative(0.4)),\n    axis = (; xlabel = \"Time [s]\"),\n) You want to add vline and hline: f = Figure()\nplot_butterfly!(f, df; positions = pos, axis = (; xlabel = \"Time [s]\"))\nhlines!(0, color = :gray, linewidth = 1)\nvlines!(0, color = :gray, linewidth = 1)\nf You want to remove all decorations: plot_butterfly(\n    df;\n    positions = pos,\n    axis = (; xlabel = \"Time [s]\"),\n    layout = (; hidedecorations = (:label => true, :ticks => true, :ticklabels => true)),\n)"},{"id":396,"pagetitle":"Butterfly plot","title":"Changing the colors of channels","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/butterfly/#Changing-the-colors-of-channels","content":" Changing the colors of channels Please check  this page . You want to highlight a specific channel or channels. Specify channels first: df.highlight1 = in.(df.channel, Ref([12])) # for single channel\ndf.highlight2 = in.(df.channel, Ref([10, 12])) # for multiple channels Second, you can highlight it or them by color. gray = Colors.RGB(128 / 255, 128 / 255, 128 / 255)\nf = Figure(size = (1000, 400))\nplot_butterfly!(\n    f[1, 1],\n    df;\n    positions = pos,\n    mapping = (; color = :highlight1),\n    visual = (; color = 1:2, colormap = [gray, :red]),\n    axis = (; xlabel = \"Time [s]\"),\n)\nplot_butterfly!(\n    f[1, 2],\n    df;\n    positions = pos,\n    mapping = (; color = :highlight2),\n    visual = (; color = 1:2, colormap = [gray, :red]),\n    axis = (; xlabel = \"Time [s]\"),\n)\nf Or by faceting: df.highlight2 = replace(df.highlight2, true => \"channels 10, 12\", false => \"all channels\")\n\nplot_butterfly(\n    df;\n    positions = pos,\n    mapping = (; color = :highlight2, col = :highlight2),\n    visual = (; color = 1:2, colormap = [gray, :red]),\n    axis = (; xlabel = \"Time [s]\"),\n)"},{"id":397,"pagetitle":"Butterfly plot","title":"Column Mappings","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/butterfly/#Column-Mappings","content":" Column Mappings Since butterfly plots use a  DataFrame  as input, the library needs to know the names of the columns used for plotting. You can set these mapping values by calling  plot_butterfly(...; mapping=(; :x=:time)) . Just specify a  NamedTuple . Note the  ;  right after the opening parentheses."},{"id":398,"pagetitle":"Butterfly plot","title":"Configurations of Butterfly Plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/butterfly/#Configurations-of-Butterfly-Plot","content":" Configurations of Butterfly Plot"},{"id":399,"pagetitle":"Butterfly plot","title":"UnfoldMakie.plot_butterfly","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/butterfly/#UnfoldMakie.plot_butterfly","content":" UnfoldMakie.plot_butterfly  —  Function plot_butterfly(plot_data::Union{DataFrame, AbstractMatrix}; kwargs...)\nplot_butterfly(times::Vector, plot_data::Union{DataFrame, AbstractMatrix}; kwargs...)\nplot_butterfly!(f::Union{GridPosition, GridLayout, Figure}, plot_data::Union{DataFrame, AbstractMatrix}; kwargs...) Plot a Butterfly plot. Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{DataFrame, AbstractMatrix}   Data for the ERP plot visualization. kwargs...   Additional styling behavior.    Often used as:  plot_butterfly(df; visual = (; colormap = :romaO)) . Keyword arguments (kwargs) positions::Array = []   Adds a topoplot as an inset legend to the provided channel positions. Must be the same length as  plot_data .     To change the colors of the channel lines use the  topoposition_to_color  function. topolegend::Bool = true   Show an inlay topoplot with corresponding electrodes. Requires  positions . topopositions_to_color::x -> pos_to_color_RomaO(x)   Change the line colors. topo_axis::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot axis.   To see all options just type  ?Axis  in REPL.   Defaults: (width = Relative(0.35f0), height = Relative(0.35f0), halign = 0.05, valign = 0.95, aspect = 1) topo_attributes::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot interoplation.   To see all options just type  ?Topoplot.topoplot  in REPL.   Defaults: (head = (color = :black, linewidth = 1), label_scatter = (markersize = 10, strokewidth = 0.5), interpolation = TopoPlots.NullInterpolator()) mapping = (;)   For highlighting specific channels.   Example:  mapping = (; color = :highlight)) , where  :highlight  is variable with appopriate mapping. Return Value: Figure  displaying Butterfly plot. Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", ylabel = \"Voltage [µV]\", yticklabelsize = 14, xtickformat = \"{:.1f}\") -  use  kwargs...  of   Makie.Axis layout =  (show_legend = false, use_colorbar = true, use_legend = true, hidespines = (:r, :t), hidedecorations = Dict{Symbol, Bool}(:label => 0, :ticks => 0, :ticklabels => 0)) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y), color = (:channel, :channels, :trial, :trials), positions = (:pos, :positions, :position, :topo_positions, :x, nothing), labels = (:labels, :label, :topoLabels, :sensor, nothing), group = (:channel,)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = nothing, color = nothing) -  use  kwargs...  of  Makie.lines legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center, framevisible = false) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, label = \"\", flipaxis = true) -  use  kwargs...  of   AlgebraOfGraphics.colorbar! see also  plot_erp source This page was generated using  Literate.jl ."},{"id":402,"pagetitle":"Channel image","title":"Channel image","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/channel_image/#Channel-image","content":" Channel image Channel image  is a plot type for visualizing EEG activity for all channels. It can fully represent time and channel dimensions using a heatmap. Y-axis represents all channels, x-axis represents time, while color represents voltage."},{"id":403,"pagetitle":"Channel image","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/channel_image/#Setup","content":" Setup Package loading using Unfold\nusing UnfoldMakie\nusing CairoMakie\nusing UnfoldSim\nusing TopoPlots"},{"id":404,"pagetitle":"Channel image","title":"Plot Channel image","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/channel_image/#Plot-Channel-image","content":" Plot Channel image The following code will result in the default configuration. dat, pos = TopoPlots.example_data()\ndat = dat[:, :, 1]\npos = pos[1:30]\nchannels_30 = UnfoldMakie.example_montage(\"channels_30\");\n\n\nplot_channelimage(dat[1:30, :], pos, channels_30; axis = (; xlabel = \"Time [s]\"))"},{"id":405,"pagetitle":"Channel image","title":"Configurations for Channel image","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/channel_image/#Configurations-for-Channel-image","content":" Configurations for Channel image"},{"id":406,"pagetitle":"Channel image","title":"UnfoldMakie.plot_channelimage","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/channel_image/#UnfoldMakie.plot_channelimage","content":" UnfoldMakie.plot_channelimage  —  Function plot_channelimage!(f::Union{GridPosition, GridLayout, Figure}, data::Union{DataFrame,AbstractMatrix}, positions::Vector{Point{2,Float32}}, ch_names::Vector{String}; kwargs...)\nplot_channelimage(data::Union{DataFrame, AbstractMatrix}, positions::Vector{Point{2,Float32}}, ch_names::Vector{String}; kwargs...) Plot a Channel image Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{DataFrame, AbstractMatrix}   DataFrame or Matrix with data.   Data should has a format of 1 row - 1 channel.  positions::Vector{Point{2,Float32}}   A vector with EEG layout coordinates. ch_names::Vector{String}   Vector with channel names. times::Vector = range(-0.3, 1.2, length = size(data, 2))   Time range on x-axis. sorting_variables::Vector = [:y, :x]   Method to sort channels on y-axis.   For instance, you can sort by channel positions on the scalp (x, y) or channel name.  sorting_reverse::Vector = [:false, :false]  Should sorting variables be reversed or not? Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", ylabel = \"Channels\", yticklabelsize = 14) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = Makie.Reverse{String}(\"RdBu\"),) -  use  kwargs...  of  Makie.heatmap legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, label = \"Voltage [µV]\") -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Channel image. source This page was generated using  Literate.jl ."},{"id":409,"pagetitle":"Circular topoplots","title":"Circular Topoplots","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/circ_topo/#Circular-Topoplots","content":" Circular Topoplots Circular topoplot series  is a plot type for visualizing EEG activity in relation to some continous variable arranged on a circluar line. It can fully represent channel and channel location dimensions using contour lines. It can also partially represent the varaible dimension. Variable could be for instance saccadic amplitude or degrees of visual angle. Basically, it is a series of Topoplots arranged on a circle."},{"id":410,"pagetitle":"Circular topoplots","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/circ_topo/#Setup","content":" Setup Package loading using UnfoldMakie\nusing CairoMakie\nusing TopoPlots # for example data\nusing Random\nusing DataFrames Data generation  Generate a  Dataframe . We need to specify the Topoplot positions either via  position , or via  labels . data, pos = TopoPlots.example_data();\ndat = data[:, 240, 1]\ndf = DataFrame(\n    :estimate => eachcol(Float64.(data[:, 100:40:300, 1])),\n    :circular_variable => [0, 50, 80, 120, 180, 210],\n    :time => 100:40:300,\n)\ndf = flatten(df, :estimate);"},{"id":411,"pagetitle":"Circular topoplots","title":"Plot generations","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/circ_topo/#Plot-generations","content":" Plot generations Note how the plots are located at the angles of the  circular_variable . plot_circular_topoplots(\n    df;\n    positions = pos,\n    center_label = \"Relative angle [°]\",\n    predictor = :circular_variable,\n) If the bounding variable is not between 0 and 360, since we are using time, we must specify it. plot_circular_topoplots(\n    df;\n    positions = pos,\n    center_label = \"Time [s]\",\n    predictor = :time,\n    predictor_bounds = [80, 320],\n    colorbar = (; height = 350),\n)"},{"id":412,"pagetitle":"Circular topoplots","title":"Configurations of Circular Topoplots","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/circ_topo/#Configurations-of-Circular-Topoplots","content":" Configurations of Circular Topoplots"},{"id":413,"pagetitle":"Circular topoplots","title":"UnfoldMakie.plot_circular_topoplots","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/circ_topo/#UnfoldMakie.plot_circular_topoplots","content":" UnfoldMakie.plot_circular_topoplots  —  Function plot_circular_topoplots!(f, data::DataFrame; kwargs...) using ColorSchemes: topo using ColorSchemes: topo using ColorSchemes: topo     plot circular topoplots(data::DataFrame; kwargs...) Plot a circular EEG topoplot. Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::DataFrame   DataFrame with data keys (columns  :y, :yhat, :estimate ), and :position (columns  :pos, :position, :positions ). Keyword arguments (kwargs) predictor::Vector{Any} = :predictor   The circular predictor value, defines position of topoplot across the circle.   Mapped around  predictor_bounds . predictor_bounds::Vector{Int64} = [0, 360]   The bounds of the predictor. Relevant for the axis labels. positions::Vector{Point{2, Float32}} = nothing   Positions of the  plot_topoplot . center_label::String = \"\"   The text in the center of the cricle. plot_radius::String = 0.8   The radius of the circular topoplot series plot calucalted by formula:  radius = (minwidth * plot_radius) / 2 . labels::Vector{String} = nothing   Labels for the  plot_topoplots . topo_axis::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot axis.   To see all options just type  ?Axis  in REPL.   Defaults: (width = Relative(0.2f0), height = Relative(0.2f0), aspect = 1) topo_attributes::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot interoplation.   To see all options just type  ?Topoplot.topoplot  in REPL.   Defaults: interp_resolution = (128, 128), interpolation = CloughTocher() Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", aspect = 1) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = false, use_colorbar = true, hidespines = (), hidedecorations = Dict{Symbol, Bool}(:label => 0)) -  check this  page mapping =  (x = nothing, y = (:estimate, :yhat, :y), positions = (:pos, :positions, :position, nothing), labels = (:labels, :label, :sensor, nothing)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = Makie.Reverse{Symbol}(:RdBu), contours = (color = :white, linewidth = 2), enlarge = 1, label_scatter = true, label_text = false, bounding_geometry = GeometryBasics.Circle) -  use  kwargs...  of  Topoplot.eeg_topoplot legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, flipaxis = true, label = \"Voltage [µV]\", colormap = Makie.Reverse{Symbol}(:RdBu)) -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Circular topoplot series. source This page was generated using  Literate.jl ."},{"id":416,"pagetitle":"Design matrix","title":"Design matrix","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/designmatrix/#Design-matrix","content":" Design matrix Design matrix plot  is a visualization type used to inspect the structure of predictors in EEG regression analysis. It fully represents the  trials  and  predictors  dimensions using a colored grid (heatmap). Each row corresponds to a trial, and each column to a predictor, with color intensity reflecting the predictor’s value. Unlike ERP or butterfly plots that focus on time and channel dimensions, the design matrix plot focuses on the underlying experimental design. It gives a compact, at-a-glance overview of how predictors vary across trials 🧩. Options like  sort_data  and  standardize_data  enhance interpretability by reorganizing trials or normalizing predictor scales. This type of plot is essential for checking data integrity before model fitting."},{"id":417,"pagetitle":"Design matrix","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/designmatrix/#Setup","content":" Setup Package loading using Unfold\nusing UnfoldMakie\nusing DataFrames\nusing CairoMakie Data uf = UnfoldMakie.example_data(\"UnfoldLinearModel\");"},{"id":418,"pagetitle":"Design matrix","title":"Plot Design Matrices","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/designmatrix/#Plot-Design-Matrices","content":" Plot Design Matrices The following code will result in the default configuration. plot_designmatrix(designmatrix(uf)) To make the design matrix easier to read, you may want to sort it using  sort_data . plot_designmatrix(designmatrix(uf); sort_data = true)"},{"id":419,"pagetitle":"Design matrix","title":"Configurations for Design matrix plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/designmatrix/#Configurations-for-Design-matrix-plot","content":" Configurations for Design matrix plot"},{"id":420,"pagetitle":"Design matrix","title":"UnfoldMakie.plot_designmatrix","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/designmatrix/#UnfoldMakie.plot_designmatrix","content":" UnfoldMakie.plot_designmatrix  —  Function plot_designmatrix!(f::Union{GridPosition, GridLayout, Figure}, data::Unfold.DesignMatrix; kwargs...)\nplot_designmatrix(data::Unfold.DesignMatrix; kwargs...) Plot a designmatrix.  Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Unfold.DesignMatrix   Data for the plot visualization. Keyword arguments (kwargs) standardize_data::Bool = false   Indicates whether the data is standardized by pointwise division of the data with its sampled standard deviation. sort_data::Bool = false   Indicates whether the data is sorted. It uses  sortslices()  of Base Julia.  xticks::Num = nothing   Specifies the number of labels displayed on the x-axis. xticks = 0 : No labels are displayed. xticks = 1 : Only the first label is displayed. xticks = 2 : The first and last labels are displayed. 2 < xticks < number of labels : The labels are evenly distributed across the axis. xticks ≥ number of labels : All labels are displayed. Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Conditions\", ylabel = \"Trials\", xticklabelrotation = 0.39) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = :roma,) -  use  kwargs...  of  Makie.heatmap legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, flipaxis = true, label = \"\") -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Design matrix.  source This page was generated using  Literate.jl ."},{"id":423,"pagetitle":"ERP plot","title":"ERP plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp/#erp_vis","content":" ERP plot ERP plot  is plot type for visualisation of  Event-related potentials . It can fully represent time and experimental condition dimensions using lines."},{"id":424,"pagetitle":"ERP plot","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp/#Setup","content":" Setup Package loading using Unfold\nusing UnfoldMakie\nusing DataFrames\nusing CairoMakie\nusing DataFramesMeta\nusing UnfoldSim\nusing UnfoldMakie Data generation Let's generate some data. We'll fit a model with a 2 level categorical predictor and a continuous predictor with interaction. data, evts = UnfoldSim.predef_eeg(; noiselevel = 12, return_epoched = true)\ndata = reshape(data, (1, size(data)...))\nf = @formula 0 ~ 1 + condition + continuous\nse_solver = (x, y) -> Unfold.solver_default(x, y, stderror = true);\n\nm = fit(\n    UnfoldModel,\n    Dict(Any => (f, range(0, step = 1 / 100, length = size(data, 2)))),\n    evts,\n    data,\n    solver = se_solver,\n);\nresults = coeftable(m)\nres_effects = effects(Dict(:continuous => -5:0.5:5), m); ┌ Warning: using `Dict(:A=>(@formula,times/basisfunction))` is deprecated, please use `[:A=>(@formula,times/basisfunction)]` from now on\n└ @ Unfold ~/.julia/packages/Unfold/h22LS/src/fit.jl:74"},{"id":425,"pagetitle":"ERP plot","title":"Figure plotting","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp/#Figure-plotting","content":" Figure plotting This is default figure: plot_erp(results) To change legend title use  mapping.color : plot_erp(\n    results,\n    mapping = (; color = :coefname => \"Conditions\"),\n    axis = (; xlabel = \"Time [s]\"),\n)"},{"id":426,"pagetitle":"ERP plot","title":"Additional features","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp/#Additional-features","content":" Additional features"},{"id":427,"pagetitle":"ERP plot","title":"Effect plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp/#Effect-plot","content":" Effect plot Effect plot shows how ERP voltage is affected by variation of some variable (here:  :contionous ). plot_erp(\n    res_effects;\n    mapping = (; y = :yhat, color = :continuous, group = :continuous),\n    layout = (; use_colorbar = false),\n    axis = (; xlabel = \"Time [s]\"),\n)"},{"id":428,"pagetitle":"ERP plot","title":"Significance lines","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp/#Significance-lines","content":" Significance lines significance::Array = []  - show a significance (see below). Here we manually specify p-value lines. If array is not empty, plot shows colored lines under the plot representing the p-values. Below is an example in which p-values are given: m = UnfoldMakie.example_data(\"UnfoldLinearModel\")\nresults = coeftable(m)\nsignificancevalues = DataFrame(\n    from = [0.01, 0.2],\n    to = [0.3, 0.4],\n    coefname = [\"(Intercept)\", \"condition: face\"], # if coefname not specified, line should be black\n)\nplot_erp(\n    results;\n    :significance => significancevalues,\n    mapping = (; color = :coefname => \"Conditions\"),\n    axis = (; xlabel = \"Time [s]\"),\n)"},{"id":429,"pagetitle":"ERP plot","title":"Error ribbons","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp/#Error-ribbons","content":" Error ribbons stderror ::bool =  false  - add an error ribbon, with lower and upper limits based on the  :stderror  column. Display a colored band on the graph to indicate lower and higher estimates based on the standard error. For the generalizability of your results, it is always better to include error bands. f = Figure()\nresults.coefname =\n    replace(results.coefname, \"condition: face\" => \"face\", \"(Intercept)\" => \"car\")\nresults = filter(row -> row.coefname != \"continuous\", results)\nplot_erp!(\n    f[1, 1],\n    results;\n    axis = (title = \"Bad example\", titlegap = 12, xlabel = \"\"),\n    :stderror => false,\n    mapping = (; color = :coefname => \"Conditions\"),\n)\n\nplot_erp!(\n    f[2, 1],\n    results;\n    axis = (title = \"Good example\", titlegap = 12, xlabel = \"Time [s]\"),\n    :stderror => true,\n    mapping = (; color = :coefname => \"Conditions\"),\n)\n\nax = Axis(f[2, 1], width = Relative(1), height = Relative(1))\nxlims!(ax, [-0.04, 1])\nylims!(ax, [-0.04, 1])\nhidespines!(ax)\nhidedecorations!(ax)\ntext!(0.98, 0.2, text = \"* Confidence\\nintervals\", align = (:right, :top))\nf There are two ways to implement it. First is using  :stderror = true  after  ; . results.se_low = results.estimate .- 0.5\nresults.se_high = results.estimate .+ 0.15\nplot_erp(\n    select(results, Not(:stderror));\n    stderror = true,\n    mapping = (; color = :coefname => \"Conditions\"),\n    axis = (; xlabel = \"Time [s]\"),\n) Second way is to specify manually lower and higher borders of the error bands. Note :stderror  has precedence over  :se_low / :se_high ."},{"id":430,"pagetitle":"ERP plot","title":"Faceting","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp/#Faceting","content":" Faceting Creation of column facets for each channel. m7 = UnfoldMakie.example_data(\"7channels\")\nresults7 = coeftable(m7)\nplot_erp(\n    results7,\n    mapping = (; col = :channel, group = :channel, color = :coefname => \"Conditions\"),\n    axis = (; xlabel = \"Time [s]\"),\n)"},{"id":431,"pagetitle":"ERP plot","title":"Configurations of ERP plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp/#Configurations-of-ERP-plot","content":" Configurations of ERP plot"},{"id":432,"pagetitle":"ERP plot","title":"UnfoldMakie.plot_erp","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp/#UnfoldMakie.plot_erp","content":" UnfoldMakie.plot_erp  —  Function plot_erp!(f::Union{GridPosition, GridLayout, Figure}, plot_data::Union{DataFrame, AbstractMatrix, AbstractVector{<:Number}}; kwargs...)\nplot_erp(times, plot_data::Union{DataFrame, AbstractMatrix, AbstractVector{<:Number}}; kwargs...) Plot an ERP plot.    Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{Union{DataFrame, AbstractMatrix, AbstractVector{<:Number}, Vector{Float32}}   Data for the ERP plot visualization. kwargs...   Additional styling behavior.    Often used as:  plot_erp(df; mapping = (; color = :coefname, col = :conditionA)) . Keyword arguments (kwargs) stderror::Bool = false   Add an error ribbon, with lower and upper limits based on the  :stderror  column. significance::DataFrame = nothing   Show significant time periods as horizontal bars.   Example:  DataFrame(from = [0.1, 0.3], to = [0.5, 0.7], coefname = [\"(Intercept)\", \"condition: face\"]) .   If  coefname  is not specified, the significance lines will be black. layout.use_colorbar = true   Enable or disable colorbar. layout.use_legend = true   Enable or disable legend. layout.show_legend = true   Enable or disable legend and colorbar. mapping = (;)   Specify  color ,  col  (column),  linestyle ,  group .   F.i.  mapping = (; col = :group)  will make a column for each group. visual = (; color = Makie.wong_colors, colormap = :roma)   For categorical color use  visual.color , for continuous -  visual.colormap . Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", ylabel = \"Voltage [µV]\", yticklabelsize = 14, xtickformat = \"{:.1f}\") -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true, use_legend = true, hidespines = (:r, :t), hidedecorations = Dict{Symbol, Bool}(:grid => 1, :label => 0, :ticks => 0, :ticklabels => 0)) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y), color = (:color, :coefname, nothing)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = :roma, color = ColorTypes.RGBA{Float32}[RGBA(0.0, 0.44705883, 0.69803923, 1.0), RGBA(0.9019608, 0.62352943, 0.0, 1.0), RGBA(0.0, 0.61960787, 0.4509804, 1.0), RGBA(0.8, 0.4745098, 0.654902, 1.0), RGBA(0.3372549, 0.7058824, 0.9137255, 1.0), RGBA(0.8352941, 0.36862746, 0.0, 1.0), RGBA(0.9411765, 0.89411765, 0.25882354, 1.0)]) -  use  kwargs...  of  Makie.lines legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center, framevisible = false) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, label = \"\", flipaxis = true) -  use  kwargs...  of   AlgebraOfGraphics.colorbar! Return Value: Figure  displaying the ERP plot. source This page was generated using  Literate.jl ."},{"id":435,"pagetitle":"ERP grid","title":"ERP grid","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp_grid/#ERP-grid","content":" ERP grid ERP grid  is a plot type for visualisation of Event-related potentials. It can fully represent time, channel, and layout (channel locations) dimensions using lines. It can also partially represent condition dimensions. Lines are displayed on a grid. The location of each axis represents the location of the electrode. This plot type is not as popular because it is too cluttered."},{"id":436,"pagetitle":"ERP grid","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp_grid/#Setup","content":" Setup Package loading using Unfold\nusing UnfoldMakie\nusing CairoMakie\nusing UnfoldSim\nusing TopoPlots Data data, pos = TopoPlots.example_data()\ndata = data[:, :, 1]\nchannels_32, positions_32 = UnfoldMakie.example_montage(\"montage_32\")\nchannels_64, positions_64 = UnfoldMakie.example_montage(\"montage_64\") ([\"Fp1\", \"Fp2\", \"F7\", \"F3\", \"Fz\", \"F4\", \"F8\", \"FC5\", \"FC1\", \"FC2\"  …  \"PO3\", \"PO4\", \"PO8\", \"I1\", \"Iz\", \"I2\", \"FT9\", \"FT10\", \"TP9\", \"TP10\"], Point{2, Float32}[[-0.5, 1.0], [0.5, 1.0], [-0.9, 0.8], [-0.3, 0.8], [0.3, 0.8], [0.9, 0.8], [-1.0, 0.6], [-0.5, 0.6], [-0.2, 0.6], [0.2, 0.6]  …  [0.9, -0.4], [-0.5, -0.6], [0.0, -0.6], [0.5, -0.6], [-0.8, -0.8], [0.8, -0.8], [-0.7, 0.9], [0.7, 0.9], [-0.6, -0.9], [0.6, -0.9]])"},{"id":437,"pagetitle":"ERP grid","title":"Plot ERP grid","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp_grid/#Plot-ERP-grid","content":" Plot ERP grid plot_erpgrid(\n    data,\n    pos;\n    indicator_grid_axis = (;\n        text_x_kwargs = (; text = \"s\"),\n        text_y_kwargs = (; text = \"µV\"),\n    ),\n)"},{"id":438,"pagetitle":"ERP grid","title":"Adding labels","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp_grid/#Adding-labels","content":" Adding labels By default labels are just numbers. plot_erpgrid(\n    data,\n    pos;\n    drawlabels = true,\n    indicator_grid_axis = (;\n        text_x_kwargs = (; text = \"s\"),\n        text_y_kwargs = (; text = \"µV\"),\n    ),\n) But you can also use predefined vector of channel labels. plot_erpgrid(\n    data,\n    pos,\n    channels_64;\n    drawlabels = true,\n    indicator_grid_axis = (; xlabel = \"s\", ylabel = \"µV\"),\n)"},{"id":439,"pagetitle":"ERP grid","title":"Customizing coordinates","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp_grid/#Customizing-coordinates","content":" Customizing coordinates You can adjust the coordinates of subplots to improve their alignment. One simple method is rounding the coordinates to specific intervals. Example: Rounding the y-coordinate by 3 precision digits. pos_new = [Point2(p[1], round(p[2], digits = 3)) for p in positions_32]\nplot_erpgrid(\n    data[1:32, :],\n    pos_new,\n    channels_32;\n    drawlabels = true,\n    indicator_grid_axis = (;\n        text_x_kwargs = (; text = \"s\"),\n        text_y_kwargs = (; text = \"µV\"),\n    ),\n) To manually adjust the position of a specific subplot, modify its coordinates using  Point()  with arithmetic operations. Example: Shifting the first subplot 0.1 units upward on the y-axis. pos_new[31] = Point(pos_new[31][1] + 0.2, pos_new[31][2]) # P9\nplot_erpgrid(\n    data[1:32, :],\n    pos_new,\n    channels_32;\n    drawlabels = true,\n    indicator_grid_axis = (;\n        text_x_kwargs = (; text = \"s\"),\n        text_y_kwargs = (; text = \"µV\"),\n    ),\n) Hint: If you need to generate simple montage coordinates and channel names check them out  here"},{"id":440,"pagetitle":"ERP grid","title":"Customizing coordinates inidcator","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp_grid/#Customizing-coordinates-inidcator","content":" Customizing coordinates inidcator plot_erpgrid(\n    data,\n    pos;\n    indicator_grid_axis = (;\n        arrows_start = [Point2f(0, 0.95), Point2f(0, 0.95)], # Top-left corner\n        arrows_dir = [Vec2f(0, -0.1), Vec2f(0.1, 0)], # Downward and right\n        text_x_coords = (0.004, 0.996), # Position for the x-axis label (to the left of the x-arrow)\n        text_y_coords = (-0.01, 0.85),  # Position for the y-axis label (above the y-arrow)\n        text_x_kwargs = (; text = \"everything\", color = :red),\n        text_y_kwargs = (; text = \"is possible\", color = :green),\n    ),\n)"},{"id":441,"pagetitle":"ERP grid","title":"Configurations for Channel image","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp_grid/#Configurations-for-Channel-image","content":" Configurations for Channel image"},{"id":442,"pagetitle":"ERP grid","title":"UnfoldMakie.plot_erpgrid","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erp_grid/#UnfoldMakie.plot_erpgrid","content":" UnfoldMakie.plot_erpgrid  —  Function plot_erpgrid(data::Union{Matrix{<:Real}, DataFrame}, positions::Vector; kwargs...)\nplot_erpgrid!(f::Union{GridPosition, GridLayout, Figure}, data::Union{Matrix{<:Real}, DataFrame}, positions::Vector, ch_names::Vector{String}; kwargs...) Plot an ERP image. Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{Matrix{<:Real}, DataFrame}   Data for the plot visualization.   Data should has a format of 1 row - 1 channel.  positions::Vector{Point{2,Float}}   Electrode positions. ch_names::Vector{String}   Vector with channel names. hlines_grid_axis::NamedTuple = (;)   Here you can flexibly change configurations of the hlines on all subaxes.   To see all options just type  ?hlines  in REPL.   Defaults: (color = :gray, linewidth = 0.5) vlines_grid_axis::NamedTuple = (;)   Here you can flexibly change configurations of the vlines on all subaxes.   To see all options just type  ?vlines  in REPL.   Defaults: (color = :gray, linewidth = 0.5, ymin = 0.2, ymax = 0.8) lines_grid_axis::NamedTuple = (;)   Here you can flexibly change configurations of the lines on all subaxes.   To see all options just type  ?lines  in REPL.   Defaults: (color = :deepskyblue3,) labels_grid_axis::NamedTuple = (;)   Here you can flexibly change configurations of the labels on all subaxes.   To see all options just type  ?text  in REPL.   Defaults: (color = :gray, fontsize = 12, align = (:left, :top), space = :relative) indicator_grid_axis::NamedTuple = (;)   Here you can change configurations of inidcator axis.   Defaults: (fontsize = 12, xlim = [-0.04, 1.0], ylim = [-0.04, 1.0], arrows start = Point{2, Float32}[[0.0, 0.0], [0.0, 0.0]], arrows dir = Vec{2, Float32}[[0.0, 0.1], [0.1, 0.0]], arrows kwargs = (arrowsize = 10,), text x coords = (0.02, 0), text x kwargs = (text = \"Time [s]\", align = (:left, :top), fontsize = 12), text y coords = (-0.008, 0.01), text y_kwargs = (text = \"Voltage [µV]\", align = (:left, :baseline), fontsize = 12, rotation = 1.5707963267948966)) subaxes::NamedTuple = (;)   Here you can flexibly change configurations of all subaxes. F.e. make them wider or shorter   To see all options just type  ?Axis  in REPL.   Defaults: (width = Relative(0.1f0), height = Relative(0.1f0)) Keyword arguments (kwargs) drawlabels::Bool = false   Draw channels labels over each waveform.  times::Vector = 1:size(data, 2)   Vector of  size() . Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (width = GridLayoutBase.Relative(1.05f0), height = GridLayoutBase.Relative(1.05f0)) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = :roma,) -  use  kwargs...  of  Makie.lines legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966) -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying ERP grid. source This page was generated using  Literate.jl ."},{"id":445,"pagetitle":"ERP image","title":"ERP image","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erpimage/#ERP-image","content":" ERP image ERP image  is a plot type for visualizing EEG activity for all trials. It can fully represent time and trial dimensions using a heatmap. Y-axis represents all trials, x-axis represents time, while color represents voltage. The ERP image can also be sorted by specific experimental variables, which helps to reveal important correlations."},{"id":446,"pagetitle":"ERP image","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erpimage/#Setup","content":" Setup Package loading using Unfold\nusing UnfoldMakie\nusing CairoMakie\nusing UnfoldSim\nusing Statistics Data input dat, evts = UnfoldSim.predef_eeg(; noiselevel = 10, return_epoched = true) ([7.12373084717791 -14.643167664038257 … 8.770271520309837 4.669510193385215; -0.9585287421702547 -12.68184440485485 … 5.23123205493583 -3.3335410378671755; … ; -2.6268562502899666 -10.051459715119043 … 2.676949521564918 -17.089453402341714; 2.400191991285271 -1.743384615374093 … 10.213367335129892 -11.11547223244284],  2000×3 DataFrame\n  Row │ continuous  condition  latency\n      │  Float64     String     Int64\n──────┼────────────────────────────────\n    1 │   2.77778   car             62\n    2 │  -5.0       face           132\n    3 │  -1.66667   car            196\n    4 │  -5.0       car            249\n    5 │   5.0       car            303\n    6 │  -0.555556  car            366\n    7 │  -2.77778   car            432\n    8 │  -2.77778   face           483\n  ⋮   │     ⋮           ⋮         ⋮\n 1994 │   1.66667   car         119798\n 1995 │   2.77778   car         119856\n 1996 │  -5.0       car         119925\n 1997 │   3.88889   car         119978\n 1998 │  -5.0       face        120030\n 1999 │  -0.555556  face        120096\n 2000 │  -2.77778   car         120154\n                       1985 rows omitted)"},{"id":447,"pagetitle":"ERP image","title":"Plot ERP image","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erpimage/#Plot-ERP-image","content":" Plot ERP image plot_erpimage(dat, axis = (; xlabel = \"Time [s]\"))"},{"id":448,"pagetitle":"ERP image","title":"Sorted ERP image","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erpimage/#Sorted-ERP-image","content":" Sorted ERP image Generate the data and specify the necessary sorting parameter. sortvalues::Vector{Int64} = false    Parameter over which plot will be sorted. Using  sortperm()  of Base Julia.    sortperm()  computes a permutation of the array's indices that puts the array in sorted order. dat_e, evts, times = UnfoldMakie.example_data(\"sort_data\")\ndat_norm = dat_e[:, :] .- mean(dat_e, dims = 2) # normalisation\nplot_erpimage(times, dat_norm; sortvalues = evts.Δlatency, axis = (; xlabel = \"Time [s]\")) To see the effect of sorting and normalization, also check this figure. f = Figure()\nplot_erpimage!(f[1, 1], times, dat_e; axis = (; xlabel = \"\"), colorbar = (; label = \"\"))\nplot_erpimage!(\n    f[2, 1],\n    times,\n    dat_e;\n    sortvalues = evts.Δlatency,\n    axis = (; xlabel = \"Time [s]\"),\n    colorbar = (; label = \"\"),\n)\nplot_erpimage!(f[1, 2], times, dat_norm; axis = (; ylabel = \"\", xlabel = \"\"))\nplot_erpimage!(\n    f[2, 2],\n    times,\n    dat_norm;\n    sortvalues = evts.Δlatency,\n    axis = (; ylabel = \"\", xlabel = \"Time [s]\"),\n)\nf"},{"id":449,"pagetitle":"ERP image","title":"Additional features","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erpimage/#Additional-features","content":" Additional features Since ERP images use a  Matrix  as an input, the library does not need any informations about the mapping. erpblur::Number = 10    Number indicating how much blur is applied to the image.   Gaussian blur of the  ImageFiltering  module is used. meanplot::bool = false    Indicating whether the plot should add a line plot below the ERP image, showing the mean of the data. Example of mean plot plot_erpimage(\n    dat;\n    meanplot = true,\n    colorbar = (; label = \"Voltage [µV]\",),\n    visual = (; colormap = :viridis),\n    meanplot_axis = (; xlabel = \"Time [s]\"),\n) Example of mean plot and plot of sorted values plot_erpimage(\n    times,\n    dat_e;\n    sortvalues = evts.Δlatency,\n    meanplot = true,\n    show_sortval = true,\n    meanplot_axis = (; xlabel = \"Time [s]\"),\n)"},{"id":450,"pagetitle":"ERP image","title":"Configurations for ERP image","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erpimage/#Configurations-for-ERP-image","content":" Configurations for ERP image"},{"id":451,"pagetitle":"ERP image","title":"UnfoldMakie.plot_erpimage","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/erpimage/#UnfoldMakie.plot_erpimage","content":" UnfoldMakie.plot_erpimage  —  Function plot_erpimage!(f::Union{GridPosition, GridLayout, Figure}, data::AbstractMatrix{Float64}; kwargs...)\nplot_erpimage!(f::Union{GridPosition, GridLayout, Figure}, data::Observable{<:AbstractMatrix}; kwargs...)\nplot_erpimage!(f::Union{GridPosition, GridLayout, Figure}, times::Observable{<:AbstractVector}, data::Observable{<:AbstractMatrix{<:Real}}; kwargs...)\n\nplot_erpimage(times::AbstractVector, data::Union{<:Observable{Matrix{<:Real}}, Matrix{<:Real}}; kwargs...)\nplot_erpimage(data::Matrix{Float64}; kwargs...) Plot an ERP image. Arguments: f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{DataFrame, Vector{Float32}}   Data for the plot visualization. Keyword arguments (kwargs) erpblur::Number = 10   Number indicating how much blur is applied to the image.    Gaussian blur of the  ImageFiltering  module is used.   Non-Positive values deactivate the blur. sortvalues::Vector{Int64} = false   Parameter over which plot will be sorted. Using  sortperm()  of Base Julia. sortperm()  computes a permutation of the array's indices that puts the array in sorted order.  sortindex::Vector{Int64} = nothing   Sorting over index values. meanplot::bool = false   Add a line plot below the ERP image, showing the mean of the data. show_sortval::bool = false   Add a plot on the right from ERP image, showing the distribution of the sorting data. sortval_xlabel::String = \"Sorting variable\"   If  show_sortval = true  controls xlabel. axis.ylabel::String = \"Trials\"   If  sortvalues = true  the default text will change to \"Sorted trials\", but it could be changed to any values specified manually. meanplot_axis::NamedTuple = (;)   Here you can flexibly change configurations of meanplot.   To see all options just type  ?Axis  in REPL.   Defaults: (height = 100, xlabel = \"Time\", xlabelpadding = 0, xautolimitmargin = (0, 0)) sortplot_axis::NamedTuple = (;)   Here you can flexibly change configurations of meanplot.   To see all options just type  ?Axis  in REPL.   Defaults: (ylabelvisible = true, yticklabelsvisible = false) Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", ylabel = \"Trials\") -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = Makie.Reverse{String}(\"RdBu\"),) -  use  kwargs...  of  Makie.heatmap legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, label = \"Voltage [µV]\") -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the ERP image.  source This page was generated using  Literate.jl ."},{"id":454,"pagetitle":"Parallel coordinates","title":"Parallel Coordinates","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Parallel-Coordinates","content":" Parallel Coordinates Parallel Coordinates Plot  (PCP) is a plot type used to visualize EEG activity for some channels. It can fully represent condition and channel dimensions using lines. It can also partially represent time and trials. Each vertical axis represents a voltage level for a channel. Each line represents a trial, each colour represents a condition."},{"id":455,"pagetitle":"Parallel coordinates","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Setup","content":" Setup Package loading using Unfold\nusing UnfoldMakie\nusing DataFrames\nusing CairoMakie Data generation r1, positions = UnfoldMakie.example_data();\nr2 = deepcopy(r1)\nr2.coefname .= \"B\" # create a second category\nr2.estimate .+= rand(length(r2.estimate)) * 0.1\nresults_plot = vcat(r1, r2);"},{"id":456,"pagetitle":"Parallel coordinates","title":"Plot PCPs","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Plot-PCPs","content":" Plot PCPs plot_parallelcoordinates(\n    subset(results_plot, :channel => x -> x .<= 5);\n    mapping = (; color = :coefname),\n    ax_labels = [\"FP1\", \"F3\", \"F7\", \"FC3\", \"C3\"],\n    axis = (; ylabel = \"Time [s]\"),\n)"},{"id":457,"pagetitle":"Parallel coordinates","title":"Additional features","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Additional-features","content":" Additional features"},{"id":458,"pagetitle":"Parallel coordinates","title":"Normalization","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Normalization","content":" Normalization On the first image, there is no normalization and the extremes of all axes are the same and equal to the max and min values across all chanells. On the second image, there is a  minmax normalization , so each axis has its own extremes based on the min and max of the data. Typically, parallel plots are normalized per axis. Whether this makes sense for estimating channel x, we do not know. begin\n    f = Figure()\n    plot_parallelcoordinates(\n        f[1, 1],\n        ax_labels = [\"FP1\", \"F3\", \"F7\", \"FC3\", \"C3\", \"T7\", \"CP3\", \"P3\", \"P7\", \"O1\"],\n        subset(results_plot, :channel => x -> x .< 10);\n        mapping = (; color = :coefname),\n        axis = (; ylabel = \"Time [s]\", xlabel = \"\", title = \"normalize = nothing\"),\n    )\n    plot_parallelcoordinates(\n        f[2, 1],\n        ax_labels = [\"FP1\", \"F3\", \"F7\", \"FC3\", \"C3\", \"T7\", \"CP3\", \"P3\", \"P7\", \"O1\"],\n        subset(results_plot, :channel => x -> x .< 10);\n        mapping = (; color = :coefname),\n        normalize = :minmax,\n        axis = (; ylabel = \"Time [s]\", title = \"normalize = :minmax\"),\n    )\n    f\nend"},{"id":459,"pagetitle":"Parallel coordinates","title":"Color schemes","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Color-schemes","content":" Color schemes Use only categorical with high contrast between adjacent colors. More:  change colormap . begin\n    f = Figure()\n    plot_parallelcoordinates(\n        f[1, 1],\n        ax_labels = [\"Fz\", \"Cz\", \"O1\", \"O2\", \"Pz\"],\n        subset(results_plot, :channel => x -> x .<= 5);\n        mapping = (; color = :coefname),\n        visual = (; colormap = :tab10),\n        axis = (; ylabel = \"Time [s]\", xlabel = \"\", title = \"colormap = tab10\"),\n    )\n    plot_parallelcoordinates(\n        f[2, 1],\n        ax_labels = [\"Fz\", \"Cz\", \"O1\", \"O2\", \"Pz\"],\n        subset(results_plot, :channel => x -> x .<= 5);\n        mapping = (; color = :coefname),\n        visual = (; colormap = :Accent_3),\n        axis = (; ylabel = \"Time [s]\", title = \"colormap = Accent_3\"),\n    )\n    f\nend"},{"id":460,"pagetitle":"Parallel coordinates","title":"Labels","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Labels","content":" Labels Use  ax_labels  to specify labels for the axes. plot_parallelcoordinates(\n    subset(results_plot, :channel => x -> x .< 5);\n    visual = (; color = :steelblue1),\n    ax_labels = [\"Fz\", \"Cz\", \"O1\", \"O2\"],\n    axis = (; ylabel = \"Time [s]\"),\n)"},{"id":461,"pagetitle":"Parallel coordinates","title":"Tick labels","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Tick-labels","content":" Tick labels Specify tick labels on axis. There are four different options for the tick labels. begin\n    f = Figure(size = (500, 900))\n    plot_parallelcoordinates(\n        f[1, 1],\n        subset(results_plot, :channel => x -> x .< 5, :time => x -> x .< 0);\n        ax_labels = [\"Fz\", \"Cz\", \"O1\", \"O2\"],\n        ax_ticklabels = :all,\n        normalize = :minmax,\n        visual = (; color = :burlywood1),\n        axis = (;\n            xlabel = \"\",\n            ylabel = \"Time [s]\",\n            ylabelpadding = 40,\n            title = \"ax_ticklabels = :all\",\n        ),\n    ) # show all ticks on all axes\n    plot_parallelcoordinates(\n        f[2, 1],\n        subset(results_plot, :channel => x -> x .< 5, :time => x -> x .< 0);\n        ax_labels = [\"Fz\", \"Cz\", \"O1\", \"O2\"],\n        ax_ticklabels = :left,\n        normalize = :minmax,\n        visual = (; color = :cyan3),\n        axis = (;\n            xlabel = \"\",\n            ylabel = \"Time [s]\",\n            ylabelpadding = 40,\n            title = \"ax_ticklabels = :left\",\n        ),\n    ) # show all ticks on the left axis, but only extremities on others\n    plot_parallelcoordinates(\n        f[3, 1],\n        subset(results_plot, :channel => x -> x .< 5, :time => x -> x .< 0);\n        ax_labels = [\"Fz\", \"Cz\", \"O1\", \"O2\"],\n        ax_ticklabels = :outmost,\n        normalize = :minmax,\n        visual = (; color = :burlywood1),\n        axis = (;\n            xlabel = \"\",\n            ylabel = \"Time [s]\",\n            ylabelpadding = 40,\n            title = \"ax_ticklabels = :outmost\",\n        ),\n    ) # show ticks on extremities of all axes\n\n    plot_parallelcoordinates(\n        f[4, 1],\n        subset(results_plot, :channel => x -> x .< 5, :time => x -> x .< 0);\n        ax_labels = [\"Fz\", \"Cz\", \"O1\", \"O2\"],\n        ax_ticklabels = :none,\n        normalize = :minmax,\n        visual = (; color = :cyan3),\n        axis = (; ylabel = \"Time [s]\", ylabelpadding = 40, title = \"ax_ticklabels = :none\"),\n    ) #  disable all ticks\n    f\nend"},{"id":462,"pagetitle":"Parallel coordinates","title":"Bending the parallel plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Bending-the-parallel-plot","content":" Bending the parallel plot Bending the linescan be helpful to make them more visible. begin\n    f = Figure()\n    plot_parallelcoordinates(\n        f[1, 1],\n        ax_labels = [\"FP1\", \"F3\", \"F7\", \"FC3\", \"C3\", \"T7\", \"CP3\", \"P3\", \"P7\", \"O1\"],\n        subset(results_plot, :channel => x -> x .< 10),\n        visual = (; color = :plum),\n        axis = (; title = \"bend = false\", xlabel = \"\", ylabel = \"Time [s]\"),\n    )\n    plot_parallelcoordinates(\n        f[2, 1],\n        ax_labels = [\"FP1\", \"F3\", \"F7\", \"FC3\", \"C3\", \"T7\", \"CP3\", \"P3\", \"P7\", \"O1\"],\n        subset(results_plot, :channel => x -> x .< 10),\n        bend = true, # here\n        visual = (; color = :plum),\n        axis = (; title = \"bend = true\", ylabel = \"Time [s]\"),\n    )\n    f\nend"},{"id":463,"pagetitle":"Parallel coordinates","title":"Transparancy","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Transparancy","content":" Transparancy uf_5chan = UnfoldMakie.example_data(\"UnfoldLinearModelMultiChannel\")\n\nbegin\n    f = Figure()\n    plot_parallelcoordinates(\n        f[1, 1],\n        uf_5chan;\n        mapping = (; color = :coefname),\n        ax_labels = [\"FP1\", \"F3\", \"F7\", \"FC3\", \"C3\"],\n        visual = (; alpha = 0.1),\n        axis = (;\n            title = \"alpha = 0.1\",\n            xlabel = \"\",\n            ylabel = \"Time [s]\",\n            ylabelpadding = 20,\n        ),\n    )\n    plot_parallelcoordinates(\n        f[2, 1],\n        uf_5chan,\n        mapping = (; color = :coefname),\n        ax_labels = [\"FP1\", \"F3\", \"F7\", \"FC3\", \"C3\"],\n        visual = (; alpha = 0.9),\n        axis = (; title = \"alpha = 0.9\", ylabel = \"Time [s]\", ylabelpadding = 20),\n    )\n    f\nend"},{"id":464,"pagetitle":"Parallel coordinates","title":"Configurations of Parallel coordinates plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#Configurations-of-Parallel-coordinates-plot","content":" Configurations of Parallel coordinates plot"},{"id":465,"pagetitle":"Parallel coordinates","title":"UnfoldMakie.plot_parallelcoordinates","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/parallelcoordinates/#UnfoldMakie.plot_parallelcoordinates","content":" UnfoldMakie.plot_parallelcoordinates  —  Function plot_parallelcoordinates(data::Union{DataFrame, AbstractMatrix}; kwargs...)\nplot_parallelcoordinates!(f::Union{GridPosition, GridLayout, Figure}, data::Union{DataFrame, AbstractMatrix}; kwargs) Plot a PCP (parallel coordinates plot). Dimensions: conditions, channels, time, trials.  Arguments: f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{DataFrame, AbstractMatrix}   Data for the plot visualization. Keyword arguments (kwargs) normalize::Symbol = nothing   If  :minmax , normalize each axis to their respective min-max range. ax_labels::Vector{String} = nothing   Specify axis labels.    Should be a vector of labels with length equal to the number of unique  mapping.x  values.   Example:  ax_labels = [\"Fz\", \"Cz\", \"O1\", \"O2\"] . ax_ticklabels::Symbol = :outmost   Specify tick labels on axis. :all  - show all labels on all axes. :left  - show all labels on the left axis, but only min and max on others.  :outmost  - show labels on min and max of all other axes.  :none  - remove all labels.  bend::Bool = false   Change straight lines between the axes to curved (\"bent\") lines using spline interpolation.   Note: While this makes the plot look cool, it is not generally recommended to bent the lines, as interpretation   suffers, and the resulting visualizations can be potentially missleading. visual.alpha::Number = 0.5   Change of line transparency. Defining the axes mapping.x = :channel, mapping.y = :estimate .   Overwrite what should be on the x and the y axes. mapping.color = :colorcolumn   Split conditions by color. The default color is  :black . Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Channels\", ylabel = \"Time\", title = \"\", xlabelpadding = 14, ylabelpadding = 26) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = :channel, y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = ColorTypes.RGBA{Float32}[RGBA(0.0, 0.44705883, 0.69803923, 1.0), RGBA(0.9019608, 0.62352943, 0.0, 1.0), RGBA(0.0, 0.61960787, 0.4509804, 1.0), RGBA(0.8, 0.4745098, 0.654902, 1.0), RGBA(0.3372549, 0.7058824, 0.9137255, 1.0), RGBA(0.8352941, 0.36862746, 0.0, 1.0), RGBA(0.9411765, 0.89411765, 0.25882354, 1.0)], color = :black, alpha = 0.3) -  use  kwargs...  of  Makie.lines legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center, title = \"Conditions\", merge = true, framevisible = false) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966) -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Parallel coordinates plot. source This page was generated using  Literate.jl ."},{"id":468,"pagetitle":"Spline plot","title":"Spline plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/splines/#spline_vis","content":" Spline plot Spline plot  is a plot type for visualisation of  terms in an UnfoldModel. Two subplots are generated for each spline term: 1) the basis function of the spline; 2) the density of the underlying covariate. Multiple spline terms are arranged across columns. Dashed lines indicate spline knots."},{"id":469,"pagetitle":"Spline plot","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/splines/#Setup","content":" Setup Package and data loading using Unfold, UnfoldMakie\nimport BSplineKit, DataFrames\n\ndf, pos = UnfoldMakie.example_data(\"TopoPlots.jl\")\nm1 = UnfoldMakie.example_data(\"UnfoldLinearModelwith1Spline\");\nm2 = UnfoldMakie.example_data(\"UnfoldLinearModelwith2Splines\"); Spline plot with one spline term: plot_splines(m1) Spline plot with two spline terms: plot_splines(m2)"},{"id":470,"pagetitle":"Spline plot","title":"Configurations of Spline plot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/splines/#Configurations-of-Spline-plot","content":" Configurations of Spline plot"},{"id":471,"pagetitle":"Spline plot","title":"UnfoldMakie.plot_splines","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/splines/#UnfoldMakie.plot_splines","content":" UnfoldMakie.plot_splines  —  Function plot_splines(m::UnfoldModel; kwargs...)\nplot_splines!(f::Union{GridPosition, GridLayout, Figure}, m::UnfoldModel; kwargs...) Visualization of spline terms in an UnfoldModel. Two subplots are generated for each spline term: 1) the basis function of the spline; 2) the density of the underlying covariate. Multiple spline terms are arranged across columns. Dashed lines indicate spline knots. Arguments: f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. m::UnfoldModel   UnfoldModel with splines. spline_axis::NamedTuple = (;)   Here you can flexibly change configurations of spline subplots.   To see all options just type  ?Axis  in REPL.   Defaults: (ylabel = \"Spline value\", xlabelvisible = false, xticklabelsvisible = false, ylabelvisible = true)     density_axis::NamedTuple = (;)   Here you can flexibly change configurations of density subplots.   To see all options just type  ?Axis  in REPL.   Defaults: (xautolimitmargin = (0, 0), ylabel = \"Density value\") superlabel_config::NamedTuple = (;)   Here you can flexibly change configurations of the Label on the top of the plot.   To see all options just type  ?Label  in REPL.   Defaults: (fontsize = 20, padding = (0, 0, 40, 0)) Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  NamedTuple() -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true) -  check this  page mapping =  (x = (:time,), y = (:estimate, :yhat, :y)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = :viridis,) -  use  kwargs...  of  Makie.series legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center, title = \"Splines\", framevisible = false) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966) -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  with splines and their density for basis functions. source This page was generated using  Literate.jl ."},{"id":474,"pagetitle":"Topoplot","title":"Topoplot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#topo_vis","content":" Topoplot Topoplot  (aka topography plot) is a plot type for visualisation of EEG activity in a specific time stemp or time interval. It can fully represent channel and channel location dimensions using contour lines. The topoplot is a 2D projection and interpolation of the 3D distributed sensor activity. The name stems from physical geography, but instead of height, the contour lines represent voltage levels."},{"id":475,"pagetitle":"Topoplot","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#Setup","content":" Setup Package loading using UnfoldMakie\nusing DataFrames\nusing CairoMakie\nusing TopoPlots Data loading dat, positions = TopoPlots.example_data(); The size of  data  is 64×400×3. This means: 64 channels; 400 timepoints in range from -0.3 to 0.5 mseconds; Estimates of 3 averaging functions. Instead of displaying the EEG data for all subjects, here we aggregate the data using (1) mean, (2) standard deviation and (3) p-value within t-tests. While  position  consist of 64 x and y coordinates of each channels on a scalp."},{"id":476,"pagetitle":"Topoplot","title":"Plot Topoplots","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#Plot-Topoplots","content":" Plot Topoplots Here we select a time point in 340 msec and the mean estimate. df = DataFrame(:estimate => dat[:, 340, 1])\nplot_topoplot(\n    df;\n    positions = positions,\n    axis = (; xlabel = \"340 ms\"),\n    colorbar = (; height = 350),\n)"},{"id":477,"pagetitle":"Topoplot","title":"Setting sensor positions","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#Setting-sensor-positions","content":" Setting sensor positions The  plot_topoplot()  needs the sensor positions to be specified. There are several ways to do this: Specify positions directly:  plot_topoplot(...; positions=[...]) Specify the sensor labels:  plot_topoplot(...; labels=[...]) To get the positions from the labels we use a  database ."},{"id":478,"pagetitle":"Topoplot","title":"Column Mappings for Topoplots","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#Column-Mappings-for-Topoplots","content":" Column Mappings for Topoplots When using topoplots with a  DataFrame  as input, the library needs to know the names of the columns used for plotting. This is specified using the  mapping=(;)  kwargs. While there are several default values that will be checked in order if they exist in the  DataFrame , a custom name may need to be chosen: Note that only one of  positions  or  labels  needs to be set to draw a topoplot. If both are set, positions takes precedence, labels can be used to label electrodes in TopoPlots.jl. The default columns of mapping could be seen usign this code: configs_default = UnfoldMakie.PlotConfig()\nconfigs_default.mapping.y (:estimate, :yhat, :y)"},{"id":479,"pagetitle":"Topoplot","title":"Labelling","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#Labelling","content":" Labelling label_text  draws labels next to their positions. Example:  plot_topoplot(...; visual=(; label_text = true)) label_scatter (boolean)  draws the markers at the given positions. Example:  plot_topoplot(...; visual=(; label_scatter = true)) begin\n    f = Figure(size = (500, 500))\n    labs4 = [\"s1\", \"s2\", \"s3\", \"s4\"]\n    plot_topoplot!(\n        f[1, 1],\n        dat[1:4, 340, 1];\n        positions = positions[1:4],\n        visual = (; label_scatter = false),\n        labels = labs4,\n        axis = (; xlabel = \"\", title = \"No markers\"),\n        colorbar = (; height = 100,),\n    )\n\n    plot_topoplot!(\n        f[2, 1],\n        dat[1:4, 340, 1];\n        positions = positions[1:4],\n        visual = (;\n            label_text = true,\n            label_scatter = (\n                markersize = 15,\n                color = \"white\",\n                strokecolor = \"green\",\n                strokewidth = 2,\n            ),\n        ),\n        labels = labs4,\n        axis = (; xlabel = \"340 ms\", title = \"Markers with channel labels\"),\n        mapping = (; labels = labs4),\n        colorbar = (; height = 100),\n    )\n    f\nend"},{"id":480,"pagetitle":"Topoplot","title":"Highlighting channels","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#Highlighting-channels","content":" Highlighting channels plot_topoplot(dat[:, 50, 1]; positions, high_chan = [1, 2], axis = (; xlabel = \"340 ms\"))"},{"id":481,"pagetitle":"Topoplot","title":"Horizontal colorbars","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#Horizontal-colorbars","content":" Horizontal colorbars Just switch  colorbar.vertical  to  false plot_topoplot(\n    dat[:, 50, 1];\n    positions,\n    axis = (; xlabel = \"50 ms\"),\n    colorbar = (; vertical = false, width = 180, label = \"Voltage estimate\"),\n)"},{"id":482,"pagetitle":"Topoplot","title":"Advanced markers","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#Advanced-markers","content":" Advanced markers You can use markers and their proeprties as additional information dimension. For instance, to map uncertaitny or some other value to the marker size, color or rotation. This is done by setting the  topo_attributes  kwarg. The following example shows how to set the marker size and color based on the data values. Check more  here . random_rotations = rand(64) .* 2π\nplot_topoplot(\n    dat[:, 50, 1];\n    positions,\n    axis = (; xlabel = \"50 ms\"),\n    topo_attributes = (;\n        label_scatter = (;\n            markersize = 20,\n            marker = '↑',\n            color = :black,\n            rotation = random_rotations,\n        )\n    ),\n)\n\nplot_topoplot(\n    dat[:, 50, 1];\n    positions,\n    axis = (; xlabel = \"50 ms\"),\n    topo_attributes = (;\n        label_scatter = (; markersize = random_rotations, marker = :circle, color = :black)\n    ),\n)"},{"id":483,"pagetitle":"Topoplot","title":"Configurations of Topoplot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#Configurations-of-Topoplot","content":" Configurations of Topoplot"},{"id":484,"pagetitle":"Topoplot","title":"UnfoldMakie.plot_topoplot","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplot/#UnfoldMakie.plot_topoplot","content":" UnfoldMakie.plot_topoplot  —  Function plot_topoplot!(f::Union{GridPosition, GridLayout, Figure}, data::Union{<:Observable{<:DataFrame},<:AbstractDataFrame,<:AbstractVector}; positions::Vector, labels = nothing, kwargs...)\nplot_topoplot(data::Union{<:Observable{<:DataFrame},<:AbstractDataFrame,<:AbstractVector}; position::Vector, labels = nothing, kwargs...) Plot a topoplot. Arguments f::Union{GridPosition, GridLayout, Figure} Figure ,  GridLayout , or  GridPosition  to draw the plot. data::Union{<:Observable{<:DataFrame},<:AbstractDataFrame,<:AbstractVector}   Data for the plot visualization. positions::Vector{Point{2, Float32}}   Positions used if  data  is not a  DataFrame . Positions are generated from  labels  if  positions = nothing . labels::Vector{String} = nothing   Labels used if  data  is not a DataFrame. high_chan = nothing  - channnel(s) to highlight by color. high_color = :darkgreen  - color for highlighting.  topo_axis::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot axis.   To see all options just type  ?Axis  in REPL.   Defaults: (width = Relative(1.0f0), height = Relative(1.0f0), halign = 0.05, valign = 0.95, aspect = DataAspect()) topo_attributes::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot interoplation.   To see all options just type  ?Topoplot.topoplot  in REPL.   Defaults: interp_resolution = (128, 128), interpolation = CloughTocher() Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time\", aspect = Makie.DataAspect()) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true, hidespines = (), hidedecorations = Dict{Symbol, Bool}(:label => 0)) -  check this  page mapping =  (x = nothing, y = (:estimate, :yhat, :y), positions = (:pos, :positions, :position, nothing), labels = (:labels, :label, :sensor, nothing)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = Makie.Reverse{Symbol}(:RdBu), contours = (color = :white, linewidth = 2), enlarge = 1, label_scatter = true, label_text = false, bounding_geometry = GeometryBasics.Circle) -  use  kwargs...  of  Topoplot.eeg_topoplot legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, flipaxis = true, label = \"Voltage [µV]\") -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Topoplot. source This page was generated using  Literate.jl ."},{"id":487,"pagetitle":"Topoplot series","title":"Topoplot Series","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Topoplot-Series","content":" Topoplot Series Topoplot series  is a plot type for visualizing EEG activity in a given time frame or time interval. It can fully represent channel and channel location dimensions using contour lines. It can also partially represent the time dimension. Basically, it is a series of Topoplots."},{"id":488,"pagetitle":"Topoplot series","title":"Setup","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Setup","content":" Setup Package loading using Unfold\nusing UnfoldMakie\nusing DataFrames\nusing CairoMakie\nusing TopoPlots\nusing Statistics Data input dat, positions = TopoPlots.example_data()\ndf = UnfoldMakie.eeg_array_to_dataframe(dat[:, :, 1], string.(1:length(positions)));"},{"id":489,"pagetitle":"Topoplot series","title":"Number of topoplots","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Number-of-topoplots","content":" Number of topoplots There are two ways to specify the number of topoplots in a topoplot series:  bin_width  - specify the interval between topoplots bin_width = 80\nplot_topoplotseries(\n    df;\n    bin_width,\n    positions = positions,\n    axis = (; xlabel = \"Time windows [s]\"),\n) bin_num  - specify the number of topoplots plot_topoplotseries(\n    df;\n    bin_num = 5,\n    positions = positions,\n    axis = (; xlabel = \"Time windows [s]\"),\n)"},{"id":490,"pagetitle":"Topoplot series","title":"Categorical and contionous x-values","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Categorical-and-contionous-x-values","content":" Categorical and contionous x-values By deafult x-value is  time , but it could be any contionous (i.g. saccade amplitude) or categorical (any experimental variable) value. f = Figure()\ndf_cat = UnfoldMakie.eeg_array_to_dataframe(dat[:, 1:5, 1], string.(1:length(positions)))\ndf_cat.condition = repeat([\"A\", \"B\", \"C\", \"D\", \"E\"], size(df_cat, 1) ÷ 5)\n\nplot_topoplotseries!(\n    f[1, 1],\n    df_cat;\n    nrows = 2,\n    mapping = (; col = :condition),\n    axis = (; xlabel = \"Conditions\"),\n    positions = positions,\n)\nf Warning Version with conditional  mapping.row  is not yet implemented. To create topoplot series with categorical values: Do not specify  bin_width  or  bin_num . Put categorical value in  mapping.col ."},{"id":491,"pagetitle":"Topoplot series","title":"Additional features","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Additional-features","content":" Additional features"},{"id":492,"pagetitle":"Topoplot series","title":"Adjusting individual topoplots","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Adjusting-individual-topoplots","content":" Adjusting individual topoplots By using  topoplot_axes  you can flexibly change configurations of topoplots. df_adj = UnfoldMakie.eeg_array_to_dataframe(dat[:, 1:4, 1], string.(1:length(positions)))\ndf_adj.condition = repeat([\"A\", \"B\", \"C\", \"D\"], size(df_adj, 1) ÷ 4)\n\nplot_topoplotseries(\n    df_adj;\n    nrows = 2,\n    positions = positions,\n    mapping = (; col = :condition),\n    axis = (; title = \"axis title\", xlabel = \"Conditions\"),\n    topoplot_axes = (;\n        rightspinevisible = true,\n        xlabelvisible = false,\n        title = \"single topoplot title\",\n    ),\n)"},{"id":493,"pagetitle":"Topoplot series","title":"Adjusting column gaps","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Adjusting-column-gaps","content":" Adjusting column gaps Using  colgap  in  with_theme  helps to adjust column gaps. with_theme(colgap = 5) do\n    plot_topoplotseries(\n        df,\n        bin_num = 5;\n        positions = positions,\n        axis = (; xlabel = \"Time windows [s]\"),\n    )\nend However it doesn't work with subsets. Here you need to use  topoplot_axes.limits . begin\n    f = Figure()\n    plot_topoplotseries!(\n        f[1, 1],\n        df,\n        bin_num = 5;\n        positions = positions,\n        topoplot_axes = (; limits = (-0.05, 1.05, -0.1, 1.05)),\n        axis = (; xlabel = \"Time windows [s]\"),\n    )\n    f\nend"},{"id":494,"pagetitle":"Topoplot series","title":"Adjusting contours","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Adjusting-contours","content":" Adjusting contours Topographic contour is a line drawn on a topographic map to indicate an increase or decrease in voltage. A contour level is an area with a specific range of voltage. By default, the number of contour levels is 6, which means that the topography plot is divided into 6 areas depending on their voltage values. plot_topoplotseries(\n    df;\n    bin_width,\n    positions = positions,\n    visual = (; enlarge = 0.9, contours = (; linewidth = 1, color = :black)),\n    axis = (; xlabel = \"Time windows [s]\"),\n)"},{"id":495,"pagetitle":"Topoplot series","title":"Aggregating functions","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Aggregating-functions","content":" Aggregating functions In this example  combinefun  is specified by  mean ,  median  and  std . f = Figure(size = (500, 500))\nplot_topoplotseries!(\n    f[1, 1],\n    df;\n    bin_width,\n    positions = positions,\n    combinefun = mean,\n    axis = (; xlabel = \"\", title = \"combinefun = mean\"),\n)\nplot_topoplotseries!(\n    f[2, 1],\n    df;\n    bin_width,\n    positions = positions,\n    combinefun = median,\n    axis = (; xlabel = \"\", title = \"combinefun = median\"),\n)\nplot_topoplotseries!(\n    f[3, 1],\n    df;\n    bin_width,\n    positions = positions,\n    combinefun = std,\n    axis = (; title = \"combinefun = std\", xlabel = \"Time windows [s]\"),\n)\nf"},{"id":496,"pagetitle":"Topoplot series","title":"Multiple rows","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Multiple-rows","content":" Multiple rows Use  nrows  to specify multiple rows. f = Figure()\ndf_col = UnfoldMakie.eeg_array_to_dataframe(dat[:, :, 1], string.(1:length(positions)))\nplot_topoplotseries!(\n    f[1, 1:5],\n    df_col;\n    bin_num = 16,\n    nrows = 4,\n    positions = positions,\n    visual = (; label_scatter = false, contours = false),\n    axis = (; xlabel = \"Time windows [s]\"),\n)\nf"},{"id":497,"pagetitle":"Topoplot series","title":"Row mapping","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Row-mapping","content":" Row mapping Use  mapping.row  to specify faceting by condition. df = UnfoldMakie.eeg_array_to_dataframe(dat[:, 1:12, 1], string.(1:length(positions)))\ndf.condition = repeat(repeat([\"A\", \"B\", \"C\"], inner = 4), 64)\ndf.time = repeat(repeat([1, 2, 3, 4], outer = 3), 64)\n\nwith_theme(rowgap = 0) do\n    plot_topoplotseries(\n        df;\n        bin_num = 4,\n        positions = positions,\n        mapping = (; row = :condition),\n    )\nend"},{"id":498,"pagetitle":"Topoplot series","title":"Channel labels","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Channel-labels","content":" Channel labels Use  visual  to specify channel labelss and channels markers.   visual.label_text = true  makes channel names visible. begin\n    f = Figure()\n    df_col = UnfoldMakie.eeg_array_to_dataframe(dat[1:4, :, 1], string.(1:4))\n    labs4 = [\"s1\", \"s2\", \"s3\", \"s4\"]\n    plot_topoplotseries!(\n        f[1, 1:5],\n        df_col;\n        bin_num = 2,\n        positions = positions[4:7],\n        labels = labs4,\n        visual = (;\n            label_scatter = (\n                markersize = 15,\n                color = \"white\",\n                strokecolor = \"green\",\n                strokewidth = 2,\n            ),\n            label_text = true,\n        ),\n        axis = (; xlabel = \"Time windows [s]\"),\n    )\n    f\nend"},{"id":499,"pagetitle":"Topoplot series","title":"Configurations of Topoplot series","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#Configurations-of-Topoplot-series","content":" Configurations of Topoplot series Also you can: Label the x-axis with  axis.xlabel . Hide electrode markers with  visual.label_scatter . Change the color map with  visual.colormap . The default is  Reverse(:RdBu) . Adjust the limits of the topoplot boxes with  axis.xlim_topo  and  axis.ylim_topo . By default both are  (-0.25, 0.25) . Adjust the size of the figure with  Figure(size = (x, y)) . Adjust the padding between topoplot labels and axis labels using  xlabelpadding  and  ylabelpadding ."},{"id":500,"pagetitle":"Topoplot series","title":"UnfoldMakie.plot_topoplotseries","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/generated/tutorials/topoplotseries/#UnfoldMakie.plot_topoplotseries","content":" UnfoldMakie.plot_topoplotseries  —  Function plot_topoplotseries(f::Union{GridPosition, GridLayout, Figure}, data::Union{<:Observable{<:DataFrame},DataFrame}; kwargs...)\nplot_topoplotseries!(data::Union{<:Observable{<:DataFrame},DataFrame}; kwargs...) Multiple miniature topoplots in regular distances.  Arguments f::Union{GridPosition, GridLayout, GridLayoutBase.GridSubposition, Figure} Figure ,  GridLayout ,  GridPosition , or  GridLayoutBase.GridSubposition  to draw the plot. data::Union{<:Observable{<:DataFrame},DataFrame}   DataFrame with data or Observable DataFrame.   Requires a  time  column by default, but can be overridden by specifying  mapping=(; x=:my_column)  with any continuous or categorical column.  Keyword arguments (kwargs) bin_width::Real = nothing   Number specifing the width of bin of continuous x-value in its units. bin_num::Real = nothing   Number of topoplots.   Either  bin_width , or  bin_num  should be specified. Error if they are both specified   If  mapping.col  or  mapping.row  are categorical  bin_width  and  bin_num  stay as  nothing . combinefun::Function = mean   Specify how the samples within  bin_width  are summarised.   Example functions:  mean ,  median ,  std .  rasterize_heatmaps::Bool = true   Force rasterization of the plot heatmap when saving in  svg  format.   Except for the interpolated heatmap, all lines/points are vectors.   This is typically what you want, otherwise you get ~128x128 vectors per topoplot, which makes everything very slow. col_labels::Bool ,  row_labels::Bool = true   Shows column and row labels in faceting mode. (not implemented) positions::Vector{Point{2, Float32}} = nothing   Specify channel positions. Requires the list of x and y positions for all unique electrodes. labels::Vector{String} = nothing   Show labels for each electrode. interactive_scatter = nothing   Enable interactive mode.   If you create  obs_tuple = Observable((0, 0, 0))  and pass it into  interactive_scatter  you can update the observable tuple with the indices of the clicked topoplot markers. (0, 0, 0)  corresponds to the (row of topoplot layout, column of topoplot layout, electrode).  topo_axis::NamedTuple = (;)   Here you can flexibly change configurations of topoplots.   To see all options just type  ?Axis  in REPL. mapping = (; col = :time , row = nothing, layout = nothing) mapping.col  - specify x-value, can be any continuous or categorical variable. mapping.row  - specify y-value, can be any continuous or categorical variable (not implemented yet). mapping.layout  - arranges topoplots by rows when equals  :time . topo_attributes::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot interoplation.   To see all options just type  ?Topoplot.topoplot  in REPL.   Defaults: interp_resolution = (128, 128), interpolation = CloughTocher() topolabels_rounding = (; sigdigits = 3)   Rounding of the topo_axis labels. sigdigits  - number of significant digits. digits  - number of digits after the decimal point.   Only one of  sigdigits  or  digits  should be provided. Shared plot configuration options The shared plot options can be used as follows:  type = (; key = value, ...)) . For example,  plot_x(...; colorbar = (; vertical = true, label = \"Test\")) . Multiple defaults will be cycled until match. Placing  ;  is important! figure =  NamedTuple() -  use  kwargs...  of  Makie.Figure axis =  (xlabel = \"Time windows\", aspect = Makie.DataAspect(), title = \"\", titlesize = 16, titlefont = :bold, ylabel = \"\", ylabelpadding = 25, xlabelpadding = 25, xpanlock = true, ypanlock = true, xzoomlock = true, yzoomlock = true, xrectzoom = false, yrectzoom = false) -  use  kwargs...  of   Makie.Axis layout =  (show_legend = true, use_colorbar = true, hidespines = (), hidedecorations = Dict{Symbol, Bool}(:label => 0)) -  check this  page mapping =  (x = nothing, y = (:estimate, :yhat, :y), positions = (:pos, :positions, :position, nothing), labels = (:labels, :label, :sensor, nothing), col = (:time,), row = (nothing,)) -  use any mapping from  AlgebraOfGraphics visual =  (colormap = Makie.Reverse{Symbol}(:RdBu), contours = (color = :white, linewidth = 2), enlarge = 1, label_scatter = false, label_text = false, bounding_geometry = GeometryBasics.Circle, levels = nothing) -  use  kwargs...  of  Topoplot.eeg_topoplot legend =  (orientation = :vertical, tellwidth = true, tellheight = false, halign = :right, valign = :center) -  use  kwargs...  of   Makie.Legend colorbar =  (vertical = true, tellwidth = true, tellheight = false, labelrotation = -1.5707963267948966, flipaxis = true, label = \"Voltage [µV]\") -  use  kwargs...  of   Makie.Colorbar Return Value: Figure  displaying the Topoplot series. source This page was generated using  Literate.jl ."},{"id":503,"pagetitle":"API: Utilities","title":"UnfoldMakie.RelativeAxis","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/helper/#UnfoldMakie.RelativeAxis","content":" UnfoldMakie.RelativeAxis  —  Type RelativeAxis(fig, p::NTuple{4, Float64}; kwargs...) Returns an  Axis  whose position is relative to a  GridLayout  element (via  BBox ) and not relative to the  Scene . Default behavior is  Axis(..., bbox = BBox()) . p::NTuple{4,Float64} : specify the position relative to the GridPosition   left:right; bottom:top, typical numbers between 0 and 1, e.g. (0.25, 0.75, 0.25, 0.75) would center an  Axis  inside this  GridPosition . kwargs...  - inserted into the axis. f = Figure()   ax = RelativeAxis(f[1, 2], (0.25, 0.75, 0.25, 0.75)# returns Axis centered within f[1, 2] Return Value: Axis . source"},{"id":504,"pagetitle":"API: Utilities","title":"UnfoldMakie.eeg_topoplot_series","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/helper/#UnfoldMakie.eeg_topoplot_series","content":" UnfoldMakie.eeg_topoplot_series  —  Function  eeg_topoplot_series(data::DataFrame,\n    fig,\n    data_inp::Union{<:Observable,<:AbstractMatrix};\n    layout = nothing,\n    topoplot_xlabels = nothing,\n    labels = nothing,\n    rasterize_heatmaps = true,\n    interactive_scatter = nothing,\n    highlight_scatter = false,\n    topo_axis = (;),\n    topo_attributes = (;),\n    positions,\n)\neeg_topoplot_series!(fig, data::DataFrame; kwargs..) Plot a series of topoplots.  The function takes the  combinefun = mean  over the  :time  column of  data . fig   Figure object.  data::Union{<:Observable,<:AbstractMatrix}   Matrix with size = (n channel, n topoplots). layout::Vector{Tuple{Int64, Int64}}   Vector of tuples with coordinates for each topoplot. topoplot_xlabels::Vector{String}   Vector of xlables for each topoplot.  topo_axis::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot axis.   To see all options just type  ?Axis  in REPL.   Defaults: (aspect = 1, title = \"\", xgridvisible = false, xminorgridvisible = false, xminorticksvisible = false, xticksvisible = false, xticklabelsvisible = false, xlabelvisible = true, ygridvisible = false, yminorgridvisible = false, yminorticksvisible = false, yticksvisible = false, yticklabelsvisible = false, leftspinevisible = false, rightspinevisible = false, topspinevisible = false, bottomspinevisible = false, xpanlock = true, ypanlock = true, xzoomlock = true, yzoomlock = true, xrectzoom = false, yrectzoom = false) topo_attributes::NamedTuple = (;)   Here you can flexibly change configurations of the topoplot interoplation.   To see all options just type  ?Topoplot.topoplot  in REPL.   Defaults: interp_resolution = (128, 128), interpolation = CloughTocher(). positions::Vector{Point{2, Float32}}   Channel positions. The list of x and y positions for all unique electrodes.  Return Value: Tuple{Figure, Vector{Any}} . source"},{"id":505,"pagetitle":"API: Utilities","title":"UnfoldMakie.config_kwargs!","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/helper/#UnfoldMakie.config_kwargs!","content":" UnfoldMakie.config_kwargs!  —  Function config_kwargs!(cfg::PlotConfig; kwargs...) Takes NamedTuple of  Key => NamedTuple  as kwargs and merges the fields with the defaults. source"},{"id":506,"pagetitle":"API: Utilities","title":"UnfoldMakie.eeg_array_to_dataframe","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/helper/#UnfoldMakie.eeg_array_to_dataframe","content":" UnfoldMakie.eeg_array_to_dataframe  —  Function eeg_array_to_dataframe(data::AbstractMatrix, label_aliases::AbstractVector)\neeg_array_to_dataframe(data::AbstractVector, label_aliases::AbstractVector)\neeg_array_to_dataframe(data::Union{AbstractMatrix, AbstractVector{<:Number}}) Helper function converting an array (Matrix or Vector) to a tidy  DataFrame  with columns  :estimate ,  :time  and  :label  (with aliases  :color ,  :group ,  :channel ). Format of Arrays: - times x condition for plot_erp. - channels x time for plot_butterfly, plot_topoplotseries. - channels for plot_topoplot. Return Value: DataFrame . source"},{"id":507,"pagetitle":"API: Utilities","title":"UnfoldMakie.rel_to_abs_bbox","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/helper/#UnfoldMakie.rel_to_abs_bbox","content":" UnfoldMakie.rel_to_abs_bbox  —  Function rel_to_abs_bbox(org, rel) Takes a rectangle  org  consiting of coordinates of origins and applies the relative transformation tuple  rel . Return Value: Makie.BBox . source"},{"id":508,"pagetitle":"API: Utilities","title":"UnfoldMakie.to_positions","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/helper/#UnfoldMakie.to_positions","content":" UnfoldMakie.to_positions  —  Function to_positions(x, y, z; sphere = [0, 0, 0.])\nto_positions(pos::AbstractMatrix; sphere = [0, 0, 0.]) Projects 3D electrode positions to a 2D layout. Reimplementation of the MNE algorithm. Assumes  size(pos) = (3, nChannels)  when input is  AbstractMatrix . Tip: You can get positions directly from an MNE object after loading PyMNE and enabling the UnfoldMakie PyMNE extension. Return Value: Vector{Point2{Float64}} .  source"},{"id":509,"pagetitle":"API: Utilities","title":"UnfoldMakie.data_binning","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/helper/#UnfoldMakie.data_binning","content":" UnfoldMakie.data_binning  —  Function data_binning(df; col_y = :erp, fun = mean, grouping = []) Group  DataFrame  according to topoplot coordinates and apply aggregation function. Arguments: df::AbstractTable   Requires columns  :cont_cuts ,  col_y  (default  :erp ), and all columns in  grouping  ( col_coord ,  row_coord ,  label ); col_y = :erp   The column to combine over (with  fun ); fun = mean()   Function to combine. grouping = []   Vector of symbols or strings, columns to group by the data before aggregation. Values of  nothing  are ignored. Return Value: DataFrame . source"},{"id":510,"pagetitle":"API: Utilities","title":"UnfoldMakie.cart3d_to_spherical","ref":"/UnfoldDocs/UnfoldMakie.jl/stable/helper/#UnfoldMakie.cart3d_to_spherical","content":" UnfoldMakie.cart3d_to_spherical  —  Function cart3d_to_spherical(x, y, z) Convert x, y, z electrode positions on a scalp to spherical coordinate representation.  Return Value: Matrix . source"},{"id":513,"pagetitle":"Home","title":"UnfoldSim.jl Documentation","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#UnfoldSim.jl-Documentation","content":" UnfoldSim.jl Documentation Welcome to  UnfoldSim.jl : a Julia package for simulating multivariate timeseries data with a focus on EEG, especially event-related potentials (ERPs).  The user provides four ingredients: 1) an experimental design, with both categorical and continuous variables, 2) event basis functions specified via linear or hierarchical models, 3) an inter-event onset distribution, and 4) a noise specification."},{"id":514,"pagetitle":"Home","title":"Key features","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#Key-features","content":" Key features Modularity:  Choose or implement different designs, components, onset distributions or noise types Multi-subject  & complex experimental designs Multi-channel  via EEG-forward models Continuous or epoched  data with potentially  overlapping  signals Potential support for  other modalities , e.g. single-voxel fMRI or pupil dilation"},{"id":515,"pagetitle":"Home","title":"Installation","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#Installation","content":" Installation julia> using Pkg; Pkg.add(\"UnfoldSim\") For more detailed instructions please refer to  Installing Julia & UnfoldSim.jl ."},{"id":516,"pagetitle":"Home","title":"Usage example","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#Usage-example","content":" Usage example"},{"id":517,"pagetitle":"Home","title":"Start simulating time series data","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#Start-simulating-time-series-data","content":" Start simulating time series data We offer some predefined (EEG) signals, check them out! For instance, a P1/N170/P300 complex (containing three typical ERP components). using UnfoldSim\ndata, events = UnfoldSim.predef_eeg(; n_repeats = 1, noiselevel = 0.8)"},{"id":518,"pagetitle":"Home","title":"Or simulate epoched data directly","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#Or-simulate-epoched-data-directly","content":" Or simulate epoched data directly data, events = UnfoldSim.predef_eeg(; n_repeats = 20, noiselevel = 0.8, return_epoched = true)"},{"id":519,"pagetitle":"Home","title":"Where to start: Learning roadmap","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#Where-to-start:-Learning-roadmap","content":" Where to start: Learning roadmap"},{"id":520,"pagetitle":"Home","title":"1. First steps","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#1.-First-steps","content":" 1. First steps 📌 Goal: Learn about the simulation workflow and run your first simulation 🔗  Quickstart  |  Simulate event-related potentials (ERPs)"},{"id":521,"pagetitle":"Home","title":"2. Intermediate topics","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#2.-Intermediate-topics","content":" 2. Intermediate topics 📌 Goal: Learn about multi-subject and multi-channel simulations  🔗  Multi-subject simulation  |  Generate multi channel data"},{"id":522,"pagetitle":"Home","title":"3. Advanced topics","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#3.-Advanced-topics","content":" 3. Advanced topics 📌 Goal: Learn how to implement your own experimental designs, components, etc. 🔗  Define a new (imbalanced) design  |  Define a new component (with variable duration and shift)  |  Use existing experimental designs & onsets in the simulation"},{"id":523,"pagetitle":"Home","title":"Statement of need","ref":"/UnfoldDocs/UnfoldSim.jl/stable/#Statement-of-need","content":" Statement of need EEG researchers often analyze data containing (temporally) overlapping events (e.g. stimulus onset and button press, or consecutive eye-fixations), non-linear effects, and complex experimental designs. For a multitude of reasons, we often need to simulate such kinds of data: Simulated EEG data is useful to test preprocessing and analysis tools, validate statistical methods, illustrate conceptual issues, test toolbox functionalities, and find limitations of traditional analysis workflows. For instance, such simulation tools allow for testing the assumptions of new analysis algorithms and testing their robustness against any violation of these assumptions."},{"id":526,"pagetitle":"API / Docstrings","title":"UnfoldSim.AutoRegressiveNoise","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.AutoRegressiveNoise","content":" UnfoldSim.AutoRegressiveNoise  —  Type AutoRegressiveNoise <: AbstractNoise Not implemented. source"},{"id":527,"pagetitle":"API / Docstrings","title":"UnfoldSim.ExponentialNoise","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.ExponentialNoise","content":" UnfoldSim.ExponentialNoise  —  Type ExponentialNoise <: AbstractNoise Type for generating noise with exponential decay in AR spectrum. Tip: To manually create noise samples use the  simulate_noise  function. Warning With the current implementation we try to get exponential decay over the whole autoregressive (AR) spectrum, which is N samples (the total number of samples in the signal) long. This involves the inversion of a Cholesky matrix of size NxN matrix, which will need lots of RAM for non-trivial problems. Fields noiselevel = 1  (optional): Factor that is used to scale the noise. ν = 1.5  (optional): Exponential factor of AR decay \"nu\". Examples julia> noise = ExponentialNoise()\nExponentialNoise\n  noiselevel: Int64 1\n  ν: Float64 1.5\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(1), noise, 5)\n5-element Vector{Float64}:\n  -5.325200748641231\n  -3.437402125380177\n   2.7852625669058884\n  -1.5381022393382109\n -14.818799857226612 See also  PinkNoise ,  RedNoise ,  NoNoise ,  WhiteNoise . source"},{"id":528,"pagetitle":"API / Docstrings","title":"UnfoldSim.Hartmut","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.Hartmut","content":" UnfoldSim.Hartmut  —  Type Hartmut <: AbstractHeadmodel Type for accessing the HArtMuT model (Harmening et al., 2022), a head model which includes not only brain sources but also muscular and ocular sources. Note: Use  Hartmut()  to create an instance of this head model. Fields artefacual::Any : Dict with artefactual sources (e.g. muscular and ocular) containing label, leadfield, orientation and position. cortical::Any :  Dict with cortical sources containing label, leadfield, orientation and position. electrodes::Any : Dict with electrode labels and their positions in 3D space. Examples julia> h = Hartmut()\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\nHArtMuT-Headmodel\n227 electrodes:  (AF3,AF3h...) - hartmut.electrodes\n2004 source points: (Left Middle Temporal Gyrus, posterior division,...) - hartmut.cortical\n4260 source points: (Muscle_DepressorLabii_left,...) - hartmut.artefactual\n\nIn addition to UnfoldSim.jl please cite:\nHArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\n# Access artefactual sources\njulia> h.artefactual\nDict{String, Any} with 4 entries:\n  \"label\"       => [\"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Mu…\n  \"leadfield\"   => [-0.00148682 -0.00229078 … -0.307231 -0.321305; 0.0141537 0.0134523 … -0.141177 -0.140583; … ; 0.108747 0.1091 … 0.106614 0.117126; 0.0257134 0.0248186 … 0.00105064 -0.00433068;;; 0.0898798 0.0891799 … 2.02466 1.81…\n  \"orientation\" => [0.54244 0.482395 -0.687789; 0.546949 0.507161 -0.666059; … ; 0.193693 -0.979684 0.0519768; 0.327641 -0.944196 -0.0338583]\n  \"pos\"         => [-29.3728 58.6061 -120.829; -28.4183 59.0185 -121.448; … ; -21.8088 70.5968 -28.7679; -21.1545 70.1282 -31.4184] source"},{"id":529,"pagetitle":"API / Docstrings","title":"UnfoldSim.LinearModelComponent","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.LinearModelComponent","content":" UnfoldSim.LinearModelComponent  —  Type LinearModelComponent <: AbstractComponent A multiple regression component for one subject. All fields can be named. Works best with  SingleSubjectDesign . Fields basis::Any : an object, if accessed, provides a 'basis function', e.g.  hanning(40)::Vector , this defines the response at a single event. It will be weighted by the model prediction. Future versions will allow for functions, as of v0.3 this is restricted to array-like objects formula::Any : StatsModels  formula  object, e.g.   @formula 0 ~ 1 + cond  (left-hand side must be 0). β::Vector  Vector of betas/coefficients, must fit the formula. contrasts::Dict  (optional): Determines which coding scheme to use for which categorical variables. Default is empty which corresponds to dummy coding.    For more information see  https://juliastats.org/StatsModels.jl/stable/contrasts . Examples julia> LinearModelComponent(;\n           basis = hanning(40),\n           formula = @formula(0 ~ 1 + cond),\n           β = [1., 2.],\n           contrasts = Dict(:cond => EffectsCoding())\n       )\nLinearModelComponent\n  basis: Array{Float64}((40,)) [0.0, 0.006474868681043577, 0.02573177902642726, 0.0572719871733951, 0.10027861829824952, 0.1536378232452003, 0.21596762663442215, 0.28565371929847283, 0.3608912680417737, 0.43973165987233853  …  0.43973165987233853, 0.3608912680417737, 0.28565371929847283, 0.21596762663442215, 0.1536378232452003, 0.10027861829824952, 0.0572719871733951, 0.02573177902642726, 0.006474868681043577, 0.0]\n  formula: StatsModels.FormulaTerm{StatsModels.ConstantTerm{Int64}, Tuple{StatsModels.ConstantTerm{Int64}, StatsModels.Term}}\n  β: Array{Float64}((2,)) [1.0, 2.0]\n  contrasts: Dict{Symbol, EffectsCoding} See also  MixedModelComponent ,  MultichannelComponent . source"},{"id":530,"pagetitle":"API / Docstrings","title":"UnfoldSim.LogNormalOnset","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.LogNormalOnset","content":" UnfoldSim.LogNormalOnset  —  Type LogNormalOnset <: AbstractOnset Log-normal inter-event distances (in samples) using the  Distributions.jl  truncated LogNormal distribution ( code and mathematical reference ). Be careful with large  μ  and  σ  values, as they are on logscale. σ>8 can quickly give you out-of-memory sized signals!  Tip: To manually generate inter-event distance samples use the  simulate_interonset_distances  function. Fields μ : The mean of the log-transformed variable (the log-normal random variable's logarithm follows a normal distribution). σ : The standard deviation of the log-transformed variable. offset = 0  (optional): The minimal distance between events. truncate_upper = nothing  (optional): Upper limit (in samples) at which the distribution is truncated. Examples julia> onset_distribution = LogNormalOnset(3, 0.25, 10, 25)\nLogNormalOnset\n  μ: Int64 3\n  σ: Float64 0.25\n  offset: Int64 10\n  truncate_upper: Int64 25 See also  UniformOnset ,  NoOnset . source"},{"id":531,"pagetitle":"API / Docstrings","title":"UnfoldSim.MixedModelComponent","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.MixedModelComponent","content":" UnfoldSim.MixedModelComponent  —  Type MixedModelComponent <: AbstractComponent A component that adds a hierarchical relation between parameters according to a Linear Mixed Model (LMM) defined via  MixedModels.jl . All fields can be named. Works best with  MultiSubjectDesign . Fields basis::Any : an object, if accessed, provides a 'basis function', e.g.  hanning(40)::Vector , this defines the response at a single event. It will be weighted by the model prediction. Future versions will allow for functions, as of v0.3 this is restricted to array-like objects formula::Any : Formula-object in the style of MixedModels.jl e.g.  @formula 0 ~ 1 + cond + (1|subject) . The left-hand side is ignored. β::Vector  Vector of betas (fixed effects), must fit the formula. σs::Dict  Dict of random effect variances, e.g.  Dict(:subject => [0.5, 0.4])  or to specify correlation matrix  Dict(:subject=>[0.5,0.4,I(2,2)],...) . Technically, this will be passed to the MixedModels.jl  create_re  function, which creates the θ matrices. contrasts::Dict  (optional): Dict in the style of MixedModels.jl. Determines which coding scheme to use for which categorical variables. Default is empty which corresponds to dummy coding. For more information see  https://juliastats.org/StatsModels.jl/stable/contrasts . Examples julia> MixedModelComponent(;\n           basis = hanning(40),\n           formula = @formula(0 ~ 1 + cond + (1 + cond|subject)),\n           β = [1., 2.],\n           σs= Dict(:subject => [0.5, 0.4]),\n           contrasts=Dict(:cond => EffectsCoding())\n       )\nMixedModelComponent\n  basis: Array{Float64}((40,)) [0.0, 0.006474868681043577, 0.02573177902642726, 0.0572719871733951, 0.10027861829824952, 0.1536378232452003, 0.21596762663442215, 0.28565371929847283, 0.3608912680417737, 0.43973165987233853  …  0.43973165987233853, 0.3608912680417737, 0.28565371929847283, 0.21596762663442215, 0.1536378232452003, 0.10027861829824952, 0.0572719871733951, 0.02573177902642726, 0.006474868681043577, 0.0]\n  formula: StatsModels.FormulaTerm{StatsModels.ConstantTerm{Int64}, Tuple{StatsModels.ConstantTerm{Int64}, StatsModels.Term, StatsModels.FunctionTerm{typeof(|), Vector{StatsModels.AbstractTerm}}}}\n  β: Array{Float64}((2,)) [1.0, 2.0]\n  σs: Dict{Symbol, Vector{Float64}}\n  contrasts: Dict{Symbol, EffectsCoding} See also  LinearModelComponent ,  MultichannelComponent . source"},{"id":532,"pagetitle":"API / Docstrings","title":"UnfoldSim.MultiSubjectDesign","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.MultiSubjectDesign","content":" UnfoldSim.MultiSubjectDesign  —  Type MultiSubjectDesign <: AbstractDesign A type for specifying the experimental design for multiple subjects (based on the given random-effects structure). Tip: Check the resulting dataframe using the  generate_events  function.  Please note that the number of items  n_items  has to be a multiple of the number of between-item levels. The sample applies for  n_subjects  and the number of between-subject levels. Fields n_subjects::Int : Number of subjects. n_items::Int : Number of items/stimuli (sometimes ≈ trials). subjects_between::Dict{Symbol,Vector} : Effects between subjects, e.g. young vs old. items_between::Dict{Symbol,Vector} : Effects between items, e.g. natural vs artificial images, (but shown to all subjects if not specified also in  subjects_between ). both_within::Dict{Symbol,Vector} : Effects completely crossed i.e. conditions/covariates that are both within-subject and within-item. event_order_function = (rng, x) -> x : Can be used to sort, or shuffle the events e.g.  (rng, x) -> shuffle(rng, x)  (or shorter just  event_order_function = shuffle ).   The default is the identify function, i.e. not changing the order of the events. Examples # Declaring the same condition both between-subject and between-item results in a full between-subject/item design.\njulia> design = MultiSubjectDesign(;\n                       n_items = 10,\n                       n_subjects = 30,\n                       subjects_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n                       items_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n                       )\nMultiSubjectDesign\n  n_subjects: Int64 30\n  n_items: Int64 10\n  subjects_between: Dict{Symbol, Vector}\n  items_between: Dict{Symbol, Vector}\n  both_within: Dict{Symbol, Vector}\n  event_order_function: #3 (function of type UnfoldSim.var\"#3#7\")\n\njulia> generate_events(StableRNG(1), design)\n150×3 DataFrame\n Row │ subject  cond    item   \n     │ String   String  String \n─────┼─────────────────────────\n   1 │ S01      levelA  I01\n   2 │ S01      levelA  I03\n   3 │ S01      levelA  I05\n  ⋮  │    ⋮       ⋮       ⋮\n 148 │ S30      levelB  I06\n 149 │ S30      levelB  I08\n 150 │ S30      levelB  I10\n               144 rows omitted See also  SingleSubjectDesign ,  RepeatDesign source"},{"id":533,"pagetitle":"API / Docstrings","title":"UnfoldSim.MultichannelComponent","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.MultichannelComponent","content":" UnfoldSim.MultichannelComponent  —  Type MultichannelComponent <: AbstractComponent Projects a  AbstractComponent  to multiple \"channels\" via the  projection  vector. Optionally,  noise  can be added to the source prior to projection. By default a  MultichannelComponent  can be constructed using one of the following options for  projection : projection::AbstractVector : Directly pass a custom projection vector. projection::Pair{<:AbstractHeadmodel,String} : Generate a projection vector by specifying which headmodel to use and which sources should be active. Fields component::AbstractComponent : The component that should be projected to the sensors. projection::AbstractVector  or  projection::Pair{<:AbstractHeadmodel,String} : Vector  p  that projects the (source) component  c[t]  (where  t  is time) to the sensors  s .   The length of  p  equals the number of sensors  s . Typically, it is a slice of the leadfield matrix.  out[s,t] = p[s]*c[t] . noise::AbstractNoise  (optional): Noise added in the source space. Default is  NoNoise . Examples # Variant 1: Specify the projection vector manually\njulia> c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [1]);\n\njulia> mc1 = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1])\nMultichannelComponent\n  component: LinearModelComponent\n  projection: Array{Float64}((7,)) [1.0, 2.0, -1.0, 3.0, 5.0, 2.3, 1.0]\n  noise: NoNoise NoNoise()\n\n# Variant 2: Use a headmodel and specify a source\njulia> c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [1]);\n\njulia> hart = headmodel(type = \"hartmut\");\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\njulia> mc2 = UnfoldSim.MultichannelComponent(c2, hart => \"Right Occipital Pole\")\nMultichannelComponent\n  component: LinearModelComponent\n  projection: Array{Float64}((227,)) [-0.03461859471337842, -0.04321094803502425, 0.0037088347968313525, -0.014722528968861278, -0.0234889834534478, 0.02731807504242923, 0.038863688452528036, 0.1190531258070562, -0.09956890221613562, -0.0867729334438599  …  0.37435404409695094, -0.020863789022627935, 0.25627478723535513, -0.05777985212119245, 0.37104376432271147, -0.19446620423767172, 0.2590764703721097, -0.12923837607416555, 0.1732886690359311, 0.4703016561960567]\n  noise: NoNoise NoNoise() See also  LinearModelComponent ,  MixedModelComponent . source"},{"id":534,"pagetitle":"API / Docstrings","title":"UnfoldSim.NoNoise","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.NoNoise","content":" UnfoldSim.NoNoise  —  Type NoNoise <: AbstractNoise A type for simulations without noise; return zeros instead of noise. Tip: To manually create noise samples use the  simulate_noise  function. Examples julia> noise = NoNoise()\nNoNoise()\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(1), noise, 3)\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0 See also  PinkNoise ,  RedNoise ,  ExponentialNoise ,  WhiteNoise . source"},{"id":535,"pagetitle":"API / Docstrings","title":"UnfoldSim.NoOnset","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.NoOnset","content":" UnfoldSim.NoOnset  —  Type NoOnset <: AbstractOnset For cases where the user wants to simulate epoched data without any overlap between consecutive events. Examples julia> onset_distribution = NoOnset()\nNoOnset() See also  UniformOnset ,  LogNormalOnset . source"},{"id":536,"pagetitle":"API / Docstrings","title":"UnfoldSim.PinkNoise","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.PinkNoise","content":" UnfoldSim.PinkNoise  —  Type PinkNoise <: AbstractNoise A type for generating Pink Noise using the  SignalAnalysis.jl  implementation. The noise values are sampled from a standard normal distribution 𝒩(μ=0, σ=1). That means that ~95% of the values are between ~-2 and ~2 (with  noiselevel = 1 ). Tip: To manually create noise samples use the  simulate_noise  function. Fields noiselevel = 1  (optional): Factor that is used to scale the noise. func = SignalAnalysis.PinkGaussian  (optional): Function that is used to create the noise samples.   This field is for internal use and should not typically be modified directly by the user.   Changes to this field may result in unexpected behavior. Examples julia> noise = PinkNoise(noiselevel = 3)\nPinkNoise\n  noiselevel: Int64 3\n  func: UnionAll\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(1), noise, 5)\n5-element Vector{Float64}:\n 2.578878369756878\n 3.4972108606501786\n 2.878568584946028\n 2.2725654770788384\n 3.5291669151888683 See also  RedNoise ,  WhiteNoise ,  ExponentialNoise ,  NoNoise . source"},{"id":537,"pagetitle":"API / Docstrings","title":"UnfoldSim.RealisticNoise","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.RealisticNoise","content":" UnfoldSim.RealisticNoise  —  Type RealisticNoise <: AbstractNoise Not implemented - planned to use Artifacts.jl to provide real EEG data to add. source"},{"id":538,"pagetitle":"API / Docstrings","title":"UnfoldSim.RedNoise","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.RedNoise","content":" UnfoldSim.RedNoise  —  Type RedNoise <: AbstractNoise A type for generating Red Noise using the  SignalAnalysis.jl  implementation. The noise values are sampled from a standard normal distribution 𝒩(μ=0, σ=1). That means that ~95% of the values are between ~-2 and ~2 (with  noiselevel = 1 ). Tip: To manually create noise samples use the  simulate_noise  function. Fields noiselevel = 1  (optional): Factor that is used to scale the noise. func = SignalAnalysis.RedGaussian  (optional): Function that is used to create the noise samples.   This field is for internal use and should not typically be modified directly by the user.   Changes to this field may result in unexpected behavior. Examples julia> noise = RedNoise(noiselevel = 2)\nRedNoise\n  noiselevel: Int64 2\n  func: UnionAll\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(2), noise, 3)\n3-element Vector{Float64}:\n -0.34153942884005967\n -0.4651387715669636\n -0.4951538876376382 See also  PinkNoise ,  WhiteNoise ,  ExponentialNoise ,  NoNoise . source"},{"id":539,"pagetitle":"API / Docstrings","title":"UnfoldSim.RepeatDesign","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.RepeatDesign","content":" UnfoldSim.RepeatDesign  —  Type RepeatDesign{T} <: AbstractDesign Repeat a design (and the corresponding events DataFrame) multiple times to mimick repeatedly recorded trials. Tip: Check the resulting dataframe using the  generate_events  function. Please note that when using an  event_order_function (e.g.  shuffle ) in a  RepeatDesign , the corresponding RNG is shared across repetitions and not deep-copied for each repetition. As a result, the order of events will differ for each repetition. Fields design::T : The experimental design that should be repeated. repeat::Int = 1 : The number of repetitions. Examples julia> using StableRNGs # For using the `generate_events` function in a reproducible way\n\njulia> design_once =\n           SingleSubjectDesign(;\n               conditions = Dict(\n                   :stimulus_type => [\"natural\", \"artificial\"],\n                   :contrast_level => range(0, 1, length = 2),\n               ),\n               event_order_function = shuffle,\n           );\n\njulia> generate_events(StableRNG(1), design_once)\n4×2 DataFrame\n Row │ contrast_level  stimulus_type \n     │ Float64         String        \n─────┼───────────────────────────────\n   1 │            1.0  natural\n   2 │            1.0  artificial\n   3 │            0.0  natural\n   4 │            0.0  artificial\n\njulia> design = RepeatDesign(design_once, 2)\nRepeatDesign{SingleSubjectDesign}\n  design: SingleSubjectDesign\n  repeat: Int64 2\n\njulia> generate_events(StableRNG(1), design)\n8×2 DataFrame\n Row │ contrast_level  stimulus_type \n     │ Float64         String        \n─────┼───────────────────────────────\n   1 │            1.0  natural\n   2 │            1.0  artificial\n   3 │            0.0  natural\n   4 │            0.0  artificial\n   5 │            1.0  artificial\n   6 │            0.0  natural\n   7 │            1.0  natural\n   8 │            0.0  artificial See also  SingleSubjectDesign ,  MultiSubjectDesign source"},{"id":540,"pagetitle":"API / Docstrings","title":"UnfoldSim.Simulation","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.Simulation","content":" UnfoldSim.Simulation  —  Type Simulation A type to store all \"ingredients\" for a simulation including their parameters. Can either be created by the user or will be created automatically when calling the  simulate  function with the required \"ingredients\". Tip: Use the  subtypes  function to get an overview of the implemented \"ingredients\", e.g.  subtypes(AbstractDesign) . Fields design::AbstractDesign : Experimental design. components::Vector{AbstractComponent} : Response function(s) for the events (e.g. the ERP shape in EEG). onset::AbstractOnset : Inter-onset distance distribution. noisetype::AbstractNoise : Noise type. Examples julia> design = SingleSubjectDesign(; conditions = Dict(:stimulus_type => [\"natural\", \"artificial\"]));\n\njulia> component = LinearModelComponent(;\n           basis = p100(),\n           formula = @formula(0 ~ 1 + stimulus_type),\n           β = [2, 3],\n       );\n\njulia> onset = UniformOnset();\n\njulia> noise = PinkNoise();\n\njulia> simulation = Simulation(design, component, onset, noise);\n\njulia> using StableRNGs\n\njulia> data, events = simulate(StableRNG(1), simulation);\n\njulia> events\n2×2 DataFrame\n Row │ stimulus_type  latency \n     │ String         Int64   \n─────┼────────────────────────\n   1 │ natural             20\n   2 │ artificial          70\n\njulia> data\n85-element Vector{Float64}:\n  0.8596261232522926\n  1.1657369535500595\n  0.9595228616486761\n  ⋮\n  0.9925202143746904\n  0.2390652543395527\n -0.11672523788068771 source"},{"id":541,"pagetitle":"API / Docstrings","title":"UnfoldSim.SingleSubjectDesign","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.SingleSubjectDesign","content":" UnfoldSim.SingleSubjectDesign  —  Type SingleSubjectDesign <: AbstractDesign A type for specifying the experimental design for a single subject (based on the given conditions). Tip: Check the resulting dataframe using the  generate_events  function.  The number of trials/rows in the output of  generate_events([rng, ]design)  depends on the full factorial of your  conditions .  To increase the number of repetitions, e.g. by 5, simply use  RepeatDesign(SingleSubjectDesign(...), 5) .  If conditions are omitted (or set to  nothing ), a single trial is simulated with a column  :dummy  and content  :dummy  - this is for convenience. Fields conditions::Dict{Symbol,Vector} : Experimental conditions, e.g.  Dict(:A => [\"a_small\",\"a_big\"], :B => [\"b_tiny\",\"b_large\"]) . event_order_function = (rng, x) -> x : Can be used to sort by specifying  sort , or shuffling by providing  shuffle , or custom functions following the interface  (rng, x) -> my_shuffle(rng,x) .   The default is the identify function, i.e. not changing the order of the events. Examples julia> using StableRNGs # For using the `generate_events` function in a reproducible way\n\njulia> design =\n           SingleSubjectDesign(;\n               conditions = Dict(\n                   :stimulus_type => [\"natural\", \"artificial\"],\n                   :contrast_level => range(0, 1, length = 5),\n               ),\n           )\nSingleSubjectDesign\n  conditions: Dict{Symbol, Vector}\n  event_order_function: #10 (function of type UnfoldSim.var\"#10#14\")\n\njulia> generate_events(StableRNG(1), design)\n10×2 DataFrame\n Row │ contrast_level  stimulus_type \n     │ Float64         String        \n─────┼───────────────────────────────\n   1 │           0.0   natural\n   2 │           0.25  natural\n   3 │           0.5   natural\n  ⋮  │       ⋮               ⋮\n   8 │           0.5   artificial\n   9 │           0.75  artificial\n  10 │           1.0   artificial\n                       4 rows omitted See also  MultiSubjectDesign ,  RepeatDesign source"},{"id":542,"pagetitle":"API / Docstrings","title":"UnfoldSim.UniformOnset","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.UniformOnset","content":" UnfoldSim.UniformOnset  —  Type UniformOnset <: AbstractOnset Provide a Uniform Distribution for the inter-event distances (in samples). Tip: To manually generate inter-event distance samples use the  simulate_interonset_distances  function. Fields width = 50  (optional): Width of the uniform distribution (=> the \"jitter\"). Since the lower bound is 0,  width  is also the upper bound. offset = 0  (optional): The minimal distance between events. The maximal distance is  offset + width . Examples julia> onset_distribution = UniformOnset(width = 25, offset = 5)\nUniformOnset\n  width: Int64 25\n  offset: Int64 5 See also  LogNormalOnset ,  NoOnset . source"},{"id":543,"pagetitle":"API / Docstrings","title":"UnfoldSim.WhiteNoise","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.WhiteNoise","content":" UnfoldSim.WhiteNoise  —  Type WhiteNoise <: AbstractNoise A type for generating White Noise using  randn  - thus Gaussian noise. The noise values are sampled from a standard normal distribution 𝒩(μ=0, σ=1). That means that ~95% of the values are between ~-2 and ~2 (with  noiselevel = 1 ). Tip: To manually create noise samples use the  simulate_noise  function. Fields noiselevel = 1  (optional): Factor that is used to scale the noise. imfilter = nothing  (optional): Use  imfilter > 0  to smooth the noise using  Image.imfilter  with a Gaussian kernel with  σ = imfilter . Examples julia> noise = WhiteNoise()\nWhiteNoise\n  noiselevel: Int64 1\n  imfilter: Nothing nothing\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(1), noise, 3)\n3-element Vector{Float64}:\n -0.5325200748641231\n  0.098465514284785\n  0.7528865221245234 See also  PinkNoise ,  RedNoise ,  ExponentialNoise ,  NoNoise . source"},{"id":544,"pagetitle":"API / Docstrings","title":"Base.length","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#Base.length-Tuple{AbstractDesign}","content":" Base.length  —  Method Length is the product of all dimensions and equals the number of events in the corresponding events dataframe. source"},{"id":545,"pagetitle":"API / Docstrings","title":"Base.size","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#Base.size-Tuple{MultiSubjectDesign}","content":" Base.size  —  Method Return the dimensions of the experiment design. source"},{"id":546,"pagetitle":"API / Docstrings","title":"DSP.Windows.hanning","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#DSP.Windows.hanning-Tuple{Any, Any, Any}","content":" DSP.Windows.hanning  —  Method hanning(duration, offset, sfreq) Generate a (potentially shifted) hanning window with a certain duration.  Note: This function extends the  DSP.hanning  function using multiple dispatch. Arguments duration : in s. offset : in s, defines hanning peak i.e. shift of the hanning window. sfreq : Sampling rate in Hz. Returns Vector : Contains a shifted (i.e. zero-padded) hanning window. Examples julia> UnfoldSim.hanning(0.1, 0.3, 100)\n25-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.9698463103929542\n 0.75\n 0.41317591116653485\n 0.11697777844051105\n 0.0 source"},{"id":547,"pagetitle":"API / Docstrings","title":"UnfoldSim.PuRF","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.PuRF-Tuple{}","content":" UnfoldSim.PuRF  —  Method PuRF(; n = 10.1, tmax = 0.93, sfreq = 100) Default generator for PuRF Pupil Response Function. The canonical PRF is a gamma function and implemented according to Denison 2020 equation (2) going back to Hoeks & Levelt, 1993. The pupil response is evaluated at t = 0:1/sfreq:3*tmax. The response is normalized by the peak-maximum at tmax, thus typically a pupil-response of 1 is returned (disregarding numerical issues). Keyword arguments: n = 10.1 : shape parameter tmax = 0.93 : peak maximum sfreq = 100 : sampling frequency Returns Vector : canonical pupil response with length(0:1/sfreq:3*tmax) entries. Examples julia> PuRF(; n = 5)\n280-element Vector{Float64}:\n 0.0\n 2.0216617815131253e-8\n 6.130689396024061e-7\n 4.4118063684811444e-6\n 1.761817666835793e-5\n ⋮\n 0.012726253506722554\n 0.012280989091455786\n 0.011850525657416842\n 0.011434405338911133\n 0.011032182932283816 source"},{"id":548,"pagetitle":"API / Docstrings","title":"UnfoldSim.add_noise!","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.add_noise!-Tuple{Any, AbstractNoise, Any}","content":" UnfoldSim.add_noise!  —  Method add_noise!(rng, noisetype::AbstractNoise, signal) Generate and add noise to a signal. Assumes that the signal can be linearized, that is, that the noise is stationary. source"},{"id":549,"pagetitle":"API / Docstrings","title":"UnfoldSim.add_responses!","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.add_responses!-Tuple{Any, Vector, Vararg{Any, 4}}","content":" UnfoldSim.add_responses!  —  Method add_responses!(signal, responses::Vector, e, s, tvec, trial_idx)\nadd_responses!(signal, responses::Matrix, e, s, tvec, trial_idx)\nadd_responses!(signal, responses::AbstractArray, e, s, tvec, trial_idx) Add (in-place) the given  responses  to the  signal , for both 2D (1 channel) and 3D (X channel case). Helper function. Arguments signal : Continuous EEG signal to be modified in place. Has the dimensions  channels x continuous_time x subjects . responses::Union{Vector, Matrix, AbstractArray} : Responses to be added. In the multi-channel case, the dimensions are  channels x maxlength(components) x length(simulation.design) , else  maxlength(components) x length(simulation.design) .  The data for all the subjects and their respective trials is concatenated. e : Index of the channel (in  signal ) for which to add the response. s : Index of the subject (in  signal ) for which to add the response. tvec : Time points (indices in  signal ) at which to add the response. trial_idx : Index of the particular trial (in  responses ) from where the response is to be added. Returns Nothing :  signal  is modified in-place. Examples julia> signal, responses, tvec = zeros(5,15,2), ones(5,6), 1:5;\n\njulia> UnfoldSim.add_responses!(signal, responses, 1, 2, tvec, 5);\n\njulia> signal\n5×15×2 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n[:, :, 2] =\n 1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 source"},{"id":550,"pagetitle":"API / Docstrings","title":"UnfoldSim.apply_event_order_function","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.apply_event_order_function-Tuple{Any, Any, Any}","content":" UnfoldSim.apply_event_order_function  —  Method apply_event_order_function(fun, rng, events) Apply  fun(rng, events) , raise an error if function  fun  is wrongly defined. Convenience function to not repeat the error handling at multiple places. source"},{"id":551,"pagetitle":"API / Docstrings","title":"UnfoldSim.closest_src","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.closest_src-Tuple{AbstractVector{<:AbstractVector}, Any}","content":" UnfoldSim.closest_src  —  Method closest_src(coords_list::AbstractVector{<:AbstractVector}, pos) When applied to a vector of target coordinate vectors, return the index of the closest position in  pos  for each of the targets.  Returns Vector : Index of the closest position in  pos  for each vector in  coords_list . Examples julia> positions = [0 0 0; 2 2 2; 3 3 3; 4 4 4];\njulia> target_coordinate_vectors = [[0.5, 0, 0.5], [10, 1, 8]];\n\njulia> UnfoldSim.closest_src(target_coordinate_vectors, positions)\n2-element Vector{Int64}:\n 1\n 4 source"},{"id":552,"pagetitle":"API / Docstrings","title":"UnfoldSim.closest_src","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.closest_src-Tuple{Hartmut, String}","content":" UnfoldSim.closest_src  —  Method closest_src(head::Hartmut, label::String) Return the index of the Harmut model source point that is closest (using Euclidean distance) to the mean position of the source points matching the given  label . Important We use the average in Euclidean space, but the cortex is a curved surface. In most cases they will not overlap. Ideally we would calculate the average on the surface, but this is a bit more complex to do (you'd need to calculate the vertices etc.). Arguments head::Hartmut : Headmodel of type  Hartmut . label::String : Label of the source point(s) of interest. Returns Int : Index of the closest Hartmut source point. Examples julia> hartmut = Hartmut();\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\njulia> label = \"Right Cingulate Gyrus, posterior division\";\n\njulia> UnfoldSim.closest_src(hartmut, label)\n1875 source"},{"id":553,"pagetitle":"API / Docstrings","title":"UnfoldSim.closest_src","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.closest_src-Tuple{Vector{<:Real}, Any}","content":" UnfoldSim.closest_src  —  Method closest_src(coords::Vector{<:Real}, pos) Return the index of the position that is closest to the target coordinates (using the Euclidean distance). Arguments coords::Vector{<:Real} : Target coordinate vector (typically with length 3). pos : Matrix that contains all possible positions.   Its dimensions are the number of positions  n  times number of entries in the position coordinate vectors (usually 3) i.e.  n x 3 . Returns Int : Row index of the position in  pos  that is closest to  coords . Examples julia> positions = [0 0 0; 2 2 2; 3 3 3; 4 4 4]\n4×3 Matrix{Int64}:\n 0  0  0\n 2  2  2\n 3  3  3\n 4  4  4\n\njulia> target_coordinates = [0.5, 0, 0.5]\n3-element Vector{Float64}:\n 0.5\n 0.0\n 0.5\n\n julia> UnfoldSim.closest_src(target_coordinates, positions)\n1 source"},{"id":554,"pagetitle":"API / Docstrings","title":"UnfoldSim.create_continuous_signal","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.create_continuous_signal-Tuple{Any, Any, Any}","content":" UnfoldSim.create_continuous_signal  —  Method create_continuous_signal(rng, responses, simulation) Simulate onset latencies and add together a continuous signal, based on the given responses and simulation parameters. Helper function. Arguments rng : Random number generator, important to ensure reproducibility. responses : Responses to be combined with the given onsets. simulation : Simulation parameters, including design, components, onsets, and noisetype. Returns (signal, latencies)::Tuple{Array, Array} : signal  contains the generated signal. Has the dimensions  channels x continuous_time x subjects . latencies  contains the onset latencies. Examples julia> using StableRNGs # to get an RNG\n\njulia> design = SingleSubjectDesign(; conditions = Dict(:cond => [\"natural\", \"artificial\"]));\n\njulia> c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), β = [1, 0.5]);\n\njulia> c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [2]);\n\njulia> simulation = Simulation(design, [c1, c2], UniformOnset(; width = 0, offset = 30), PinkNoise());\n\njulia> responses = simulate_responses(StableRNG(1), [c1, c2], simulation)\n45×2 Matrix{Float64}:\n 0.0        0.0\n 0.0        0.0\n ⋮          \n 0.0233794  0.0233794\n 0.0        0.0\n\njulia> signal, latencies = UnfoldSim.create_continuous_signal(StableRNG(1), responses, simulation);\n\njulia> signal\n106-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n ⋮\n 0.023379444289913343\n 0.0\n 0.0\n\n julia> latencies\n2-element Vector{Int64}:\n 31\n 61 source"},{"id":555,"pagetitle":"API / Docstrings","title":"UnfoldSim.epoch","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.epoch-Tuple{AbstractVector, Vararg{Any}}","content":" UnfoldSim.epoch  —  Method epoch(data::AbstractVector, args...; kwargs...) One channel case. The data is reshaped and then passed to the multi-channel epoch method. source"},{"id":556,"pagetitle":"API / Docstrings","title":"UnfoldSim.epoch","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.epoch-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Tuple{Number, Number}, Any}} where T<:Union{Missing, Number}","content":" UnfoldSim.epoch  —  Method epoch(\n    data::AbstractArray{T,2},\n    events,\n    τ::Tuple{Number,Number},\n    sfreq;\n    eventtime::Symbol = :latency,\n) where {T<:Union{Missing,Number}} Helper function to segment continuous  data  into epochs based on the given  events  and the time window  τ . Adapted from Unfold.jl: https://github.com/unfoldtoolbox/Unfold.jl/blob/b3  a21c2bb7e93d2f45ec64b0197f4663a6d7939a/src/utilities.jl#L40 Arguments data::AbstractArray{T,2} : Continuous data with the dimensions  channels x continuous_time . events : Events data frame (based on the design) with latencies. τ::Tuple{Number,Number} : Time window for epoching in s. sfreq : Sampling frequency in Hz. Keyword arguments eventtime::Symbol = :latency : The name of the column in  events  that contains the latencies. Returns Array : Epoched data with the dimensions  channels x times x event  (or  times x event  for the single channel case). Examples # One channel example\njulia> data, events = UnfoldSim.predef_eeg();\n\njulia> size(data), size(events)\n((120199,), (2000, 3))\n\njulia> UnfoldSim.epoch(data, events, (-0.2, 1), 100)\n121×2000 Matrix{Float64}:\n  0.114127   -0.105347     …  -0.125485   1.6383\n  0.128198    0.0474874        0.0112935  1.28122\n  0.0547917  -0.0832977       -0.126181   0.850062\n  0.0992842  -0.230224        -0.0449072  0.496583\n  0.024461   -0.175023        -0.0223837  0.170389\n  0.165133   -0.000793527  …  -0.0278197  0.104454\n  ⋮                        ⋱              \n -0.362249    2.91297          0.546699   0.0\n -0.199265    2.58394          0.171159   0.0\n -0.184075    2.34611         -0.0269841  0.0\n -0.13901     2.11971         -0.0552873  0.0\n -0.0674085   1.74561      …  -0.187959   0.0 source"},{"id":557,"pagetitle":"API / Docstrings","title":"UnfoldSim.generate_events","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.generate_events","content":" UnfoldSim.generate_events  —  Function generate_events(design::AbstractDesign)\ngenerate_events(rng::AbstractRNG, design::AbstractDesign) Generate a full-factorial events DataFrame based on the experimental conditions and covariates defined in the design. Arguments design::AbstractDesign : Experimental design for which the events DataFrame should be created. rng::AbstractRNG  (optional): Random number generator (RNG) to make the process reproducible. If none is given,  MersenneTwister(1)  will be used. Returns DataFrame : Each row corresponds to one combination of condition/covariate levels which is often equivalent to one stimulus or trial. source"},{"id":558,"pagetitle":"API / Docstrings","title":"UnfoldSim.generate_events","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, MultiSubjectDesign}","content":" UnfoldSim.generate_events  —  Method generate_events(design::MultiSubjectDesign)\ngenerate_events(rng::AbstractRNG, design::MultiSubjectDesign) Generate the events Dataframe according to  MixedModelsSim.jl 's  simdat_crossed  function. Afterwards apply  design.event_order_function  and finally sort by  :subject .  Note: No condition can be named  dv  which is used internally in MixedModelsSim / MixedModels as a dummy left-side Examples julia> using Random # for shuffling\njulia> using StableRNGs\n\njulia> design = MultiSubjectDesign(;\n                       n_items = 4,\n                       n_subjects = 5,\n                       both_within = Dict(:condition => [\"red\", \"green\"]),\n                       event_order_function = shuffle,\n                       );\n\njulia> generate_events(StableRNG(1), design)\n40×3 DataFrame\n Row │ subject  item    condition \n     │ String   String  String    \n─────┼────────────────────────────\n   1 │ S1       I2      red\n   2 │ S1       I2      green\n   3 │ S1       I3      green\n  ⋮  │    ⋮       ⋮         ⋮\n  38 │ S5       I3      red\n  39 │ S5       I2      red\n  40 │ S5       I4      green\n                   34 rows omitted source"},{"id":559,"pagetitle":"API / Docstrings","title":"UnfoldSim.generate_events","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, RepeatDesign}","content":" UnfoldSim.generate_events  —  Method UnfoldSim.generate_events([rng::AbstractRNG, ]design::RepeatDesign{T}) For a  RepeatDesign , iteratively call  generate_events  for the underlying {T} design and concatenate the results. In case of  MultiSubjectDesign , sort by subject.  Please note that when using an  event_order_function (e.g.  shuffle ) in a  RepeatDesign , the corresponding RNG is shared across repetitions and not deep-copied for each repetition. As a result, the order of events will differ for each repetition. source"},{"id":560,"pagetitle":"API / Docstrings","title":"UnfoldSim.generate_events","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, SingleSubjectDesign}","content":" UnfoldSim.generate_events  —  Method generate_events(design::SingleSubjectDesign)\ngenerate_events(rng::AbstractRNG, design::SingleSubjectDesign) Generate the events DataFrame based on  design.conditions  and afterwards apply  design.event_order_function . If  design.conditions  is  nothing , a single trial is simulated with a column  :dummy  and content  :dummy  - this is for convenience. Examples julia> using Random # for shuffling\njulia> using StableRNGs\n\njulia> design = SingleSubjectDesign(;\n           conditions = Dict(:A => [\"small\", \"large\"], :B => range(1, 5, length = 3)),\n           event_order_function = shuffle,\n       );\n\n# Variant 1: Without specifying an RNG, MersenneTwister(1) will be used for the shuffling specified as `event_order_function`.\njulia> generate_events(design)\n6×2 DataFrame\n Row │ A       B       \n     │ String  Float64 \n─────┼─────────────────\n   1 │ large       5.0\n   2 │ large       1.0\n   3 │ large       3.0\n   4 │ small       1.0\n   5 │ small       3.0\n   6 │ small       5.0\n\n# Variant 2: Use a custom RNG.\njulia> generate_events(StableRNG(1), design)\n6×2 DataFrame\n Row │ A       B       \n     │ String  Float64 \n─────┼─────────────────\n   1 │ large       5.0\n   2 │ large       3.0\n   3 │ small       1.0\n   4 │ small       3.0\n   5 │ large       1.0\n   6 │ small       5.0 source"},{"id":561,"pagetitle":"API / Docstrings","title":"UnfoldSim.hartmut_citation","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.hartmut_citation-Tuple{}","content":" UnfoldSim.hartmut_citation  —  Method Return the citation string for HArtMuT. source"},{"id":562,"pagetitle":"API / Docstrings","title":"UnfoldSim.hrf","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.hrf-Tuple{}","content":" UnfoldSim.hrf  —  Method hrf(;\nTR = 1,\npeak = 6.0,\npost_undershoot = 16,\nlength = 32.0,\npeak_width = 1.0,\npost_undershoot_width = 1,\namplitude = 6,\nshift = 0) Generate a parameterized BOLD haemodynamic response function (HRF) kernel based on gamma-functions. Implementation and default parameters were taken from the SPM-toolbox. Note: TR = 1/sfreq Keyword arguments TR = 1 : repetition time, 1/sfreq. length = 32.0 : total length of the kernel in seconds. amplitude = 6 : maximal amplitude. peak = 6.0 : peak timing. peak_width = 1.0 : width of the peak. post_undershoot = 16 : post-undershoot timing. post_undershoot_width = 1 : post-undershoot width. shift = 0 : shift the whole HRF. Returns Vector : HRF BOLD response. Examples julia> hrf()\n33-element Vector{Float64}:\n  0.0\n  0.0007715994433635659\n  0.019784004131204957\n  0.08202939459091822\n  0.158157713522699\n  ⋮\n -0.0006784790038792572\n -0.00042675060451877775\n -0.000263494738348278\n -0.00015990722628360688\n -9.548780093799345e-5 source"},{"id":563,"pagetitle":"API / Docstrings","title":"UnfoldSim.leadfield","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.leadfield-Tuple{Hartmut}","content":" UnfoldSim.leadfield  —  Method leadfield(hart::Hartmut; type = \"cortical\") Return the leadfield for the (cortical or artefacual) sources of the HArtMuT model. Keyword arguments type = \"cortical\" : Defines whether the \"cortical\" or \"artefactual\" leadfield should be returned. Returns Array{Float64, 3} : Leadfield values i.e. how much each source contributes to the potential measured at each electrode.   The output dimensions are  electrodes x sources x spatial dimension . Examples julia> h = Hartmut();\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\njulia> lf = leadfield(h);\n\njulia> size(lf)\n(227, 2004, 3)\n\n# Access the leadfield for one spatial dimension\njulia> lf[:,:,1]\n227×2004 Matrix{Float64}:\n  0.151429    0.0284341  …  -0.119927     -0.158114\n  0.1732      0.0441432     -0.110515     -0.165316\n  0.249592    0.10857       -0.000593027  -0.0206122\n  0.245206    0.104854      -0.0200251    -0.055392\n  0.126496    0.0118467     -0.128248     -0.146107\n  0.253092    0.111688   …   0.02277       0.0184387\n  ⋮                      ⋱                \n  0.20306     0.138837       0.133486      0.18334\n -0.689154   -1.00904       -0.108276     -0.105398\n  0.192729    0.148448       0.0924756     0.142322\n -1.26181    -1.59936       -0.140598     -0.133054\n  0.213982    0.145953   …   0.115515      0.170698\n  0.0731569   0.0794415      0.0485819     0.107929 source"},{"id":564,"pagetitle":"API / Docstrings","title":"UnfoldSim.magnitude","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.magnitude-Tuple{AbstractHeadmodel}","content":" UnfoldSim.magnitude  —  Method magnitude(headmodel::AbstractHeadmodel) Return the magnitude for the given  headmodel  based on the leadfield (and potentially the source orientations) specified in the  headmodel . If the  headmodel  includes source orientations these are used in the calculations, otherwise the  leadfield  is returned assuming that the source orientations are already included. Please note that (at least in the case of the HArtMuT model) the leadfield for the cortical sources is used. Returns Matrix{Float64} : Contribution of each source to the potential measured at each electrode taking into account the orientation of the sources.   The output dimensions are  electrodes x sources . Examples # Using the HArtMut model as an example\njulia> h = Hartmut();\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\njulia> magnitude(h)\n227×2004 Matrix{Float64}:\n  0.111706   …   0.301065\n  0.0774359      0.332934\n  ⋮          ⋱  \n -0.164539      -0.246555 source"},{"id":565,"pagetitle":"API / Docstrings","title":"UnfoldSim.magnitude","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.magnitude-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}}} where T<:Real","content":" UnfoldSim.magnitude  —  Method magnitude(lf::AbstractArray{T,3}, orientation::AbstractArray{T,2}) where {T<:Real} Return the magnitude of the leadfield  lf  along the given  orientation . Arguments lf::AbstractArray{T,3} : Leadfield with the dimensions  electrodes x sources x spatial dimension . orientation::AbstractArray{T,2} : Source orientations with the dimensions  sources x spatial dimensions . Examples # Specify the leadfield (often given by a headmodel)\njulia> lf = cat([1 0; 0 1; 0 0], [1 1; 0 0; 0.5 0.5], dims=3);\n\n# Specify the source orientations\njulia> ori = [1.0 0; 0 1]\n\n# Calculate the magnitude\njulia> magnitude(lf, ori)\n3×2 Matrix{Float64}:\n 1.0  1.0\n 0.0  0.0\n 0.0  0.5 source"},{"id":566,"pagetitle":"API / Docstrings","title":"UnfoldSim.maxlength","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.maxlength-Tuple{Vector{<:AbstractComponent}}","content":" UnfoldSim.maxlength  —  Method maxlength(c::Vector{<:AbstractComponent}) = maximum(length.(c)) Return the maximum of the individual components' lengths. source"},{"id":567,"pagetitle":"API / Docstrings","title":"UnfoldSim.n170","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.n170-Tuple{}","content":" UnfoldSim.n170  —  Method n170(; sfreq = 100) Generate a Hanning window mimicking an N170 EEG component with a negative (!) peak at 170ms and a width of 150ms. Keyword arguments sfreq = 100 : Sampling frequency in Hz. Returns Vector : Contains a shifted (i.e. zero-padded) hanning window. Examples julia> n170(; sfreq = 120)\n28-element Vector{Float64}:\n -0.0\n -0.0\n -0.0\n -0.0\n -0.0\n  ⋮\n -0.45386582026834904\n -0.2771308221117309\n -0.1304955413896705\n -0.03376388529782215\n -0.0 See also  p100 ,  p300 ,  n400 ,  hanning . source"},{"id":568,"pagetitle":"API / Docstrings","title":"UnfoldSim.n400","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.n400-Tuple{}","content":" UnfoldSim.n400  —  Method n400(; sfreq = 100) Generate a Hanning window mimicking an N400 EEG component with a negative (!) peak at 400ms and a width of 400ms. Keyword arguments sfreq = 100 : Sampling frequency in Hz. Returns Vector : Contains a shifted (i.e. zero-padded) hanning window. Examples julia> n400(; sfreq = 250)\n150-element Vector{Float64}:\n -0.0\n -0.0\n -0.0\n -0.0\n -0.0\n  ⋮\n -0.016025649301821876\n -0.009035651368646647\n -0.00402259358460233\n -0.0010066617640578368\n -0.0 See also  p100 ,  p300 ,  n170 ,  hanning . source"},{"id":569,"pagetitle":"API / Docstrings","title":"UnfoldSim.n_channels","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.n_channels-Tuple{AbstractComponent}","content":" UnfoldSim.n_channels  —  Method n_channels(c::AbstractComponent) Return the number of channels for the given component  c . By default = 1. source"},{"id":570,"pagetitle":"API / Docstrings","title":"UnfoldSim.n_channels","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.n_channels-Tuple{MultichannelComponent}","content":" UnfoldSim.n_channels  —  Method n_channels(c::MultichannelComponent) For  MultichannelComponent  return the length of the projection vector. source"},{"id":571,"pagetitle":"API / Docstrings","title":"UnfoldSim.n_channels","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.n_channels-Tuple{Vector{<:AbstractComponent}}","content":" UnfoldSim.n_channels  —  Method n_channels(c::Vector{<:AbstractComponent}) For a vector of  MultichannelComponent s, return the number of channels for the first component but assert all are of equal length. source"},{"id":572,"pagetitle":"API / Docstrings","title":"UnfoldSim.orientation","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.orientation-Tuple{Hartmut}","content":" UnfoldSim.orientation  —  Method orientation(hart::Hartmut; type = \"cortical\") Return the orientations of the (cortical or artefacual) sources of the HArtMuT model.  The norm of the orientation vectors is 1 and the values are between -1 and 1. Keyword arguments type = \"cortical\" : Defines whether the \"cortical\" or \"artefactual\" orientations should be returned. Returns Matrix{Float64} : Orientations in 3D space. The output dimensions are  sources x spatial dimensions . Examples julia> h = Hartmut();\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\njulia> orientation(h)\n2004×3 Matrix{Float64}:\n -0.921919   0.364292   0.131744\n -0.900757  -0.415843  -0.125345\n -0.954087   0.117479  -0.27553\n -0.814613  -0.55344    0.17352\n -0.790526   0.276849  -0.546281\n  ⋮                    \n -0.962905   0.20498   -0.17549\n -0.828358   0.557468  -0.0552498\n -0.963785  -0.265607  -0.0239074\n -0.953909   0.203615   0.22045\n -0.75762    0.128027   0.640016 source"},{"id":573,"pagetitle":"API / Docstrings","title":"UnfoldSim.p100","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.p100-Tuple{}","content":" UnfoldSim.p100  —  Method p100(; sfreq = 100) Generate a Hanning window mimicking a P100 EEG component with a peak at 100ms and a width of 100ms. Keyword arguments sfreq = 100 : Sampling frequency in Hz. Returns Vector : Contains a shifted (i.e. zero-padded) hanning window. Examples julia> p100(; sfreq = 200)\n30-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.37725725642960045\n 0.22652592093878665\n 0.10542974530180327\n 0.02709137914968268\n 0.0 See also  p300 ,  n170 ,  n400 ,  hanning . source"},{"id":574,"pagetitle":"API / Docstrings","title":"UnfoldSim.p300","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.p300-Tuple{}","content":" UnfoldSim.p300  —  Method p300(; sfreq = 100) Generate a Hanning window mimicking a P300 EEG component with a peak at 300ms and a width of 300ms. Keyword arguments sfreq = 100 : Sampling frequency in Hz. Returns Vector : Contains a shifted (i.e. zero-padded) hanning window. Examples julia> p300(; sfreq = 150)\n67-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.07937323358440934\n 0.04518400232274078\n 0.02025351319275137\n 0.005089279059533658\n 0.0 See also  p100 ,  n170 ,  n400 ,  hanning . source"},{"id":575,"pagetitle":"API / Docstrings","title":"UnfoldSim.pad_array","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.pad_array-Tuple{Vector, Tuple, Any}","content":" UnfoldSim.pad_array  —  Method pad_array(arr::Vector, len::Int, val)    \npad_array(arr::Vector, len::Tuple, val) Pads the input array  arr  with a specified value  val  either before or after the existing elements, based on the sign of  len . Arguments arr::Vector : The input array to be padded. len::Union{Int, Tuple} : The number of times that  val  should be added.   If  len  is negative, the values are added before the existing array. Otherwise, they are added after the existing array.   If  len  is a tuple,  pad_array  is called twice which enables padding the array before and after in one function call. val : The value to be used for padding. Returns Vector : Padded vector with the new length  length(arr) + sum(abs.(len)) . Examples # Create an array that will be padded\njulia> my_array = rand(5)\n5-element Vector{Float64}:\n 0.0420017254437951\n 0.19179144973603235\n 0.5388760239550549\n 0.6973699906283798\n 0.9966598131018376\n\n # Pad the array with zeros before the original array\njulia> pad_array(my_array, -2, 0)\n7-element Vector{Float64}:\n 0.0\n 0.0\n 0.0420017254437951\n 0.19179144973603235\n 0.5388760239550549\n 0.6973699906283798\n 0.9966598131018376\n\n# Pad the array with the value 5 before and after the original array\njulia> pad_array(my_array, (-2, 1), 5)\n8-element Vector{Float64}:\n 5.0\n 5.0\n 0.0420017254437951\n 0.19179144973603235\n 0.5388760239550549\n 0.6973699906283798\n 0.9966598131018376\n 5.0 source"},{"id":576,"pagetitle":"API / Docstrings","title":"UnfoldSim.predef_2x2","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.predef_2x2-Tuple{Random.AbstractRNG}","content":" UnfoldSim.predef_2x2  —  Method predef_2x2(rng::AbstractRNG; <keyword arguments>) Simulate data for a 2x2 design i.e. a design with two conditions with two levels each. Note that this function is mainly used for demonstration and internal testing purposes or whenever a quick simulation is needed.  The most used keyword argument is:  return_epoched = true  which returns already epoched data. If you want epoched data without overlap, specify  onset = NoOnset()  and  return_epoched = true .  Be careful if you modify  n_items  with  n_subjects = 1 ,  n_items  has to be a multiple of 4 (or your equivalent conditions factorial, e.g. all combinations length). In difference to  predef_EEG ,  predef_2x2  is sample based (no sampling rate to be specified), and also has a 2x2 design, instead of a 2-categorical, 1-continuous design. Keyword arguments Design n_items = 100 : Number of items. n_subjects = 1 : Number of subjects. conditions = Dict(:A => [\"a_small\",\"a_big\"], :B => [\"b_tiny\",\"b_large\"]) : Experimental conditions with their levels. event_order_function = shuffle : Random trial order. Component / Signal signalsize = 100 : Length of simulated hanning window. basis = hanning(signalsize) : The actual \"function\".  signalsize  is only used here. β = [1, -0.5, .5, +1] : The parameters for the fixed effects. σs = Dict(:subject => [1, 0.5, 0.5, 0.5],:item => [1]) : Only needed in n_subjects >= 2 cases; specifies the random effects. contrasts = Dict(:A => EffectsCoding(), :B => EffectsCoding()) : Effect coding by default. formula = n_subjects == 1 ? @formula(0 ~ 1 + A*B) : @formula(dv ~ 1 + A*B + (A*B|subject) + (1|item)) : Model formula with interaction. Onset overlap = (0.5,0.2) , onset = UniformOnset(; offset = signalsize * overlap[1], width = signalsize * overlap[2]) , # Put offset to 1 for no overlap. put width to 0 for no jitter Noise noiselevel = 0.2 . noise = PinkNoise(; noiselevel = noiselevel) . Other parameters return_epoched = false : If true, already epoched data is returned. Otherwise, continuous data is returned. Returns (data, events)::Tuple{Array, DataFrame} :  data  contains the simulated EEG data. Its dimensionality depends on the status of  return_epoched  and whether n subjects >=2: `continuous time , continuous time x n subjects , times x size(design)[1] or times x size(design)[1] x n_subjects`.  events  contains the event combinations based on the experimental design. Each row corresponds to one combination of condition levels which is often equivalent to one stimulus or trial. Examples julia> data, events = UnfoldSim.predef_2x2();\n\njulia> events\n100×3 DataFrame\n Row │ A        B        latency \n     │ String   String   Int64   \n─────┼───────────────────────────\n   1 │ a_small  b_large       62\n   2 │ a_big    b_tiny       132\n  ⋮  │    ⋮        ⋮        ⋮\n  99 │ a_big    b_large     5883\n 100 │ a_big    b_tiny      5935\n                  96 rows omitted\n\njulia> data\n6035-element Vector{Float64}:\n  0.32384561187165956\n  0.4108799249488322\n  0.4715514814540277\n  0.5936253009785152\n  ⋮\n  0.047664408295942984\n  0.051193074728432035\n -0.08951617593287822\n -0.14456000097460356 See also  predef_eeg . source"},{"id":577,"pagetitle":"API / Docstrings","title":"UnfoldSim.predef_eeg","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.predef_eeg-Tuple{Any}","content":" UnfoldSim.predef_eeg  —  Method predef_eeg(; <keyword arguments>)\npredef_eeg(rng; <keyword arguments>)\npredef_eeg(rng, n_subjects; <keyword arguments>) Simulate data for a P1/N1/P3 component complex. Note that this function is mainly used for demonstration and internal testing purposes or whenever a quick simulation is needed.  In case  n_subjects  is defined -  MixedModelComponents  are generated (multi-subject simulation), else  LinearModelComponents  (single-subject simulation).  The most used keyword argument is:  return_epoched = true  which returns already epoched data. If you want epoched data without overlap, specify  onset = NoOnset()  and  return_epoched = true . Keyword arguments Design n_repeats = 100 : Number of times the experimental design is repeated. Only used in the single-subject case. n_items = 100 : Number of items. Only used in the multi-subject case. event_order_function = shuffle : Random trial order. Use  event_order_function = (rng, x) -> x  to deactivate. conditions = Dict(:condition => [\"car\", \"face\"], :continuous => range(-5, 5, length = 10)) : Conditions and covariates used in this predefined design. Component / Signal sfreq = 100 : Sampling frequency. p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()) : P1 with amplitude 5; no effects. n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 3], Dict()) : N1 with amplitude 5, dummy-coded condition effect (levels \"car\", \"face\") of 3. p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1 + continuous), [5, 1], Dict()) : P3 with amplitude 5, continuous effect range [-5,5] with slope 1. Onset overlap = (0.5,0.2) , # convenient parameterization for the default  onset::UniformOnset . ( offset ,  width ) in seconds. If you do not want any overlap, either use  onset=NoOnset() , or put the offset to a value larger than the maximum used component length, e.g.  overlap=(1,0.2) . Put the  width  to  0  to have no jitter between events. onset = UniformOnset(; offset = sfreq * 0.5 * overlap[1], width = sfreq * 0.5 * overlap[2]) ,  Noise noiselevel = 0.2 . noise = PinkNoise(; noiselevel = noiselevel) . Other parameters return_epoched = false : If true, already epoched data is returned. Otherwise, continuous data is returned. Returns (data, events)::Tuple{Array, DataFrame} :  data  contains the simulated EEG data. Its dimensionality depends on the status of  return_epoched  and whether it's a single- or multisubject simulation (1D, 2D or 3D array):  continuous_time ,  continuous_time x n_subjects ,  times x size(design)[1]  or  times x size(design)[1] x n_subjects .  events  contains the event combinations based on the experimental design. Each row corresponds to one combination of condition/covariate levels which is often equivalent to one stimulus or trial. Examples julia> data, events = UnfoldSim.predef_eeg();\n\njulia> events\n2000×3 DataFrame\n  Row │ continuous  condition  latency \n      │ Float64     String     Int64   \n──────┼────────────────────────────────\n    1 │   2.77778   car             62\n    2 │  -5.0       face           132\n  ⋮   │     ⋮           ⋮         ⋮\n 1999 │  -0.555556  face        120096\n 2000 │  -2.77778   car         120154\n\njulia> data\n120199-element Vector{Float64}:\n  0.31631798033146774\n  0.40338935529989906\n  0.46409775558165056\n  0.5862082040156747\n  ⋮\n -0.1879589005111152\n -0.3163314509311509\n -0.22230944464885682\n -0.01320095208877194 See also  predef_2x2 . source"},{"id":578,"pagetitle":"API / Docstrings","title":"UnfoldSim.simulate","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.simulate","content":" UnfoldSim.simulate  —  Function simulate(\nrng::AbstractRNG,\ndesign::AbstractDesign,\ncomponents,\nonset::AbstractOnset,\nnoise::AbstractNoise = NoNoise();\nreturn_epoched = false,\n)\n\nsimulate(\ndesign::AbstractDesign,\ncomponents,\nonset::AbstractOnset,\nnoise::AbstractNoise = NoNoise();\nreturn_epoched = false,\n) Simulate continuous or epoched signal, given  design , [Array of]  component ,  onset  and  optional  noise  and  rng . Main simulation function. Arguments rng::AbstractRNG  (optional): Random number generator, important to ensure reproducibility. design::AbstractDesign : Desired experimental design. components :  Component (s) for the desired signal. onset::AbstractOnset : Desired inter-onset distance distribution. noise::AbstractNoise = NoNoise()  (optional): Desired noise. Keyword arguments return_epoched::Bool = false : If set to  true  epoched data is returned, otherwise a continuous signal is returned (see also Notes below). Returns (signal, events)::Tuple{Array, DataFrame} : signal  : Generated signal. Depending on the design, on the components and on     return_epoched , the output can be a 1-D, 2-D, 3-D or 4-D Array.    For example, a 4-D Array would have the dimensions  channels x time x trials x subjects . events : Generated events data frame with latencies. Examples Adapted from the  quickstart tutorial  in the UnfoldSim docs. julia> using Random # to get an RNG\n\njulia> design =\n    SingleSubjectDesign(; conditions = Dict(:cond_A => [\"level_A\", \"level_B\"])) |>\n    x -> RepeatDesign(x, 10);\n\njulia> component = LinearModelComponent(; \n    basis = [0, 0, 0, 0.5, 1, 1, 0.5, 0, 0],\n    formula = @formula(0 ~ 1 + cond_A),\n    β = [1, 0.5],\n);\n\njulia> onset = UniformOnset(; width = 20, offset = 4);\n\njulia> noise = PinkNoise(; noiselevel = 0.2);\n\n# Variant 1: Use a custom RNG.\njulia> data, events = simulate(MersenneTwister(2), design, component, onset, noise);\n\njulia> data\n293-element Vector{Float64}:\n -0.013583193323430123\n  0.09159433856866195\n  ⋮\n -0.25190584567097907\n -0.20179992275876316\n\njulia> events\n20×2 DataFrame\n Row │ cond_A   latency \n     │ String   Int64   \n─────┼──────────────────\n   1 │ level_A        9\n   2 │ level_B       20\n   3 │ level_A       27\n   4 │ level_B       37\n  ⋮  │    ⋮        ⋮\n  18 │ level_B      257\n  19 │ level_A      271\n  20 │ level_B      284\n         13 rows omitted\n\n# Variant 2: Without specifying an RNG, MersenneTwister(1) will be used for the simulation.\njulia> data1, events1 = simulate(design, component, onset, noise);\n┌ Warning: No random generator defined, used the default (`Random.MersenneTwister(1)`) with a fixed seed. This will always return the same results and the user is strongly encouraged to provide their own random generator! Notes Some remarks on how the noise is added: If  return_epoched = true  and  onset = NoOnset()  the noise is added to the epoched data matrix. If  onset  is not  NoOnset , a continuous signal is created and the noise is added to this    i.e. this means that the noise won't be the same as in the  onset = NoOnset()  case even if  return_epoched = true . The case  return_epoched = false  and  onset = NoOnset()  is not possible and therefore    covered by an assert statement. Additional remarks on the overlap of adjacent signals when  return_epoched = true : If  onset = NoOnset()  there will not be any overlapping signals in the data because the onset calculation and conversion to a continuous signal is skipped. If an inter-onset distance distribution is given, a continuous signal(potentially with overlap) is constructed and partitioned into epochs afterwards. source"},{"id":579,"pagetitle":"API / Docstrings","title":"UnfoldSim.simulate_and_add!","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.simulate_and_add!-Tuple{AbstractMatrix, Any, Any, Any}","content":" UnfoldSim.simulate_and_add!  —  Method simulate_and_add!(epoch_data::AbstractMatrix, c, simulation, rng)\nsimulate_and_add!(epoch_data::AbstractArray, c, simulation, rng) Helper function to call  simulate_component  and add it to a provided Array  epoch_data . source"},{"id":580,"pagetitle":"API / Docstrings","title":"UnfoldSim.simulate_component","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.simulate_component-Tuple{Any, AbstractComponent, Simulation}","content":" UnfoldSim.simulate_component  —  Method simulate_component(rng, c::AbstractComponent, simulation::Simulation) By default call  simulate_component  with  (rng, c::Abstractcomponent, design::AbstractDesign)  instead of the whole simulation. This function exist solely to provide a \"hook\" if for a custom component something else than the design is necessary, e.g. a dependency on the onsets, noise or similar. source"},{"id":581,"pagetitle":"API / Docstrings","title":"UnfoldSim.simulate_component","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.simulate_component-Tuple{Any, LinearModelComponent, AbstractDesign}","content":" UnfoldSim.simulate_component  —  Method simulate_component(rng, c::LinearModelComponent, design::AbstractDesign) Generate a linear model design matrix, weight it by the coefficients  c.β  and multiply the result with the given basis vector. Returns Matrix{Float64} : Simulated component for each event in the events data frame. The output dimensions are  length(c.basis) x length(design) . Examples julia> design = SingleSubjectDesign(; conditions = Dict(:cond => [\"natural\", \"artificial\"]));\n\njulia> c = UnfoldSim.LinearModelComponent([0, 1, 1, 0], @formula(0 ~ 1 + cond), [1, 2], Dict());\n\njulia> using StableRNGs\n\njulia> simulate_component(StableRNG(1), c, design)\n4×2 Matrix{Float64}:\n 0.0  0.0\n 3.0  1.0\n 3.0  1.0\n 0.0  0.0 source"},{"id":582,"pagetitle":"API / Docstrings","title":"UnfoldSim.simulate_component","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.simulate_component-Tuple{Any, MixedModelComponent, AbstractDesign}","content":" UnfoldSim.simulate_component  —  Method simulate_component(rng, c::MixedModelComponent, design::AbstractDesign, return_parameters = false) Generate a MixedModel and simulate data according to the given parameters  c.β  and  c.σs . Keyword arguments return_parameters::Bool = false : Can be used to return the per-event parameters used to weight the basis function. Sometimes useful to inspect what is simulated. Returns Matrix{Float64} : Simulated component for each event in the events data frame. The output dimensions are  length(c.basis) x length(design) . Notes MixedModels/Sim does not allow simulation of data without white noise of the residuals. Because we want our own noise, we use the following trick to remove the MixedModels-Noise: Practically, we upscale the specified  σs  by factor 10 000, and request a white-noise-level of  σ = 0.0001 . Internally in MixedModels/Sim,  σs  are relative to  σ , and thus are normalized correctly, while keeping the noise 10 000 times smaller than the random effects We cannot exclude that this trick runs into strange numerical issues if the random effect  σs  are very large compared to the fixed effects. Currently, it is not possible to use a different basis for fixed and random effects. If this is needed, some code-scaffold is available but commented out at the moment and requires a bit of implementation work. Examples julia> design = MultiSubjectDesign(; n_subjects = 2, n_items = 6, items_between = Dict(:cond => [\"A\", \"B\"]));\n\njulia> c = UnfoldSim.MixedModelComponent([0, 1, 1, 0], @formula(0 ~ 1 + cond + (1|subject)), [1, 2], Dict(:subject => [2],), Dict());\n\njulia> using StableRNGs\n\njulia> simulate_component(StableRNG(1), c, design)\n4×12 Matrix{Float64}:\n -0.0      -0.0       -0.0      -0.0       -0.0     -0.0       0.0       0.0      0.0       0.0      0.0       0.0\n -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565\n -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565\n -0.0      -0.0       -0.0      -0.0       -0.0     -0.0       0.0       0.0      0.0       0.0      0.0       0.0\n\njulia> simulate_component(StableRNG(1), c, design, return_parameters = true)\n1×12 Matrix{Float64}:\n -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565 source"},{"id":583,"pagetitle":"API / Docstrings","title":"UnfoldSim.simulate_component","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.simulate_component-Tuple{Any, MultichannelComponent, AbstractDesign}","content":" UnfoldSim.simulate_component  —  Method simulate_component(rng, c::MultichannelComponent, design::AbstractDesign) Return the projection of a  MultichannelComponent c  from \"source\" to \"sensor\" space. Returns Array{Float64,3} : Projected simulated component for each event in the events data frame. The output dimensions are  length(c.projection) x length(c.basis) x length(design) . Examples julia> design = SingleSubjectDesign(; conditions = Dict(:cond => [\"natural\", \"artificial\"]));\n\njulia> c = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), β = [1, 0.5]);\njulia> mc = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1], PinkNoise());\n\njulia> using StableRNGs\n\njulia> simulate_component(StableRNG(1), mc, design)\n7×15×2 Array{Float64, 3}:\n[:, :, 1] =\n  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.3742    1.76706   2.76971   2.0306    1.17429   1.00922   1.09519   0.754659   2.25662\n  1.71925    2.33147   1.91905    1.51504    2.35278   3.30312   2.7484    3.53412   5.53942   4.0612    2.34858   2.01845   2.19039   1.50932    4.51324\n -0.859626  -1.16574  -0.959523  -0.757522  -1.17639  -1.65156  -1.3742   -1.76706  -2.76971  -2.0306   -1.17429  -1.00922  -1.09519  -0.754659  -2.25662\n  2.57888    3.49721   2.87857    2.27257    3.52917   4.95469   4.1226    5.30118   8.30913   6.09179   3.52287   3.02767   3.28558   2.26398    6.76985\n  4.29813    5.82868   4.79761    3.78761    5.88194   8.25781   6.871     8.8353   13.8485   10.153     5.87145   5.04612   5.47597   3.7733    11.2831\n  1.97714    2.68119   2.2069     1.7423     2.70569   3.79859   3.16066   4.06424   6.37033   4.67037   2.70087   2.32121   2.51894   1.73572    5.19022\n  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.3742    1.76706   2.76971   2.0306    1.17429   1.00922   1.09519   0.754659   2.25662\n\n[:, :, 2] =\n  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.31571   1.56047   2.39471   1.54567   0.689367   0.634223   0.888605   0.69617   2.25662\n  1.71925    2.33147   1.91905    1.51504    2.35278   3.30312   2.63142   3.12094   4.78942   3.09135   1.37873    1.26845    1.77721    1.39234   4.51324\n -0.859626  -1.16574  -0.959523  -0.757522  -1.17639  -1.65156  -1.31571  -1.56047  -2.39471  -1.54567  -0.689367  -0.634223  -0.888605  -0.69617  -2.25662\n  2.57888    3.49721   2.87857    2.27257    3.52917   4.95469   3.94713   4.68142   7.18413   4.63702   2.0681     1.90267    2.66582    2.08851   6.76985\n  4.29813    5.82868   4.79761    3.78761    5.88194   8.25781   6.57855   7.80236  11.9735    7.72837   3.44684    3.17112    4.44303    3.48085  11.2831\n  1.97714    2.68119   2.2069     1.7423     2.70569   3.79859   3.02613   3.58909   5.50783   3.55505   1.58554    1.45871    2.04379    1.60119   5.19022\n  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.31571   1.56047   2.39471   1.54567   0.689367   0.634223   0.888605   0.69617   2.25662 source"},{"id":584,"pagetitle":"API / Docstrings","title":"UnfoldSim.simulate_interonset_distances","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.simulate_interonset_distances","content":" UnfoldSim.simulate_interonset_distances  —  Function simulate_interonset_distances(rng, onset::AbstractOnset, design::AbstractDesign) Generate the inter-onset distance vector by sampling from the respective distribution (in samples). Arguments rng : Random number generator (RNG) to make the process reproducible. onset::AbstractOnset : Inter-onset distance distribution to sample from. design::AbstractDesign : Experimental design with conditions and covariates. Returns Vector{Integer} : Inter-onset distances in samples. Note that these are distances between onsets and no latencies. Examples # Create an experimental design\njulia> design_single = SingleSubjectDesign(;\n           conditions = Dict(\n               :stimulus_type => [\"natural\", \"artificial\"],\n               :contrast_level => range(0, 1, length = 3),\n           ),\n       );\n\n# Create an inter-onset distance distribution\njulia> onset_distribution = LogNormalOnset(3, 0.5, 5, nothing);\n\njulia> using StableRNGs\n\njulia> simulate_interonset_distances(StableRNG(1), onset_distribution, design_single)\n6-element Vector{Int64}:\n 20\n 26\n 34\n 18\n 12\n 23 See also  simulate_onsets . source"},{"id":585,"pagetitle":"API / Docstrings","title":"UnfoldSim.simulate_noise","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.simulate_noise","content":" UnfoldSim.simulate_noise  —  Function simulate_noise(rng, t::AbstractNoise, n::Int) Generate noise samples of the given type  t . For details, see the documentation of the individual noise types. Use  subtypes(AbstractNoise)  for a list of the implemented noise types. Arguments rng::AbstractRNG : Random number generator (RNG) to make the process reproducible. t::AbstractNoise : Instance of a noise type e.g.  PinkNoise() . n::Int : The number of noise samples that should be generated. Returns Vector : Vector of length  n  containing the noise samples. Examples # Here we use White Noise as an example but it works in the same way for the other noise types.\njulia> noise = WhiteNoise()\nWhiteNoise\n  noiselevel: Int64 1\n  imfilter: Int64 0\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(1), noise, 3)\n3-element Vector{Float64}:\n -0.5325200748641231\n  0.098465514284785\n  0.7528865221245234 source"},{"id":586,"pagetitle":"API / Docstrings","title":"UnfoldSim.simulate_onsets","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.simulate_onsets-Tuple{Any, AbstractOnset, Simulation}","content":" UnfoldSim.simulate_onsets  —  Method simulate_onsets(rng, onset::AbstractOnset, simulation::Simulation) Call  simulate_interonset_distances  to generate distances between events and then add them up to generate the actual latencies in samples. Please note that this function is mainly for internal use in the context of  simulate  function calls.  Also note that the accumulation of onsets starts at 1 to avoid indexing problems in the case that the first sampled onset is 0. Arguments rng : Random number generator (RNG) to make the process reproducible. onset::AbstractOnset : Inter-onset distance distribution which is passed to  simulate_interonset_distances . simulation::Simulation : Simulation object which contains design, component(s), inter-onset distance distribution and noise. Returns Examples # Create Simulation object\njulia> design_single = SingleSubjectDesign(;\n           conditions = Dict(\n               :stimulus_type => [\"natural\", \"artificial\"],\n               :contrast_level => range(0, 1, length = 3),\n           ),\n       );\n\njulia> p1_component = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [5]);\n\njulia> simulation = Simulation(design_single, p1_component, UniformOnset(), NoNoise());\n\njulia> using StableRNGs\n\n# Simulate onsets for this simulation\njulia> simulate_onsets(StableRNG(1), simulation.onset, simulation)\n6-element Vector{Int64}:\n  20\n  70\n  97\n 110\n 150\n 182 See also  simulate_interonset_distances . source"},{"id":587,"pagetitle":"API / Docstrings","title":"UnfoldSim.simulate_responses","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.simulate_responses-Tuple{Any, Vector{<:AbstractComponent}, Simulation}","content":" UnfoldSim.simulate_responses  —  Method simulate_responses(\n    rng,\n    components::Vector{<:AbstractComponent},\n    simulation::Simulation) Simulate multiple component responses and accumulate them on a per-event basis. Returns epoch_data :  Matrix  (or  Array  in the multi-channel case) of combined simulated components.   The output dimensions are  maxlength(components) x length(simulation.design)  for single-channel components and    n_channels(components) x maxlength(components) x length(simulation.design)  for multi-channel components. Examples julia> design = SingleSubjectDesign(; conditions = Dict(:cond => [\"natural\", \"artificial\"]));\n\njulia> c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), β = [1, 0.5]);\njulia> c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [2]);\n\njulia> simulation = Simulation(design, [c1, c2], UniformOnset(; width = 0, offset = 30), PinkNoise());\n\njulia> using StableRNGs\n\njulia> simulate_responses(StableRNG(1), [c1, c2], simulation)\n45×2 Matrix{Float64}:\n 0.0        0.0\n 0.0        0.0\n 0.0        0.0\n 0.0        0.0\n 0.0        0.0\n ⋮          \n 0.352614   0.352614\n 0.203907   0.203907\n 0.0924246  0.0924246\n 0.0233794  0.0233794\n 0.0        0.0 source"},{"id":588,"pagetitle":"API / Docstrings","title":"UnfoldSim.weight_σs","ref":"/UnfoldDocs/UnfoldSim.jl/stable/api/#UnfoldSim.weight_σs-Tuple{Dict, Float64, Float64}","content":" UnfoldSim.weight_σs  —  Method weight_σs(σs::Dict, b_σs::Float64, σ_lmm::Float64) Weight a  σs  Dict for MixedModels.jl by  b_σs , a scaling factor typically from a  basis . Finally scales it again by  σ_lmm , as a trick to simulate noise-free LMMs (see  MixedModelsComponent ) In the future, we anticipate a function      function weight_σs(σs::Dict,b_σs::Dict,σ_lmm::Float64)  where each  σs  entry can be weighted individually by a matching  b_σs , but it is not implemented. Arguments σs::Dict  = a Dict of random effects as output of MixedModels.create_re b_σs::Float64  = a scaling factor, typically one entry of a basis function from a component σ_lmm::Float64  = a scaling factor to simulate near-zero noise LMMs Returns `NamedTuple` of the weighted random effects source"},{"id":591,"pagetitle":"Developer documentation","title":"Developer documentation","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Developer-documentation","content":" Developer documentation Welcome to the developer documentation! We are excited that you are interested in contributing to our package. Feel free to submit your work in a state you are comfortable with—we genuinely appreciate every contribution! If you are interested in following best practices and learning along the way, keep reading. But don't worry, we welcome your input just as it is 🙂. Contribution guide If you haven't already, please read the  Contribution guide  first. Please note that the following documentation is adapted from the  BestieTemplate.jl developer documentation  but has been customized to fit our needs."},{"id":592,"pagetitle":"Developer documentation","title":"Development/GitHub Workflow","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Development/GitHub-Workflow","content":" Development/GitHub Workflow"},{"id":593,"pagetitle":"Developer documentation","title":"Before you start coding","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Before-you-start-coding","content":" Before you start coding Check whether there exists a GitHub issue about the topic (e.g. bug, new feature etc). If not create one with a short description of the problem or feature idea. Discuss your approach with the package maintainers either in the issue or via another channel."},{"id":594,"pagetitle":"Developer documentation","title":"First time clone & development version","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#First-time-clone-and-development-version","content":" First time clone & development version If this is the first time you work with this repository, follow the instructions below to clone the repository and create a  dev  version.  `dev` version of a Julia package Having a  dev  (development) version of a Julia package allows you to import a local version of the package with your changes instead of the registered package version (which is static)."},{"id":595,"pagetitle":"Developer documentation","title":"a) If you have writing access for the GitHub repository","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#a)-If-you-have-writing-access-for-the-GitHub-repository","content":" a) If you have writing access for the GitHub repository Option 1: Clone this repository using  git clone . Option 2 (recommended): Use the Julia  dev  command to create a development version of the package: Start a Julia session and run  cd(\"/path/to/your/project\")  to navigate to your project folder. Press  ]  to enter  pkg  mode. Run  dev --local UnfoldSim  to clone the package to  ./dev/UnfoldSim  and automatically add it to your Julia project environment. Important If you have writing rights, whenever  upstream  is mentioned below, use  origin  instead."},{"id":596,"pagetitle":"Developer documentation","title":"b) If you don't have writing access for the GitHub repository","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#b)-If-you-don't-have-writing-access-for-the-GitHub-repository","content":" b) If you don't have writing access for the GitHub repository Fork the UnfoldSim.jl repository. Clone your repository (this will create a  git remote  called  origin ). Add the UnfoldSim.jl repository as a remote: git remote add upstream https://github.com/unfoldtoolbox/UnfoldSim.jl This will ensure that you have two remotes in your git:  origin  and  upstream . You will create branches and push to  origin , and you will fetch and update your local  main  branch from  upstream . `dev` version without writing rights You can also use the  dev  command on your fork. Run  ]dev --local url/of/your/fork  to clone the package to  ./dev/UnfoldSim  and automatically add it to your Julia project environment."},{"id":597,"pagetitle":"Developer documentation","title":"Revise.jl","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Revise.jl","content":" Revise.jl Further, we recommend to use  Revise.jl : a Julia package which allows you to track source code changes in a running Julia session without need to restart it and reload the package. We recommend to install it in the global environment: julia> # Press ]\npkg> activate\npkg> add Revise"},{"id":598,"pagetitle":"Developer documentation","title":"Working on a new issue","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Working-on-a-new-issue","content":" Working on a new issue We try to keep a linear Git history in this repository, so it is important to keep your branches up-to-date. Fetch from the remote and fast-forward your local main git fetch upstream\ngit switch main\ngit merge --ff-only upstream/main Branch from  main  to address the issue (see below for naming) git switch -c 42-add-answer-universe Push the new local branch to your personal remote repository git push -u origin 42-add-answer-universe Create a pull request to merge your remote branch into the  main  branch of the original UnfoldSim.jl repository."},{"id":599,"pagetitle":"Developer documentation","title":"Branch naming","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Branch-naming","content":" Branch naming If there is an associated issue, add the issue number. If there is no associated issue,  and the changes are small , add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update. If the changes are not small and there is no associated issue, then either create an issue first, or discuss in another channel with the maintainers. Use dash separated imperative wording related to the issue (e.g.,  14-add-tests ,  15-fix-model ,  16-remove-obsolete-files )."},{"id":600,"pagetitle":"Developer documentation","title":"Commit messages","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Commit-messages","content":" Commit messages Use imperative or present tense, for instance:  Add feature  or  Fix bug . Have informative titles. When necessary, add a body with details. If there are breaking changes, add the information to the commit message."},{"id":601,"pagetitle":"Developer documentation","title":"Before creating a pull request","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Before-creating-a-pull-request","content":" Before creating a pull request Ideally: Make sure the tests pass (see  Testing ). Add appropriate documentation (ideally using the  Docstring templates ). Ideally: Follow the formatting rules from  JuliaFormatter.jl  (see  Formatting ). Fetch any  main  updates from upstream and rebase your branch, if necessary: git fetch upstream\ngit rebase upstream/main BRANCH_NAME Then you can open a pull request and work with the reviewer to address any issues. Best practices not shackles We encourage you to share your contributions in whatever state you are comfortable with. Don’t feel overwhelmed by the number of guides — think of them as helpful resources, not strict requirements. Every contribution is valuable, and we’re happy to refine things together! "},{"id":602,"pagetitle":"Developer documentation","title":"Formatting","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Formatting","content":" Formatting"},{"id":603,"pagetitle":"Developer documentation","title":"JuliaFormatter.jl","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#JuliaFormatter.jl","content":" JuliaFormatter.jl We use  JuliaFormatter.jl  for formatting and recommend you to install it in your global environment: julia> # Press ]\npkg> activate\npkg> add JuliaFormatter"},{"id":604,"pagetitle":"Developer documentation","title":"Beware of reviewdog 🐶","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Beware-of-reviewdog","content":" Beware of reviewdog 🐶 We use the  julia-format  Github action to ensure that the code follows the formatting rules defined by  JuliaFormatter.jl . When opening a pull request  reviewdog  will automatically make formatting suggestions for your code."},{"id":605,"pagetitle":"Developer documentation","title":"Testing","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Testing","content":" Testing As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run  test : julia> # press ]\npkg> activate .\npkg> test Running single tests Instead of running all tests, you can also run the  test/setup.jl  to load all required packages, and subsequently run single tests manually either by  include(\"test/my_test.jl\")  or by opening the file and running the specific test block you want to run."},{"id":606,"pagetitle":"Developer documentation","title":"Documentation","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Documentation","content":" Documentation Documentation is key to maintaining a codebase that is easy to understand and extend. Whether it is comments in the code, docstrings, or tutorials, when writing documentation,  think about your future self or the next person reading the code or using your functions."},{"id":607,"pagetitle":"Developer documentation","title":"Building and viewing the documentation locally","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Building-and-viewing-the-documentation-locally","content":" Building and viewing the documentation locally We recommend using  LiveServer.jl  to build and preview the documentation locally. To simplify this process we created the  docs/run_liveserver.jl  script. Please follow these steps: Navigate to the  docs  folder and activate it. Run  using Revise  (in case you decided to install it in your docs environment). If this is the first time building the docs Press  ]  to enter  pkg  mode. Run  pkg> dev ..  to use the development version of your package. Press backspace to leave  pkg  mode. Run  include(\"run_liveserver.jl\") . Click on the provided link or go to  http://0.0.0.0:8000/  in your browser. Live preview of docstrings Install  Revise.jl  in the docs environment to enable live updating of docstrings in the docs preview. Separate Julia session for docs preview We recommend using a separate Julia session (in VSCode) to run the  run_liveserver.jl  script, as it continues running. This way, you can avoid \"blocking\" the REPL and run other code in the meantime."},{"id":608,"pagetitle":"Developer documentation","title":"Adding a documentation page","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Adding-a-documentation-page","content":" Adding a documentation page We recommend to write a Literate.jl document and place it in  docs/literate/FOLDER/FILENAME.jl  with  FOLDER  being  HowTo ,  Explanation ,  Tutorial  or  Reference  ( recommended reading on the 4 categories ). Literate.jl converts the  .jl  file to a  .md  automatically and places it in  docs/src/generated/FOLDER/FILENAME.md . Edit  make.jl  with a reference to  docs/src/generated/FOLDER/FILENAME.md ."},{"id":609,"pagetitle":"Developer documentation","title":"Docstring templates","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Docstring-templates","content":" Docstring templates The following docstring templates are mainly based on the  Julia manual  and  Blue: a Style Guide for Julia ."},{"id":610,"pagetitle":"Developer documentation","title":"Function docstring template","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Function-docstring-template","content":" Function docstring template \"\"\"\n    my_function(argument1:Type1; keyword_argument3::Type3 = value3)\n    my_function(argument1::Type1, optional_argument2::Type2; keyword_argument3::Type3 = value3)\n\nOne-line description using the imperative form (\"Do this\") instead of the third person and ending with a period.\n\nIf the one-line description is not sufficient, one can also write a short paragraph with additional information.\n\n# Arguments (if needed)\n- `argument1::Type1`: Description of argument1.\n- `optional_argument2::Type2` (optional): Description of optional_argument2.\n\n# Keyword arguments (if needed)\n- `keyword_argument3::Type3 = value3`: Description of keyword_argument3.\n\n# Returns\n- `result::Type4` : Description of result.\n\n# Examples\n```julia-repl\njulia> my_function(value1, value2)\nresult1\n\njulia> my_function(value1; keyword_argument3 = value4)\nresult2\n```\n\nSee also [`my_function2`](@ref), [`my_function3`](@ref).\n\"\"\" Special cases: If a function accepts many keyword arguments, only include  <keyword arguments>  as a placeholder in the signature and give a keyword list with descriptions in the Keyword arguments section of the docstring. If a function returns more than one variable, write the Returns section in the following way: # Returns\n- (result1, result2)::Tuple{Type1, Type2}:\n    - Description of result1\n    - Description of result2"},{"id":611,"pagetitle":"Developer documentation","title":"Type docstring template","ref":"/UnfoldDocs/UnfoldSim.jl/stable/developer_docs/#Type-docstring-template","content":" Type docstring template \"\"\"\n    MyType <: MyAbstractType\n\nOne-line desciption of my type which ends with a period.\n\nIf the one-line description is not sufficient, one can also write a short paragraph with additional information.\n\n# Fields\n- `field1::Type1`: Description of field1.\n- `optional_field2::Type2 = value2` (optional): Description of field2. If not provided, defaults to `value2`.\n\n# Examples\n```julia-repl\njulia> MyType(field1, field2)\nresult1\n```\n\nSee also [`MyType2`](@ref), [`my_function2`](@ref).\n\"\"\""},{"id":614,"pagetitle":"Generate multi channel data","title":"Generate multi channel data","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/multichannel/#Generate-multi-channel-data","content":" Generate multi channel data Here you will learn how to simulate EEG data for multiple channels/electrodes. The idea is to specify a signal on source level and then use a head model or a manual projection matrix to project the source signal to a number of electrodes."},{"id":615,"pagetitle":"Generate multi channel data","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/multichannel/#Setup","content":" Setup Click to expand # Load required packages\nusing UnfoldSim\nusing UnfoldMakie\nusing CairoMakie\nusing DataFrames\nusing Random"},{"id":616,"pagetitle":"Generate multi channel data","title":"Specifying a design","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/multichannel/#Specifying-a-design","content":" Specifying a design We are using a one-level design for testing here. design = SingleSubjectDesign(conditions = Dict(:condA => [\"levelA\"])); Next we generate two simple components at two different times without any formula attached (we have a single condition anyway) c = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [1]);\nc2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [1]);"},{"id":617,"pagetitle":"Generate multi channel data","title":"The multichannel component","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/multichannel/#The-multichannel-component","content":" The multichannel component Next, similar to the nested design above, we can nest the component in a  MultichannelComponent . We could either provide the projection matrix manually, e.g.: mc = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1]) MultichannelComponent\n  component: LinearModelComponent\n  projection: Array{Float64}((7,)) [1.0, 2.0, -1.0, 3.0, 5.0, 2.3, 1.0]\n  noise: NoNoise NoNoise()\n or maybe more convenient: use the pair-syntax: Headmodel=>Label which makes use of a headmodel (HaRTmuT is currently easily available in UnfoldSim) hart = Hartmut()\nmc = UnfoldSim.MultichannelComponent(c, hart => \"Left Postcentral Gyrus\")\nmc2 = UnfoldSim.MultichannelComponent(c2, hart => \"Right Occipital Pole\") MultichannelComponent\n  component: LinearModelComponent\n  projection: Array{Float64}((227,)) [-0.03461859471337842, -0.04321094803502425, 0.0037088347968313525, -0.014722528968861278, -0.0234889834534478, 0.02731807504242923, 0.038863688452528036, 0.1190531258070562, -0.09956890221613562, -0.0867729334438599  …  0.37435404409695094, -0.020863789022627935, 0.25627478723535513, -0.05777985212119245, 0.37104376432271147, -0.19446620423767172, 0.2590764703721097, -0.12923837607416555, 0.1732886690359311, 0.4703016561960567]\n  noise: NoNoise NoNoise()\n Hint You could also specify a noise-specific component which is applied prior to projection & summing with other components. finally we need to define the onsets of the signal onset = UniformOnset(; width = 20, offset = 4);"},{"id":618,"pagetitle":"Generate multi channel data","title":"Simulation","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/multichannel/#Simulation","content":" Simulation Now as usual we simulate data. Inspecting data shows our result is now indeed ~230 Electrodes large! Nice! data, events =\n    simulate(MersenneTwister(1), design, [mc, mc2], onset, PinkNoise(noiselevel = 0.05));\n\nsize(data) (227, 61) Hint The noise declared in the  simulate  function is added after mixing to channels, each channel receives independent noise. It is also possible to add noise to each individual component+source prior to projection. This would introduce correlated noise."},{"id":619,"pagetitle":"Generate multi channel data","title":"Plotting","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/multichannel/#Plotting","content":" Plotting Let's plot using Butterfly & Topoplot first we convert the electrodes to positions usable in TopoPlots.jl pos3d = hart.electrodes[\"pos\"]\npos2d = to_positions(pos3d')\npos2d = [Point2f(p[1] + 0.5, p[2] + 0.5) for p in pos2d]; now plot! f = Figure()\ndf = DataFrame(\n    :estimate => data[:],\n    :channel => repeat(1:size(data, 1), outer = size(data, 2)),\n    :time => repeat(1:size(data, 2), inner = size(data, 1)),\n)\nplot_butterfly!(f[1, 1:2], df; positions = pos2d)\nplot_topoplot!(\n    f[2, 1],\n    df[df.time.==28, :];\n    positions = pos2d,\n    visual = (; enlarge = 0.5, label_scatter = false),\n    axis = (; limits = ((0, 1), (0, 0.9))),\n)\nplot_topoplot!(\n    f[2, 2],\n    df[df.time.==48, :];\n    positions = pos2d,\n    visual = (; enlarge = 0.5, label_scatter = false),\n    axis = (; limits = ((0, 1), (0, 0.9))),\n)\nf This page was generated using  Literate.jl ."},{"id":622,"pagetitle":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/newComponent/#Define-a-new-component-(with-variable-duration-and-shift)","content":" Define a new component (with variable duration and shift) We want a new component that changes its duration and shift depending on a column in the event design. This is somewhat already implemented in the HRF + Pupil bases."},{"id":623,"pagetitle":"Define a new component (with variable duration and shift)","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/newComponent/#Setup","content":" Setup Click to expand using UnfoldSim\nusing Unfold\nusing Random\nusing DSP\nusing CairoMakie, UnfoldMakie\n\nsfreq = 100;"},{"id":624,"pagetitle":"Define a new component (with variable duration and shift)","title":"Design","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/newComponent/#Design","content":" Design Let's generate a design with two columns, shift + duration design = UnfoldSim.SingleSubjectDesign(;\n    conditions = Dict(\n        :shift => rand(100) .* sfreq / 5,\n        :duration => 20 .+ rand(100) .* sfreq / 5,\n    ),\n) SingleSubjectDesign\n  conditions: Dict{Symbol, Vector}\n  event_order_function: #3 (function of type UnfoldSim.var\"#3#7\")\n"},{"id":625,"pagetitle":"Define a new component (with variable duration and shift)","title":"Implement a new AbstractComponent","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/newComponent/#Implement-a-new-AbstractComponent","content":" Implement a new AbstractComponent We also need a new  AbstractComponent struct TimeVaryingComponent <: AbstractComponent\n    basisfunction::Any\n    maxlength::Any\nend We have to define the length of a component Base.length(c::TimeVaryingComponent) = length(c.maxlength) While we could have put the TimeVaryingComponent.basisfunction directly into the simulate function, I thought this is a bit more modular function UnfoldSim.simulate(rng, c::TimeVaryingComponent, design::AbstractDesign)\n    evts = generate_events(design)\n    return c.basisfunction(evts, c.maxlength)\nend finally, the actual function that does the shifting + duration function basis_shiftduration(evts, maxlength)\n    basis = hanning.(Int.(round.(evts.duration))) ## hanning as long as duration\n    if \"shift\" ∈ names(evts)\n        basis = pad_array.(basis, Int.(round.(.-evts.shift)), 0) ## shift by adding 0 in front\n    end\n    # we should make sure that all bases have maxlength by appending / truncating\n    difftomax = maxlength .- length.(basis)\n    if any(difftomax .< 0)\n        @warn \"basis longer than max length in at least one case. either increase maxlength or redefine function. Trying to truncate the basis\"\n        basis[difftomax.>0] = pad_array.(basis[difftomax.>0], difftomax[difftomax.>0], 0)\n        return [b[1:maxlength] for b in basis]\n    else\n        return pad_array.(basis, difftomax, 0)\n    end\nend basis_shiftduration (generic function with 1 method)"},{"id":626,"pagetitle":"Define a new component (with variable duration and shift)","title":"Simulate data with the new component type","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/newComponent/#Simulate-data-with-the-new-component-type","content":" Simulate data with the new component type erp = UnfoldSim.simulate(\n    MersenneTwister(1),\n    TimeVaryingComponent(basis_shiftduration, 50),\n    design,\n)\nplot_erpimage(hcat(erp...), sortvalues = generate_events(design).shift) This page was generated using  Literate.jl ."},{"id":629,"pagetitle":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/newDesign/#Define-a-new-(imbalanced)-design","content":" Define a new (imbalanced) design A design specifies how much data is generated, and how the event-table(s) should be generated. Already implemented examples are  MultiSubjectDesign  and  SingleSubjectDesign . We need 3 things for a new design: a  struct<:AbstractDesign , a  size  and a  generate_events  function."},{"id":630,"pagetitle":"Define a new (imbalanced) design","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/newDesign/#Setup","content":" Setup Click to expand using UnfoldSim\nusing StableRNGs\nusing DataFrames\nusing Parameters\nusing Random"},{"id":631,"pagetitle":"Define a new (imbalanced) design","title":"1) type","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/newDesign/#1)-type","content":" 1)  type We need a  ImbalanceSubjectDesign  struct. You are free to implement it as you wish, as long as the other two functions are implemented @with_kw struct ImbalanceSubjectDesign <: UnfoldSim.AbstractDesign\n    n_trials::Int\n    balance::Float64 = 0.5 # default balanced\nend;"},{"id":632,"pagetitle":"Define a new (imbalanced) design","title":"2) size","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/newDesign/#2)-size","content":" 2)  size we need a  size(design::ImbalanceSubjectDesign)  function to tell how many events we will have. This is used at different places, e.g. in the Default onset implementation # note the trailing , to make it a Tuple\nUnfoldSim.size(design::ImbalanceSubjectDesign) = (design.n_trials,);"},{"id":633,"pagetitle":"Define a new (imbalanced) design","title":"3) generate_events","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/newDesign/#3)-generate_events","content":" 3)  generate_events We need a type  generate_events(rng::AbstractRNG, design::ImbalanceSubjectDesign)  function. This function should return the actual table as a  DataFrame function UnfoldSim.generate_events(rng::AbstractRNG, design::ImbalanceSubjectDesign)\n    nA = Int(round.(design.n_trials .* design.balance))\n    nB = Int(round.(design.n_trials .* (1 - design.balance)))\n    @assert nA + nB ≈ design.n_trials\n    levels = vcat(repeat([\"levelA\"], nA), repeat([\"levelB\"], nB))\n    return DataFrame(Dict(:condition => levels))\nend; Finally, we can test the function and see whether it returns a Design-DataFrame as we requested design = ImbalanceSubjectDesign(; n_trials = 6, balance = 0.2)\ngenerate_events(design) 6×1 DataFrame Row condition String 1 levelA 2 levelB 3 levelB 4 levelB 5 levelB 6 levelB This page was generated using  Literate.jl ."},{"id":636,"pagetitle":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/predefinedData/#Use-existing-experimental-designs-and-onsets-in-the-simulation","content":" Use existing experimental designs & onsets in the simulation Let's say you want to use the events data frame (containing the levels of the experimental variables and the event onsets (latencies)) from a previous study in your simulation."},{"id":637,"pagetitle":"Use existing experimental designs & onsets in the simulation","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/predefinedData/#Setup","content":" Setup Click to expand # Load required packages\nusing UnfoldSim\nusing DataFrames\nusing Random\nusing CairoMakie # for plotting From a previous study, we (somehow, e.g. by using  pyMNE.jl ) imported an event data frame like this: my_events = DataFrame(:condition => [:A, :B, :B, :A, :A], :latency => [7, 13, 22, 35, 41]) 5×2 DataFrame Row condition latency Symbol Int64 1 A 7 2 B 13 3 B 22 4 A 35 5 A 41 To use exactly these values, we can generate a new  AbstractDesign , which will always return this event dataframe struct MyManualDesign <: AbstractDesign\n    my_events::Any\nend\nUnfoldSim.generate_events(rng, d::MyManualDesign) = deepcopy(d.my_events) ## generate function which is called internally in UnfoldSim\nUnfoldSim.size(d::MyManualDesign) = size(d.my_events, 1); ## necessary function to tell what the dimensionality of the experimental design is Note Note the  UnfoldSim.generate_events  which tells Julia to \"overload\" the  generate_events  function as defined in UnfoldSim. Next we generate a  MyManualDesign mydesign = MyManualDesign(my_events); We could already use this \"solo\" and simulate some data, for example: signal = LinearModelComponent(;\n    basis = [1, 1, 0.5, 0, 0],\n    formula = @formula(0 ~ 1 + condition),\n    β = [1, 0.5],\n);\n\ndata, events =\n    simulate(MersenneTwister(1), mydesign, signal, UniformOnset(; width = 10, offset = 5))\nlines(data) # plotting\nvlines!(my_events.latency; linestyle = :dash)\ncurrent_figure() Looks good, but the events don't match our custom onsets yet."},{"id":638,"pagetitle":"Use existing experimental designs & onsets in the simulation","title":"Custom Timings","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/predefinedData/#Custom-Timings","content":" Custom Timings Finally, we want to use our custom timings as well. For this we define a new  AbstractOnset . Again, it simply returns our manually provided latencies struct MyManualOnset <: AbstractOnset end\nUnfoldSim.simulate_onsets(rng, onset::MyManualOnset, simulation::Simulation) =\n    generate_events(rng, simulation.design).latency Hint This is a bit of a trick, it relies that  MyManualOnset  is always used in combination with  MyManualDesign . You could of course repeat the structure from  MyManualDesign  also for  MyManualOnset  and have an explicit field in the structure containing the onsets. And that's it data, events = simulate(MersenneTwister(1), mydesign, signal, MyManualOnset())\nlines(data) # plotting\nvlines!(my_events.latency, linestyle = :dash)\ncurrent_figure() now everything matches, lovely! This page was generated using  Literate.jl ."},{"id":641,"pagetitle":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/HowTo/repeatTrials/#howto_repeat_design","content":" Get multiple trials with identical subject/item combinations Sometimes we want to repeat a design, that is, have multiple trials with identical values, but it is not always straight forward to implement. For instance, there is no way to easily modify  MultiSubjectDesign  to have multiple identical subject/item combinations, without doing awkward repetitions of condition-levels or something. If you struggle with this problem  RepeatDesign  is an easy tool for you: using UnfoldSim\n\ndesignOnce = MultiSubjectDesign(;\n    n_items = 2,\n    n_subjects = 2,\n    subjects_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n    items_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n);\n\ndesign = RepeatDesign(designOnce, 4);\ngenerate_events(design) 8×3 DataFrame Row subject cond item String String String 1 S1 levelA I1 2 S1 levelA I1 3 S1 levelA I1 4 S1 levelA I1 5 S2 levelB I2 6 S2 levelB I2 7 S2 levelB I2 8 S2 levelB I2 As you can see, the design was simply repeated. Note If you implemented your own  AbstractDesign , you need to define the size function accordingly. E.g.:    Base.size(design::RepeatDesign{SingleSubjectDesign}) = size(design.design).*design.repeat This page was generated using  Literate.jl ."},{"id":644,"pagetitle":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/basistypes/#Overview:-Basis-function-(component)-types","content":" Overview: Basis function (component) types There are several basis types directly implemented. They can be easily used for the  components . Note You can use any arbitrary shape defined by yourself! We often make use of  hanning(50)  from the DSP.jl package."},{"id":645,"pagetitle":"Overview: Basis function (component) types","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/basistypes/#Setup","content":" Setup Click to expand # Load required packages\nusing UnfoldSim\nusing CairoMakie\nusing DSP\nusing StableRNGs"},{"id":646,"pagetitle":"Overview: Basis function (component) types","title":"EEG","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/basistypes/#EEG","content":" EEG By default, the EEG bases assume a sampling rate of 100, which can easily be changed by e.g. p100(; sfreq=300) f = Figure()\nax = f[1, 1] = Axis(f)\nfor b in [p100, n170, p300, n400]\n    lines!(ax, b(), label = string(b))\n    scatter!(ax, b(), label = string(b))\nend\naxislegend(ax, merge = true)\nf"},{"id":647,"pagetitle":"Overview: Basis function (component) types","title":"fMRI","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/basistypes/#fMRI","content":" fMRI default hrf TR is 1. Get to know all your favourite shapes! ##--\nf = Figure()\nplotConfig = (\n    :peak => 1:3:10,\n    :post_undershoot => 10:5:30,\n    :amplitude => 2:5,\n    :shift => 0:3:10,\n    :peak_width => 0.1:0.5:1.5,\n    :post_undershoot_width => 0.1:0.5:1.5,\n)\n\nfor (ix, pl) in enumerate(plotConfig)\n    col = (ix - 1) % 3 + 1\n    row = Int(ceil(ix / 3))\n\n    ax = f[row, col] = Axis(f)\n    cfg = collect(pl)\n    for k in cfg[2]\n        lines!(ax, UnfoldSim.hrf(; TR = 0.1, (cfg[1] => k,)...), label = string(k))\n    end\n\n    axislegend(string(cfg[1]); merge = true)\nend\nf"},{"id":648,"pagetitle":"Overview: Basis function (component) types","title":"Pupil","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/basistypes/#Pupil","content":" Pupil We use the simplified PuRF from Hoeks & Levelt, 1993. Note that https://www.science.org/doi/10.1126/sciadv.abi9979 show some evidence in their supplementary material, that the convolution model is not fully applicable. f = Figure()\nplotConfig = (:n => 5:3:15, :tmax => 0.5:0.2:1.1)\n\nfor (ix, pl) in enumerate(plotConfig)\n    ax = f[1, ix] = Axis(f)\n    cfg = collect(pl)\n    for k in cfg[2]\n        lines!(ax, UnfoldSim.PuRF(; (cfg[1] => k,)...), label = string(k))\n    end\n\n    axislegend(string(cfg[1]); merge = true)\nend\nf This page was generated using  Literate.jl ."},{"id":651,"pagetitle":"Overview: Experimental design types","title":"Overview: Experimental design types","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/designtypes/#Overview:-Experimental-design-types","content":" Overview: Experimental design types The experimental design specifies the experimental conditions and other variables that are supposed to have an influence on the simulated data. Currently, there are three types of designs implemented:  SingleSubjectDesign ,  MultiSubjectDesign  and  RepeatDesign ."},{"id":652,"pagetitle":"Overview: Experimental design types","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/designtypes/#Setup","content":" Setup Click to expand # Load required packages\nusing UnfoldSim\nusing Random"},{"id":653,"pagetitle":"Overview: Experimental design types","title":"Single-subject designs","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/designtypes/#Single-subject-designs","content":" Single-subject designs As the name suggests, the  SingleSubjectDesign  type can be used to specify the experimental design for a single subject. Using the  conditions  arguments, the user can specify all relevant conditions or predictors and their levels or value range. The current implementation assumes a full factorial design (also called fully crossed design) in which each level of a factor occurs with each level of the other factors. Moreover, in the current implementation, there is exactly one instance of each of these factor combinations. Example: design_single = SingleSubjectDesign(;\n    conditions = Dict(\n        :stimulus_type => [\"natural\", \"artificial\"],\n        :contrast_level => range(0, 1, length = 3),\n    ),\n); In order to inspect the design, we can use the  generate_events  function to create an event table based on the design we specified. generate_events(design_single) 6×2 DataFrame Row contrast_level stimulus_type Float64 String 1 0.0 natural 2 0.5 natural 3 1.0 natural 4 0.0 artificial 5 0.5 artificial 6 1.0 artificial To change the order of the trials e.g. to sort or shuffle them, one can use the  event_order_function  argument. Example: Randomize the order of trials design_single_shuffled = SingleSubjectDesign(;\n    conditions = Dict(\n        :stimulus_type => [\"natural\", \"artificial\"],\n        :contrast_level => range(0, 1, length = 3),\n    ),\n    event_order_function = shuffle,\n); Click to expand event table  generate_events(design_single_shuffled) 6×2 DataFrame Row contrast_level stimulus_type Float64 String 1 1.0 artificial 2 0.5 natural 3 0.0 artificial 4 0.0 natural 5 1.0 natural 6 0.5 artificial"},{"id":654,"pagetitle":"Overview: Experimental design types","title":"Multi-subject designs","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/designtypes/#Multi-subject-designs","content":" Multi-subject designs The  MultiSubjectDesign  type can be used to simulate data for an experiment with multiple subjects. Internally, it uses the  MixedModelsSim.jl package . One needs to specify the number of subjects  n_subjects  and the number of items  n_items  i.e. stimuli. In addition, one needs to decide for every experimental factor whether it should be between- or within-subject (and item). Note For factors that are not listed in  items_between  it is assumed that they vary within-item (accordingly for  subjects_between ). design_multi = MultiSubjectDesign(\n    n_subjects = 6,\n    n_items = 4,\n    items_between = Dict(:colour => [\"red\", \"blue\"]),\n    subjects_between = Dict(:age_group => [\"young\", \"old\"]),\n    both_within = Dict(:luminance => range(0, 1, length = 3)),\n); Click to expand event table  generate_events(design_multi) 72×5 DataFrame Row subject age_group item colour luminance String String String String Float64 1 S1 young I1 red 0.0 2 S1 young I2 blue 0.0 3 S1 young I3 red 0.0 4 S1 young I4 blue 0.0 5 S1 young I1 red 0.5 6 S1 young I2 blue 0.5 7 S1 young I3 red 0.5 8 S1 young I4 blue 0.5 9 S1 young I1 red 1.0 10 S1 young I2 blue 1.0 11 S1 young I3 red 1.0 12 S1 young I4 blue 1.0 13 S2 old I1 red 0.0 14 S2 old I2 blue 0.0 15 S2 old I3 red 0.0 16 S2 old I4 blue 0.0 17 S2 old I1 red 0.5 18 S2 old I2 blue 0.5 19 S2 old I3 red 0.5 20 S2 old I4 blue 0.5 21 S2 old I1 red 1.0 22 S2 old I2 blue 1.0 23 S2 old I3 red 1.0 24 S2 old I4 blue 1.0 25 S3 young I1 red 0.0 26 S3 young I2 blue 0.0 27 S3 young I3 red 0.0 28 S3 young I4 blue 0.0 29 S3 young I1 red 0.5 30 S3 young I2 blue 0.5 31 S3 young I3 red 0.5 32 S3 young I4 blue 0.5 33 S3 young I1 red 1.0 34 S3 young I2 blue 1.0 35 S3 young I3 red 1.0 36 S3 young I4 blue 1.0 37 S4 old I1 red 0.0 38 S4 old I2 blue 0.0 39 S4 old I3 red 0.0 40 S4 old I4 blue 0.0 41 S4 old I1 red 0.5 42 S4 old I2 blue 0.5 43 S4 old I3 red 0.5 44 S4 old I4 blue 0.5 45 S4 old I1 red 1.0 46 S4 old I2 blue 1.0 47 S4 old I3 red 1.0 48 S4 old I4 blue 1.0 49 S5 young I1 red 0.0 50 S5 young I2 blue 0.0 51 S5 young I3 red 0.0 52 S5 young I4 blue 0.0 53 S5 young I1 red 0.5 54 S5 young I2 blue 0.5 55 S5 young I3 red 0.5 56 S5 young I4 blue 0.5 57 S5 young I1 red 1.0 58 S5 young I2 blue 1.0 59 S5 young I3 red 1.0 60 S5 young I4 blue 1.0 61 S6 old I1 red 0.0 62 S6 old I2 blue 0.0 63 S6 old I3 red 0.0 64 S6 old I4 blue 0.0 65 S6 old I1 red 0.5 66 S6 old I2 blue 0.5 67 S6 old I3 red 0.5 68 S6 old I4 blue 0.5 69 S6 old I1 red 1.0 70 S6 old I2 blue 1.0 71 S6 old I3 red 1.0 72 S6 old I4 blue 1.0 As with the  SingleSubjectDesign  one can use the  event_order_function  argument to determine the order of events/trials. Important The number of subjects/items has to be a divisor of the number of factor level combinations, i.e. it is assumed that the design is balanced which means that there is an equal number of observations for all possible factor level combinations."},{"id":655,"pagetitle":"Overview: Experimental design types","title":"Repeat designs","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/designtypes/#Repeat-designs","content":" Repeat designs The  RepeatDesign  type is a functionality to encapsulate single- or multi-subject designs. It allows to repeat a generated event table multiple times. In other words, the  RepeatDesign  type allows to have multiple instances of the same item/subject/factor level combination. Example: Assume, we have the following single-subject design from above: Click to expand event table  generate_events(design_single) 6×2 DataFrame Row contrast_level stimulus_type Float64 String 1 0.0 natural 2 0.5 natural 3 1.0 natural 4 0.0 artificial 5 0.5 artificial 6 1.0 artificial But instead of having only one instance of the factor combinations e.g.  stimulus_type :  natural  and  contrast_level :  0 , we will repeat the design three times such that there are three occurrences of each combination. design_repeated = RepeatDesign(design_single, 3);\ngenerate_events(design_repeated) 18×2 DataFrame Row contrast_level stimulus_type Float64 String 1 0.0 natural 2 0.5 natural 3 1.0 natural 4 0.0 artificial 5 0.5 artificial 6 1.0 artificial 7 0.0 natural 8 0.5 natural 9 1.0 natural 10 0.0 artificial 11 0.5 artificial 12 1.0 artificial 13 0.0 natural 14 0.5 natural 15 1.0 natural 16 0.0 artificial 17 0.5 artificial 18 1.0 artificial Here  one can find another example of how to repeat design entries for multi-subject designs. This page was generated using  Literate.jl ."},{"id":658,"pagetitle":"Overview: Noise types","title":"Overview: Noise types","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/noisetypes/#Overview:-Noise-types","content":" Overview: Noise types There are different types of noise signals which differ in their power spectra. If you are not familiar with different types/colors of noise yet, have a look at the  colors of noise Wikipedia page . There are several noise types directly implemented in UnfoldSim.jl. Here is a comparison: using UnfoldSim\nusing CairoMakie\nusing DSP\nusing StableRNGs\nimport StatsBase.autocor\n\nf = Figure()\nax_sig =\n    f[1, 1:3] =\n        Axis(f; title = \"1.000 samples of noise\", xlabel = \"Time\", ylabel = \"Amplitude\")\nax_spec =\n    f[2, 1:2] = Axis(\n        f;\n        title = \"Welch Periodogram\",\n        xlabel = \"Normalized frequency\",\n        ylabel = \"log(Power)\",\n    )\nax_auto =\n    f[2, 3:4] = Axis(\n        f;\n        title = \"Autocorrelogram (every 10th lag)\",\n        xlabel = \"Lag\",\n        ylabel = \"Autocorrelation\",\n    )\nfor n in [PinkNoise RedNoise WhiteNoise NoNoise ExponentialNoise]\n\n    # generate\n    noisevec = simulate_noise(StableRNG(1), n(), 10000)\n\n    # plot 1000 samples\n    lines!(ax_sig, noisevec[1:1000]; label = string(n))\n\n    # calc spectrum\n    perio = welch_pgram(noisevec)\n\n    # plot spectrum\n    lines!(ax_spec, freq(perio), log10.(power(perio)))\n\n    lags = 0:10:500\n    autocor_vec = autocor(noisevec, lags)\n    lines!(ax_auto, lags, autocor_vec)\n\nend\nf[1, 4] = Legend(f, ax_sig, \"Noise type\", tellheight = true)\nf Hint We recommed for smaller signals the  ExponentialNoise , maybe with a removed DC offset or a HighPass filter. For long signals, this Noise requires lots of memory though. maybe Pinknoise is a better choice then. This page was generated using  Literate.jl ."},{"id":661,"pagetitle":"Overview: Onset types","title":"Overview: Onset types","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/onsettypes/#Overview:-Onset-types","content":" Overview: Onset types The onset types determine the distances between event onsets in the continuous EEG signal. The distances are sampled from a certain probability distribution. Currently, there are two types of onset distributions implemented:  UniformOnset  and  LogNormalOnset ."},{"id":662,"pagetitle":"Overview: Onset types","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/onsettypes/#Setup","content":" Setup Click to expand # Load required packages\nusing UnfoldSim\nusing CairoMakie\nusing Random\n\n# Define a simple design and repeat it 10000.\n# This will result in 20000 events i.e. event onsets.\ndesign =\n    SingleSubjectDesign(conditions = Dict(:cond => [\"A\", \"B\"])) |>\n    x -> RepeatDesign(x, 10000);"},{"id":663,"pagetitle":"Overview: Onset types","title":"UniformOnset","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/onsettypes/#UniformOnset","content":" UniformOnset The  UniformOnset  is based on a uniform distribution and has two parameters:  width  and  offset . Example: onset_uniform = UniformOnset(; width = 50, offset = 0); The  width  parameter defines the upper bound of the interval of the uniform distribution (its lower bound is 0) i.e. all values between 0 and  width  are equally probable. The  offset  parameter determines the minimal distance between two events and its value is added to the value sampled from the uniform distribution i.e. it shifts the distribution. Its default value is  0 , i.e. no offset. In the figure below, it is illustrated how the onset distribution changes when changing one of its parameters. Click to show the code for the figure above let\n    f = Figure()\n\n    # Define parameter combinations\n    parameters = [(((50, 0), (80, 0)), \"width\"), (((50, 0), (50, 20)), \"offset\")]\n\n    axes_list = Array{Any}(undef, length(parameters))\n\n    # Create a subplot for each parameter i.e. one for width and one for offset\n    for (index, (combinations, label)) in enumerate(parameters)\n        ax = Axis(f[index, 1], title = \"Parameter: $label\")\n        axes_list[index] = ax\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets\n        for (width, offset) in combinations\n            onsets = UnfoldSim.simulate_interonset_distances(\n                MersenneTwister(42),\n                UniformOnset(; width = width, offset = offset),\n                design,\n            )\n\n            hist!(ax, onsets, bins = range(0, 100, step = 1), label = \"($width, $offset)\")\n\n            if label == \"offset\" && offset != 0\n                vlines!(offset, color = \"black\")\n            end\n        end\n        hideydecorations!(ax)\n        hidespines!(ax, :t, :r)\n        axislegend(\n            ax,\n            framevisible = false,\n            labelsize = 12,\n            markersize = 5,\n            patchsize = (10, 10),\n        )\n    end\n    axes_list[end].xlabel = \"Time between events [samples]\"\n    linkyaxes!(axes_list...)\nend"},{"id":664,"pagetitle":"Overview: Onset types","title":"LogNormalOnset","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/onsettypes/#LogNormalOnset","content":" LogNormalOnset The  LogNormalOnset  is based on a log-normal distribution and has four parameters:  μ ,  σ ,  offset  and  truncate_upper . Example: onset_lognormal = LogNormalOnset(; μ = 3, σ = 0.25, offset = 0, truncate_upper = nothing); The parameters  μ  and  σ  are the location and scale parameter of the log-normal distribution. However, they are not identical to its mean and standard deviation. If a variable  $X$  is log-normally distributed then  $Y = ln(X)$  is normally distributed with mean  μ  and standard deviation  σ [1] . The  offset  parameter determines the minimal distance between two events and its value is added to the value sampled from the log-normal distribution i.e. it shifts the distribution. Its default value is  0 , i.e. no offset. The  truncate_upper  parameter allows to truncate the distribution at a certain sample value. Its default value is  nothing , i.e. no truncation. In the figure below, it is illustrated how the onset distribution changes when changing one of its parameters. Click to show the code for the figure above let\n    f = Figure(size = (600, 800))\n\n    # Define parameter combinations\n    parameters = [\n        (((3, 0.25, 0, nothing), (2.5, 0.25, 0, nothing)), \"μ\"),\n        (((3, 0.25, 0, nothing), (3, 0.35, 0, nothing)), \"σ\"),\n        (((3, 0.25, 0, nothing), (3, 0.25, 30, nothing)), \"offset\"),\n        (((3, 0.25, 0, nothing), (3, 0.25, 0, 25)), \"truncate_upper\"),\n    ]\n\n    axes_list = Array{Any}(undef, length(parameters))\n\n    # Create a subplot for each parameter i.e. one for μ, one for σ etc\n    for (index, (combinations, label)) in enumerate(parameters)\n        ax = Axis(f[index, 1], title = \"Parameter: $label\")\n        axes_list[index] = ax\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets\n        for (μ, σ, offset, truncate_upper) in combinations\n            onsets = UnfoldSim.simulate_interonset_distances(\n                MersenneTwister(42),\n                LogNormalOnset(;\n                    μ = μ,\n                    σ = σ,\n                    offset = offset,\n                    truncate_upper = truncate_upper,\n                ),\n                design,\n            )\n\n            hist!(\n                ax,\n                onsets,\n                bins = range(0, 100, step = 1),\n                label = \"($μ,$σ,$offset,$truncate_upper)\",\n            )\n\n            if label == \"offset\" && offset !== 0\n                vlines!(offset, color = \"black\")\n            elseif label == \"truncate_upper\" && truncate_upper !== nothing\n                vlines!(truncate_upper, color = \"black\")\n            end\n        end\n        hideydecorations!(ax)\n        hidespines!(ax, :t, :r)\n        axislegend(\n            ax,\n            framevisible = false,\n            labelsize = 12,\n            markersize = 5,\n            patchsize = (10, 10),\n        )\n    end\n    axes_list[end].xlabel = \"Time between events [samples]\"\n    linkyaxes!(axes_list...)\nend"},{"id":665,"pagetitle":"Overview: Onset types","title":"Overlap of subsequent events","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/onsettypes/#Overlap-of-subsequent-events","content":" Overlap of subsequent events Note The overlap of subsequent events can be indirectly controlled by setting the  offset  parameter relative to the length of the component basis.   Assuming that  signal  is a component e.g.  LinearModelComponent , if  offset  >  length(signal.basis)  -> no overlap if  offset  <  length(signal.basis)  -> there might be overlap, depending on the other parameters of the onset distribution This page was generated using  Literate.jl . 1 Wikipedia contributors. (2023, December 5). Log-normal distribution. In Wikipedia, The Free Encyclopedia. Retrieved 12:27, December 7, 2023, from https://en.wikipedia.org/w/index.php?title=Log-normal_distribution&oldid=1188400077#"},{"id":668,"pagetitle":"Overview of functionality","title":"Overview of functionality","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/overview/#Overview-of-functionality","content":" Overview of functionality A UnfoldSim simulation has four ingredients: Design, Component, Onset and Noise. Here we provide a short overview of the implemented types."},{"id":669,"pagetitle":"Overview of functionality","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/overview/#Setup","content":" Setup Click to expand # Load required packages\nusing UnfoldSim\nusing InteractiveUtils"},{"id":670,"pagetitle":"Overview of functionality","title":"Design","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/overview/#Design","content":" Design Designs define the experimental design. They can be nested, e.g.  RepeatDesign(SingleSubjectDesign,10)  would repeat the generated design-dataframe 10x. subtypes(AbstractDesign) 3-element Vector{Any}:\n MultiSubjectDesign\n RepeatDesign\n SingleSubjectDesign"},{"id":671,"pagetitle":"Overview of functionality","title":"Component","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/overview/#Component","content":" Component Components define a signal. Some components can be nested, e.g.  LinearModelComponent|>MultichannelComponent , see the multi-channel tutorial for more information. subtypes(AbstractComponent) 3-element Vector{Any}:\n LinearModelComponent\n MixedModelComponent\n MultichannelComponent"},{"id":672,"pagetitle":"Overview of functionality","title":"Onsets","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/overview/#Onsets","content":" Onsets Onsets define the distance between events in the continuous signal. subtypes(AbstractOnset) 3-element Vector{Any}:\n LogNormalOnset\n NoOnset\n UniformOnset"},{"id":673,"pagetitle":"Overview of functionality","title":"Noise","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/reference/overview/#Noise","content":" Noise Choose the noise you need! subtypes(AbstractNoise) 7-element Vector{Any}:\n ExponentialNoise\n NoNoise\n PinkNoise\n RedNoise\n UnfoldSim.AutoRegressiveNoise\n UnfoldSim.RealisticNoise\n WhiteNoise This page was generated using  Literate.jl ."},{"id":676,"pagetitle":"Multi-subject simulation","title":"Multi-subject simulation","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/multisubject/#Multi-subject-simulation","content":" Multi-subject simulation In this tutorial, you will learn how to simulate data for multiple subjects. In particular, you will learn how to specify fixed and random effects and what their influence on the simulated data looks like."},{"id":677,"pagetitle":"Multi-subject simulation","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/multisubject/#Setup","content":" Setup Click to expand # Load required packages\nusing UnfoldSim\nusing Unfold\nusing CairoMakie\nusing UnfoldMakie\nusing DataFrames Similar to the single subject case, multi-subject simulation depends on: Design  (typically a  MultiSubjectDesign ) Components  (typically a  MixedModelComponent ) Onset  (any) Noise  (any)"},{"id":678,"pagetitle":"Multi-subject simulation","title":"Design","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/multisubject/#Design","content":" Design Our first design should be 20 subjects, with 4 items each. Any individual image is shown only either as large or small, thus we choose  items_between . design = MultiSubjectDesign(\n    n_subjects = 20,\n    n_items = 4,\n    items_between = Dict(:condition => [\"large\", \"small\"]),\n) MultiSubjectDesign\n  n_subjects: Int64 20\n  n_items: Int64 4\n  subjects_between: Dict{Symbol, Vector}\n  items_between: Dict{Symbol, Vector}\n  both_within: Dict{Symbol, Vector}\n  event_order_function: #10 (function of type UnfoldSim.var\"#10#14\")\n"},{"id":679,"pagetitle":"Multi-subject simulation","title":"Between, within?","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/multisubject/#Between,-within?","content":" Between, within? In the beginning, the distinction between  between-items ,  between-subjects  and  within-subjects ,  within-items  and  both-between ,  both-within  feels daunting. We base our terminology on  MixedModelsSim  which uses the following definitions: subjects_between  -> effects between subjects, e.g. young vs old items_between  -> effects between items, e.g. natural vs artificial images, (but shown to all subjects if not specified in subjects_between as well) both_within  -> effects completly crossed, e.g. word vs. scramble, where the \"original\" word is the item, and shown to all subjects"},{"id":680,"pagetitle":"Multi-subject simulation","title":"Components","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/multisubject/#Components","content":" Components For multi-subject, similar to the  LinearModelComponent  specified before, we have to define the fixed effect  β , the model parameters that are applied to all subjects. β = [1, 2] # 1 = intercept, 2 = difference between large and small 2-element Vector{Int64}:\n 1\n 2 In addition, we have to provide random effects  σs , which define the spread (and  correlation) of the subjects around the fixed effects, foreach parameter σs = Dict(\n    :subject => [0.5, 1], # we have more spread in the condition-effect\n    :item => [1], # the item-variability is higher than the subject-variability\n) Dict{Symbol, Vector} with 2 entries:\n  :item    => [1]\n  :subject => [0.5, 1.0] now we are ready to assemble the parts signal = MixedModelComponent(;\n    basis = UnfoldSim.hanning(50),\n    formula = @formula(0 ~ 1 + condition + (1 + condition | subject) + (1 | item)),\n    β = β,\n    σs = σs,\n    contrasts = Dict(:condition => EffectsCoding()), # we highly recommend specifying your contrasts, by Default its Dummy/ReferenceCoding with alphabetically sorted levels (relying 100% on StatsModels.jl)\n) MixedModelComponent\n  basis: Array{Float64}((50,)) [0.0, 0.004104993088376974, 0.016352568480485274, 0.03654162132698918, 0.0643406479383053, 0.09929318906602175, 0.14082532495113625, 0.18825509907063326, 0.24080371584473748, 0.2976083284388031  …  0.2976083284388031, 0.24080371584473748, 0.18825509907063326, 0.14082532495113625, 0.09929318906602175, 0.0643406479383053, 0.03654162132698918, 0.016352568480485274, 0.004104993088376974, 0.0]\n  formula: StatsModels.FormulaTerm{StatsModels.ConstantTerm{Int64}, Tuple{StatsModels.ConstantTerm{Int64}, StatsModels.Term, StatsModels.FunctionTerm{typeof(|), Vector{StatsModels.AbstractTerm}}, StatsModels.FunctionTerm{typeof(|), Vector{StatsModels.AbstractTerm}}}}\n  β: Array{Int64}((2,)) [1, 2]\n  σs: Dict{Symbol, Vector}\n  contrasts: Dict{Symbol, EffectsCoding}\n and simulate! data, evts = simulate(design, signal, NoOnset(), NoNoise(), return_epoched = true); ┌ Warning:  No random generator defined, used the default (`Random.MersenneTwister(1)`) with a fixed seed. This will always return the same results and the user is strongly encouraged to provide their own random generator!\n └  @ UnfoldSim ~/work/UnfoldSim.jl/UnfoldSim.jl/src/simulation.jl:17 We get data with 50 samples (our  basis  from above), with  4  items and 20 subjects. We get items and subjects separately because we chose no-overlap (via  NoOnset ) and  return_epoched = true `. size(data)\n\nfirst(evts, 5) 5×3 DataFrame Row subject item condition String String String 1 S01 I1 large 2 S01 I2 small 3 S01 I3 large 4 S01 I4 small 5 S02 I1 large Finally, let's plot the data f = Figure()\n\nfor k = 1:4\n    series(\n        f[1, k],\n        data[:, k, :]',\n        solid_color = :black,\n        axis = (; limits = ((0, 50), (-5, 6))),\n    )\n    Label(f[1, k, Top()], text = \"Item:\" * evts[k, :item] * \", c:\" * evts[k, :condition])\nend\nf Some remarks on interpreting the plot: The β main-effect of small (#2 and #4) vs. large (#1 and #3) is clearly visible. The variability between subjects, is the variability between the individual curves. The item effect shows up e.g. that #2 vs. #4 column show different values."},{"id":681,"pagetitle":"Multi-subject simulation","title":"Continuous Signals / Overlap","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/multisubject/#Continuous-Signals-/-Overlap","content":" Continuous Signals / Overlap Let's continue our tutorial and simulate overlapping signals instead. We replace the  NoOnset  with an  UniformOnset  with 20 to 70 samples between subsequent events.  We further remove the  return_epoched , because we want to have continuous data for now. data, evts = simulate(design, signal, UniformOnset(offset = 20, width = 50), NoNoise());\nsize(data) (275, 20) with the first dimension being continuous data, and the latter still the subjects. series(data', solid_color = :black) Each line is one subject, and it looks a bit unstructured, because the event-onsets are of course random for each subject. Note All subjects have the same sequence of trials, if you need to change this, specify a  event_order_function  in the  MultiSubjectDesign ."},{"id":682,"pagetitle":"Multi-subject simulation","title":"Analyzing these data with Unfold.jl","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/multisubject/#Analyzing-these-data-with-Unfold.jl","content":" Analyzing these data with Unfold.jl We will analyze these data using the  Unfold.jl  toolbox. While preliminary support for deconvolution (overlap correction) for mixed models is available, here we will not make use of it, but rather apply a MixedModel to each timepoint, following the Mass-univariate approach. data, evts = simulate(\n    design,\n    signal,\n    UniformOnset(offset = 20, width = 50),\n    NoNoise();\n    return_epoched = true,\n);\nsize(data) (50, 4, 20) For Unfold.jl, we have to reshape the data, so that all subjects are concatenated. data = reshape(data, size(data, 1), :)\ntimes = range(0, 1, length = size(data, 1))\nm = fit(\n    UnfoldModel,\n    @formula(0 ~ 1 + condition + (1 | item) + (1 + condition | subject)),\n    evts,\n    data,\n    times,\n)\nplot_erp(coeftable(m), mapping = (; col = :group)) The first column shows the fixed effects, the latter the item and subject random effects as they evolve across time This page was generated using  Literate.jl ."},{"id":685,"pagetitle":"Power analysis","title":"Power analysis","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/poweranalysis/#Power-analysis","content":" Power analysis For a power analysis, we will repeatedly simulate data, and check whether we can find a significant effect. We perform the power analysis on epoched data."},{"id":686,"pagetitle":"Power analysis","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/poweranalysis/#Setup","content":" Setup Click to expand # Load required packages\nusing UnfoldSim\nusing Statistics\nusing HypothesisTests\nusing DataFrames\nusing Random"},{"id":687,"pagetitle":"Power analysis","title":"Simulation loop","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/poweranalysis/#Simulation-loop","content":" Simulation loop pvals = fill(NaN, 100)\n@time for seed in eachindex(pvals)\n    # Simulate data of 30 subjects\n    data, evts = UnfoldSim.predef_2x2(\n        MersenneTwister(seed);\n        n_subjects = 20, ## 30 subjects\n        overlap = (1, 0), ## deactivate overlap\n        noiselevel = 10,  ## add more noise to make it more challenging\n        return_epoched = true, ## saves us the epoching step\n    )\n\n\n    # take the mean over a pre-specified timewindow\n    evts.y = dropdims(mean(data[40:60, :, :], dims = 1), dims = (1))[:]\n\n    # extract the two levels of condition A\n    evts_reduced = combine(groupby(evts, [:subject, :A]), :y => mean)\n    y_big = evts_reduced[evts_reduced.A.==\"a_big\", :y_mean]\n    y_small = evts_reduced[evts_reduced.A.==\"a_small\", :y_mean]\n\n    # calculate a one-sided t-test\n    pvals[seed] = pvalue(OneSampleTTest(y_big, y_small))\nend  11.866674 seconds (22.77 M allocations: 3.059 GiB, 8.84% gc time, 80.05% compilation time: 14% of which was recompilation) Let's calculate the power power = mean(pvals .< 0.05) * 100 61.0 This page was generated using  Literate.jl ."},{"id":690,"pagetitle":"Quickstart","title":"Quickstart","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/quickstart/#Quickstart","content":" Quickstart To get started with data simulation, the user needs to provide four ingredients: an experimental design, defining which conditions and how many events/\"trials\" exist an event basis function, defining the simulated event-related response for every event (e.g. the ERP shape in EEG) an inter-onset event distribution, defining the distances in time of the event sequence a noise specification, defining the type of noise signal that is added to the simulated signal (e.g. pink noise) Tip Use  subtypes(AbstractNoise)  (or  subtypes(AbstractComponent)  etc.) to find already implemented building blocks."},{"id":691,"pagetitle":"Quickstart","title":"Specify the simulation ingredients","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/quickstart/#Specify-the-simulation-ingredients","content":" Specify the simulation ingredients"},{"id":692,"pagetitle":"Quickstart","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/quickstart/#Setup","content":" Setup Click to expand # Load required packages\nusing UnfoldSim\nusing Random # to get an RNG\nusing CairoMakie # for plotting"},{"id":693,"pagetitle":"Quickstart","title":"Experimental Design","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/quickstart/#Experimental-Design","content":" Experimental Design Define a 1 x 2 design with 20 trials. That is, one condition ( cond_A ) with two levels. design =\n    SingleSubjectDesign(; conditions = Dict(:cond_A => [\"level_A\", \"level_B\"])) |>\n    x -> RepeatDesign(x, 10);"},{"id":694,"pagetitle":"Quickstart","title":"Event basis function (Component)","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/quickstart/#Event-basis-function-(Component)","content":" Event basis function (Component) Define a simple component and ground truth simulation formula. Akin to ERP components, we call one simulation signal a component. Note You could easily specify multiple components by providing a vector of components, which are automatically added at the same onsets. This procedure simplifies to generate some response that is independent of simulated condition, whereas other depends on it. signal = LinearModelComponent(;\n    basis = [0, 0, 0, 0.5, 1, 1, 0.5, 0, 0],\n    formula = @formula(0 ~ 1 + cond_A),\n    β = [1, 0.5],\n);"},{"id":695,"pagetitle":"Quickstart","title":"Onsets and Noise","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/quickstart/#Onsets-and-Noise","content":" Onsets and Noise We will start with a uniform (but overlapping,  offset  <  length(signal.basis) ) inter-onset distribution. onset = UniformOnset(; width = 20, offset = 4); And we will use some noise noise = PinkNoise(; noiselevel = 0.2);"},{"id":696,"pagetitle":"Quickstart","title":"Combine & Generate","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/quickstart/#Combine-and-Generate","content":" Combine & Generate Finally, we will combine all ingredients and simulate some data. data, events = simulate(MersenneTwister(1), design, signal, onset, noise); data  is a  n-sample  Vector (but could be a Matrix for e.g.  MultiSubjectDesign  or epoched data). events  is a DataFrame that contains a column  latency  with the onsets of events (in samples)."},{"id":697,"pagetitle":"Quickstart","title":"Plot them!","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/quickstart/#Plot-them!","content":" Plot them! lines(data; color = \"black\")\nvlines!(events.latency; color = [\"orange\", \"teal\"][1 .+ (events.cond_A.==\"level_B\")])\n\ncurrent_axis().title = \"Simulated data\"\ncurrent_axis().xlabel = \"Time [samples]\"\ncurrent_axis().ylabel = \"Amplitude [μV]\"\n\ncurrent_figure() This page was generated using  Literate.jl ."},{"id":700,"pagetitle":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/simulateERP/#Simulate-event-related-potentials-(ERPs)","content":" Simulate event-related potentials (ERPs) One subfield of EEG research focuses on so-called event-related potentials (ERPs) which are defined as brain responses time-locked to a certain event e.g. stimulus onset. The waveform of an ERP usually consists of multiple ERP components which denote the peaks and troughs of the waveform. ERP components are characterized (and named) by their timing relative to the event, their polarity (positive or negative) and their scalp topography. For example, the N170 describes a negative deflection which occurrs roughly 170 ms after the onset of (certain) visual stimuli. Often, researchers are interested how a component (e.g. its amplitude or timing) changes depending on certain experimental factors. For example, N170 has been shown to be related to face processing and its amplitude is modulated by whether the stimulus is a face or an object e.g. a car. ( Source ) Here we will learn how to simulate a typical ERP complex with P100, N170, P300."},{"id":701,"pagetitle":"Simulate event-related potentials (ERPs)","title":"Setup","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/simulateERP/#Setup","content":" Setup Click to expand # Load required packages\nusing UnfoldSim # For simulation\nusing Random # For randomization\nusing StableRNGs # To get an RNG\nusing Unfold # For analysis\nusing CairoMakie # For plotting\nusing UnfoldMakie # For plotting"},{"id":702,"pagetitle":"Simulate event-related potentials (ERPs)","title":"Specify the simulation \"ingredients\"","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/simulateERP/#Specify-the-simulation-\"ingredients\"","content":" Specify the simulation \"ingredients\""},{"id":703,"pagetitle":"Simulate event-related potentials (ERPs)","title":"1. Experimental design","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/simulateERP/#1.-Experimental-design","content":" 1. Experimental design We specify an experimental design with one subject in two experimental conditions including a continuous variable with 10 values. To mimic randomization in an experiment, we shuffle the trials using the  event_order_function  argument. To generate more trials we repeat the design 100 times which results in 2000 trials in total. design =\n    SingleSubjectDesign(;\n        conditions = Dict(\n            :condition => [\"car\", \"face\"],\n            :continuous => range(0, 5, length = 10),\n        ),\n        event_order_function = shuffle,\n    ) |> x -> RepeatDesign(x, 100); The  generate_events  function can be used to create an events data frame from the specified experimental design. events_df = generate_events(StableRNG(1), design);\nfirst(events_df, 5) 5×2 DataFrame Row continuous condition Float64 String 1 2.22222 face 2 4.44444 car 3 3.88889 car 4 1.11111 car 5 0.555556 car Above you can see the first five rows extracted from the events data frame representing the experimental design. Each row corresponds to one event. The columns  continuous  and  condition  display the levels of the predictor variables for the specific event."},{"id":704,"pagetitle":"Simulate event-related potentials (ERPs)","title":"2. Event basis functions (Components)","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/simulateERP/#2.-Event-basis-functions-(Components)","content":" 2. Event basis functions (Components) Next, we create a signal consisting of three different components. For the first component, we use the prespecified  P100  base which will be unaffected by our design and has an amplitude of 5 µV. p1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [5]); For the second component, we use the prespecified  N170  base with an intercept of 5 µV and a condition effect of 3 µV for the “face/car” condition i.e. faces will have a more negative signal than cars. n1 = LinearModelComponent(;\n    basis = n170(),\n    formula = @formula(0 ~ 1 + condition),\n    β = [5, 3],\n); For the third component, we use the prespecified  P300  base and include a linear and a quadratic effect of the continuous variable: the larger the value of the continuous variable, the larger the simulated potential. p3 = LinearModelComponent(;\n    basis = p300(),\n    formula = @formula(0 ~ 1 + continuous + continuous^2),\n    β = [5, 1, 0.2],\n);"},{"id":705,"pagetitle":"Simulate event-related potentials (ERPs)","title":"3. Inter-onset distribution","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/simulateERP/#3.-Inter-onset-distribution","content":" 3. Inter-onset distribution In the next step, we specify an inter-onset distribution, in this case, a uniform distribution with an inter-event distance of exactly 200 samples. onset = UniformOnset(; width = 0, offset = 200);"},{"id":706,"pagetitle":"Simulate event-related potentials (ERPs)","title":"4. Noise specification","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/simulateERP/#4.-Noise-specification","content":" 4. Noise specification As the last ingredient, we specify the  noise , in this case, Pink noise. noise = PinkNoise(; noiselevel = 2);"},{"id":707,"pagetitle":"Simulate event-related potentials (ERPs)","title":"Simulate data","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/simulateERP/#Simulate-data","content":" Simulate data Finally, we combine all the ingredients and simulate data. To make the simulation reproducible, one can specify a random generator. # Combine the components in a vector\ncomponents = [p1, n1, p3]\n\n# Simulate data\neeg_data, events_df = simulate(StableRNG(1), design, components, onset, noise); To inspect the simulated data we will visualize the first 1400 samples. Click to show the code for the figure below f = Figure(size = (1000, 400))\nax = Axis(\n    f[1, 1],\n    title = \"Simulated EEG data\",\n    titlesize = 18,\n    xlabel = \"Time [samples]\",\n    ylabel = \"Amplitude [µV]\",\n    xlabelsize = 16,\n    ylabelsize = 16,\n    xgridvisible = false,\n    ygridvisible = false,\n)\n\nn_samples = 1400\nlines!(eeg_data[1:n_samples]; color = \"black\")\nv_lines = [\n    vlines!(\n        [r[\"latency\"]];\n        color = [\"orange\", \"teal\"][1+(r[\"condition\"]==\"car\")],\n        label = r[\"condition\"],\n    ) for r in\n    filter(:latency => x -> x < n_samples, events_df)[:, [\"latency\", \"condition\"]] |>\n    eachrow\n]\nxlims!(ax, 0, n_samples)\naxislegend(\"Event onset\"; unique = true); current_figure() The vertical lines denote the event onsets and their colour represents the respective condition i.e. car or face."},{"id":708,"pagetitle":"Simulate event-related potentials (ERPs)","title":"Validate the simulation results","ref":"/UnfoldDocs/UnfoldSim.jl/stable/generated/tutorials/simulateERP/#Validate-the-simulation-results","content":" Validate the simulation results To validate the simulation results, we use the  Unfold.jl  package  to fit an Unfold regression model to the simulated data and examine the estimated regression parameters and marginal effects. For the formula, we include a categorical predictor for  condition  and a non-linear predictor (based on splines) for  continuous . m = fit(\n    UnfoldModel,\n    [\n        Any => (\n            @formula(0 ~ 1 + condition + spl(continuous, 4)),\n            firbasis(τ = [-0.1, 1], sfreq = 100, name = \"basis\"),\n        ),\n    ],\n    events_df,\n    eeg_data,\n); To inspect the modelling results we will visualize the model coefficient estimates together with the estimated marginal effects i.e. the predicted ERPs. Click to show the code for the figure below # Create a data frame with the model coefficients and extract the coefficient names\ncoefs = coeftable(m)\ncoefnames = unique(coefs.coefname)\n\nf2 = Figure(size = (1000, 400))\nga = f2[1, 1] = GridLayout()\ngb = f2[1, 2] = GridLayout()\n\n# Plot A: Estimated regression parameters\nax_A = Axis(\n    ga[1, 1],\n    title = \"Estimated regression parameters\",\n    titlegap = 12,\n    xlabel = \"Time [s]\",\n    ylabel = \"Amplitude [μV]\",\n    xlabelsize = 16,\n    ylabelsize = 16,\n    xgridvisible = false,\n    ygridvisible = false,\n)\n\nfor coef in coefnames\n    estimate = filter(:coefname => ==(coef), coefs)\n\n    lines!(ax_A, estimate.time, estimate.estimate, label = coef)\nend\naxislegend(\"Coefficient\", framevisible = false)\nhidespines!(ax_A, :t, :r)\n\n# Plot B: Marginal effects\nplot_B = plot_erp!(\n    gb,\n    effects(Dict(:condition => [\"car\", \"face\"], :continuous => 0:0.5:5), m);\n    mapping = (; color = :continuous, linestyle = :condition, group = :continuous),\n    legend = (; valign = :top, halign = :right),\n    axis = (\n        title = \"Marginal effects\",\n        titlegap = 12,\n        xlabel = \"Time [s]\",\n        ylabel = \"Amplitude [μV]\",\n        xlabelsize = 16,\n        ylabelsize = 16,\n        xgridvisible = false,\n        ygridvisible = false,\n    ),\n)\n\n# Add letter labels to the plots\n# Adapted from: https://docs.makie.org/stable/tutorials/layout-tutorial/\nfor (label, layout) in zip([\"A\", \"B\"], [ga, gb])\n    Label(\n        layout[1, 1, TopLeft()],\n        label,\n        fontsize = 26,\n        font = :bold,\n        padding = (0, 5, 5, 0),\n        halign = :right,\n    )\nend current_figure() In subplot A, one can see the model coefficient estimates and as intended the first component is unaffected by the experimental design, there is a condition effect in the second component and an effect of the continuous variable on the third component. The relation between the levels of the continuous variable and the scaling of the third component is even clearer visible in subplot B which depicts the estimated marginal effects of the predictors which are obtained by evaluating the estimated function at specific values of the continuous variable. As shown in this example,  UnfoldSim.jl  and  Unfold.jl  can be easily combined to investigate the effects of certain features, e.g. the type of noise or its intensity on the analysis result and thereby assess the robustness of the analysis. This page was generated using  Literate.jl ."},{"id":711,"pagetitle":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","ref":"/UnfoldDocs/UnfoldSim.jl/stable/installation/#Installing-Julia-and-UnfoldSim.jl","content":" Installing Julia & UnfoldSim.jl"},{"id":712,"pagetitle":"Installing Julia & UnfoldSim.jl","title":"Installing Julia","ref":"/UnfoldDocs/UnfoldSim.jl/stable/installation/#Installing-Julia","content":" Installing Julia The recommended way to install julia is  juliaup . TL;DR: If you don't want to read the explicit instructions, just copy the following command: Windows:  winget install julia -s msstore Mac/Linux:  curl -fsSL https://install.julialang.org | sh We further recommend to use  VSCode  and install the  Julia Extension ."},{"id":713,"pagetitle":"Installing Julia & UnfoldSim.jl","title":"Installing UnfoldSim.jl","ref":"/UnfoldDocs/UnfoldSim.jl/stable/installation/#Installing-UnfoldSim.jl","content":" Installing UnfoldSim.jl The following instructions are intended for Julia beginners. More advanced Julia users can jump ahead to step 3."},{"id":714,"pagetitle":"Installing Julia & UnfoldSim.jl","title":"1. Start an interactive Julia session (\"REPL\")","ref":"/UnfoldDocs/UnfoldSim.jl/stable/installation/#1.-Start-an-interactive-Julia-session-(\"REPL\")","content":" 1. Start an interactive Julia session (\"REPL\") Option 1: Type  julia  in the command line. Option 2: In VSCode, press  Ctrl + Shift + P  to open the command palette and type in  Julia: Start REPL ."},{"id":715,"pagetitle":"Installing Julia & UnfoldSim.jl","title":"2. Activate your project environment","ref":"/UnfoldDocs/UnfoldSim.jl/stable/installation/#2.-Activate-your-project-environment","content":" 2. Activate your project environment Before installing UnfoldSim.jl make sure that you activated your project environment. Option 1:  cd(\"/path/to/your/project\")  and  ]activate . Option 2:  ]activate /path/to/your/project/ Hint After activating you should see  (environment) pkg>  (where  environment  is the name of your project folder). If you see  (@v1.11) pkg>  instead, you still have to activate your environment. Note that by typing  ]  you enter the Julia package manager. To get back to the Julia REPL, press backspace."},{"id":716,"pagetitle":"Installing Julia & UnfoldSim.jl","title":"3. Install the UnfoldSim.jl package","ref":"/UnfoldDocs/UnfoldSim.jl/stable/installation/#3.-Install-the-UnfoldSim.jl-package","content":" 3. Install the UnfoldSim.jl package If you are not in the package manager anymore, type  ] . Then type  add UnfoldSim . After the installation is finished you can use  using UnfoldSim  in the REPL to import the package."},{"id":719,"pagetitle":"Home","title":"UnfoldStats.jl Documentation","ref":"/UnfoldDocs/UnfoldStats.jl/stable/#UnfoldStats.jl-Documentation","content":" UnfoldStats.jl Documentation Welcome to  UnfoldStats.jl : a Julia package for statistical testing of EEG/ERP data and  Unfold.jl  models."},{"id":720,"pagetitle":"Home","title":"Key features","ref":"/UnfoldDocs/UnfoldStats.jl/stable/#Key-features","content":" Key features TBD"},{"id":721,"pagetitle":"Home","title":"Installation","ref":"/UnfoldDocs/UnfoldStats.jl/stable/#Installation","content":" Installation julia> using Pkg; Pkg.add(\"UnfoldStats\") For more detailed instructions please refer to  Installing Julia & Unfold Packages ."},{"id":722,"pagetitle":"Home","title":"Usage example","ref":"/UnfoldDocs/UnfoldStats.jl/stable/#Usage-example","content":" Usage example TBD"},{"id":723,"pagetitle":"Home","title":"Where to start: Learning roadmap","ref":"/UnfoldDocs/UnfoldStats.jl/stable/#Where-to-start:-Learning-roadmap","content":" Where to start: Learning roadmap"},{"id":724,"pagetitle":"Home","title":"1. First steps","ref":"/UnfoldDocs/UnfoldStats.jl/stable/#1.-First-steps","content":" 1. First steps 📌 Goal: TBD  🔗 TBD"},{"id":725,"pagetitle":"Home","title":"2. Intermediate topics","ref":"/UnfoldDocs/UnfoldStats.jl/stable/#2.-Intermediate-topics","content":" 2. Intermediate topics 📌 Goal: TBD  🔗 TBD"},{"id":726,"pagetitle":"Home","title":"3. Advanced topics","ref":"/UnfoldDocs/UnfoldStats.jl/stable/#3.-Advanced-topics","content":" 3. Advanced topics 📌 Goal: TBD  🔗 TBD"},{"id":727,"pagetitle":"Home","title":"Statement of need","ref":"/UnfoldDocs/UnfoldStats.jl/stable/#Statement-of-need","content":" Statement of need TBD"},{"id":730,"pagetitle":"API / Docstrings","title":"API / Docstrings","ref":"/UnfoldDocs/UnfoldStats.jl/stable/api/#API-/-Docstrings","content":" API / Docstrings UnfoldStats.contained_or_equal UnfoldStats.extract_coefs UnfoldStats.extract_coefs UnfoldStats.extract_symbol UnfoldStats.get_predictor_string"},{"id":731,"pagetitle":"API / Docstrings","title":"UnfoldStats.contained_or_equal","ref":"/UnfoldDocs/UnfoldStats.jl/stable/api/#UnfoldStats.contained_or_equal-Tuple{Any, Any}","content":" UnfoldStats.contained_or_equal  —  Method contained_or_equal(p, e) Test if  p  equals  e  or whether  e  contains  p  if  e  is a tuple. source"},{"id":732,"pagetitle":"API / Docstrings","title":"UnfoldStats.extract_coefs","ref":"/UnfoldDocs/UnfoldStats.jl/stable/api/#UnfoldStats.extract_coefs-Tuple{Unfold.UnfoldModel, Any, Any}","content":" UnfoldStats.extract_coefs  —  Method extract_coefs(model::UnfoldModel, predictor, basisname) Return the coefficients of an Unfold model for a certain  predictor  and  basisname . For extracting the terms of a predictor variable  predictor  must be a symbol e.g. :continuous. For extracting the intercept  predictor  should be a String, i.e. \"(Intercept)\". basisname  must match one of the basis names which can be found in  coeftable(model) . Note: If a predictor variable has more than one term in the formula (e.g. a spline set, a categorical variable with several levels or an interaction), the coefficients for all terms are returned. The dimensions of the returned coefficients are channel x times x coefficients. source"},{"id":733,"pagetitle":"API / Docstrings","title":"UnfoldStats.extract_coefs","ref":"/UnfoldDocs/UnfoldStats.jl/stable/api/#UnfoldStats.extract_coefs-Tuple{Vector{<:Unfold.UnfoldModel}, Any, Any}","content":" UnfoldStats.extract_coefs  —  Method extract_coefs(models::Vector{<:UnfoldModel}, predictor, basisname) When applied to a vector of Unfold models, extracts the coefficients (matching the predictor and basisname) for all models (usually subjects) and concatenates them. The dimensions of the returned coefficients are channel x times x coefficients x subjects. source"},{"id":734,"pagetitle":"API / Docstrings","title":"UnfoldStats.extract_symbol","ref":"/UnfoldDocs/UnfoldStats.jl/stable/api/#UnfoldStats.extract_symbol-Tuple{StatsModels.AbstractTerm}","content":" UnfoldStats.extract_symbol  —  Method extract_symbol(t::AbstractTerm) Return the symbol(s) underlying a term from a model formula, repeated by their actual coefficient number (after StatsModels.apply_schema). Examples julia> f = @formula 0 ~ 1 + spl(continuous, 4) + continuous + condition + pet + condition & pet\njulia> ... # apply schema using an event dataframe, according to StatsModels\njulia> extract_symbol(f)\n8-element Vector{Any}:\n \"(Intercept)\"\n :continuous\n :continuous\n :continuous\n :continuous\n :condition\n :pet\n (:condition, :pet) We get the actual symbols of each predictor - this is different to a function that would return the symbol for each term, which would be  [\"(Intercept)\", :continuous,:continuous,:condition,:pet,(:condition,:pet) ] The difference between those two cases would get even more stark, if a basisfunction is in play as it timeexpand terms into many more predictors. source"},{"id":735,"pagetitle":"API / Docstrings","title":"UnfoldStats.get_predictor_string","ref":"/UnfoldDocs/UnfoldStats.jl/stable/api/#UnfoldStats.get_predictor_string-Tuple{Symbol}","content":" UnfoldStats.get_predictor_string  —  Method get_predictor_string(p) Return string representation based on the type of  p . This function is used for a useful display of variables e.g. in an error message. Examples julia> UnfoldStats.get_predictor_string(:condition)\n\":condition\" source"},{"id":738,"pagetitle":"MixedModels EEG + Cluster permutation test","title":"0. Setup","ref":"/UnfoldDocs/UnfoldStats.jl/stable/generated/tutorial/lmm_clusterdepth/#0.-Setup","content":" 0. Setup If you want to do LMM + cluster permutations, you at least need these packages (more for the simulation below) using UnfoldMixedModels\nusing MixedModelsPermutations, ClusterDepth\nusing UnfoldStats"},{"id":739,"pagetitle":"MixedModels EEG + Cluster permutation test","title":"1. Simulate data","ref":"/UnfoldDocs/UnfoldStats.jl/stable/generated/tutorial/lmm_clusterdepth/#1.-Simulate-data","content":" 1. Simulate data This section can be skipped, if one already has (real) data that they want to analyse. Click to expand the simulation details using UnfoldSim\nusing StatsModels\nusing Random\n\nsrate = 25\ndesign = MultiSubjectDesign(;\n    n_subjects = 30,\n    n_items = 40,\n    items_between = Dict(:stimtype => [\"car\", \"face\"]),\n)\n#both_within = Dict(:condition=>[\"scrambled\",\"intact\"]))\ncontrasts = Dict(:stimtype => DummyCoding())\np1 = MixedModelComponent(;\n    basis = UnfoldSim.p100(; sfreq = srate),\n    formula = @formula(dv ~ 1 + (1 | subject) + (1 | item)),\n    β = [5.0],\n    σs = Dict(:subject => [0.0], :item => [0.0]),\n    contrasts = contrasts,\n);\n\nn1 = MixedModelComponent(;\n    basis = UnfoldSim.n170(; sfreq = srate),\n    formula = @formula(dv ~ 1 + stimtype + (1 + stimtype | subject) + (1 | item)),\n    β = [1.0, 4], # n170-basis is negative\n    σs = Dict(:subject => [2.0, 0.25], :item => [0.25]),\n    contrasts = contrasts,\n);\n\np3 = MixedModelComponent(;\n    basis = UnfoldSim.p300(; sfreq = srate),\n    formula = @formula(dv ~ 1 + (1 | subject) + (1 + stimtype | item)),\n    β = [4.0],\n    σs = Dict(:subject => [1.0], :item => [0.5, 2]),\n    contrasts = contrasts,\n);\n\n\n\ndata_e, events = UnfoldSim.simulate(\n    design,\n    [p1, n1, p3],\n    UniformOnset(srate * 2, 10),\n    PinkNoise(; noiselevel = 1);\n    return_epoched = true,\n)\ntimes = range(-0.1, 0.5, length = size(data_e, 1))\ndata_e = reshape(data_e, 1, size(data_e, 1), :) ┌ Warning:  No random generator defined, used the default (`Random.MersenneTwister(1)`) with a fixed seed. This will always return the same results and the user is strongly encouraged to provide their own random generator!\n └  @ UnfoldSim ~/.julia/packages/UnfoldSim/JzrqI/src/simulation.jl:17"},{"id":740,"pagetitle":"MixedModels EEG + Cluster permutation test","title":"2. Fit mass-univariate LMMs","ref":"/UnfoldDocs/UnfoldStats.jl/stable/generated/tutorial/lmm_clusterdepth/#2.-Fit-mass-univariate-LMMs","content":" 2. Fit mass-univariate LMMs We have some typical experimental data with subject and item effects. Item refer to stimuli here, based on our  stimtype  condition these are either different  cars  or  faces . m = fit(\n    UnfoldModel,\n    [\n        Any => (\n            @formula(0 ~ 1 + stimtype + (1 + stimtype | item) + (1 + stimtype | subject)),\n            times,\n        ),\n    ],\n    events,\n    data_e,\n); \n Progress:  17%|██████▉                                  |  ETA: 0:00:08 \n    channel: 1 \n       time: 2 \n\n\n\n\n\n Progress: 100%|█████████████████████████████████████████| Time: 0:00:02 \n    channel: 1 \n       time: 12"},{"id":741,"pagetitle":"MixedModels EEG + Cluster permutation test","title":"3. Cluster permutation test","ref":"/UnfoldDocs/UnfoldStats.jl/stable/generated/tutorial/lmm_clusterdepth/#3.-Cluster-permutation-test","content":" 3. Cluster permutation test If we would run a statistical test on each time-point separately, we would greatly inflate the type-1 error, reaching significance on any each sample much higher than the assumed α=0.05. One solution are cluster permutation test, where we instead test for clustersizes of connected significant clusters. In \"classical\" two-stage testing, such a permutation test is straight forward. But for LMMs we have to think of something more clever, as it is not directly clear how to permute if both subject and item effects exist (you gonna break the relation between the two). We did that in  MixedModelsPermutations  and can apply this strategy to EEG data as well.` select the fixed-effects coefficient to test ( stimtype ) coefficient = 2; call the permutation test Note This interface is very likely to change in the future pvalue(\n    MersenneTwister(1),\n    m,\n    data_e,\n    coefficient;\n    n_permutations = 20,\n    clusterforming_threshold = 1.8,\n) 1×12 Matrix{Float64}:\n 1.0  1.0  1.0  0.0666667  0.0666667  1.0  1.0  1.0  1.0  1.0  1.0  1.0 This page was generated using  Literate.jl ."},{"id":744,"pagetitle":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"Two-stage EEG analysis using Unfold & UnfoldStats","ref":"/UnfoldDocs/UnfoldStats.jl/stable/generated/tutorial/test_splines/#Two-stage-EEG-analysis-using-Unfold-and-UnfoldStats","content":" Two-stage EEG analysis using Unfold & UnfoldStats"},{"id":745,"pagetitle":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"0. Setup","ref":"/UnfoldDocs/UnfoldStats.jl/stable/generated/tutorial/test_splines/#0.-Setup","content":" 0. Setup Load required packages. using UnfoldStats\nusing Unfold\nusing DataFrames\nusing Chain\nusing Statistics\nusing HypothesisTests\nusing CairoMakie\nusing UnfoldMakie"},{"id":746,"pagetitle":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"1. Simulate data","ref":"/UnfoldDocs/UnfoldStats.jl/stable/generated/tutorial/test_splines/#1.-Simulate-data","content":" 1. Simulate data This section can be skipped, if one already has (real) data that they want to analyse. Click to expand the simulation details using UnfoldSim\nusing StableRNGs\n\ndesign = MultiSubjectDesign(\n    n_subjects = 20,\n    n_items = 100,\n    items_between = Dict(:continuous => range(0, 2, length = 10)),\n)\n\nβ = [1, 1, 0.5, 0.2]\nσs = Dict(:subject => [1, 0.1, 0.1, 0.1])\n\nsignal = MixedModelComponent(;\n    basis = UnfoldSim.hanning(50),\n    formula = @formula(\n        0 ~\n            1 +\n            continuous +\n            continuous^2 +\n            continuous^3 +\n            (1 + continuous + continuous^2 + continuous^3 | subject)\n    ),\n    β = β,\n    σs = σs,\n)\n\nhart = Hartmut()\nsignal_multichannel = MultichannelComponent(signal, hart => \"Left Postcentral Gyrus\")\n\nonset = UniformOnset(; width = 50, offset = 60)\nnoise = PinkNoise(; noiselevel = 5) UnfoldSim.PinkNoise\n  noiselevel: Int64 5\n  func: UnionAll\n data, events = UnfoldSim.simulate(\n    StableRNG(1),\n    design,\n    signal_multichannel,\n    onset,\n    noise,\n    return_epoched = false,\n); Click to expand event data frame  first(events, 12) 12×4 DataFrame Row subject item continuous latency String String Float64 Int64 1 S01 I001 0.0 80 2 S01 I002 0.222222 190 3 S01 I003 0.444444 277 4 S01 I004 0.666667 350 5 S01 I005 0.888889 450 6 S01 I006 1.11111 542 7 S01 I007 1.33333 626 8 S01 I008 1.55556 736 9 S01 I009 1.77778 813 10 S01 I010 2.0 921 11 S01 I011 0.0 986 12 S01 I012 0.222222 1090"},{"id":747,"pagetitle":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"2. Fit an Unfold model for each subject (first stage)","ref":"/UnfoldDocs/UnfoldStats.jl/stable/generated/tutorial/test_splines/#2.-Fit-an-Unfold-model-for-each-subject-(first-stage)","content":" 2. Fit an Unfold model for each subject (first stage) In the first stage, we fit an Unfold model for each subject separately. # Specify a temporal basis function\nbasisfunction = firbasis((-0.1, 0.7), 100)\n\n# Specify the model formula\nformula = @formula 0 ~ 1 + spl(continuous, 4)\n\n# Combine basisfunction and formula in an event dict\nevent_vec = [Any => (formula, basisfunction)]\n\nsubject_list = unique(events.subject)\nmodel_list = UnfoldLinearModelContinuousTime[]\n\n# Slice the data by its last dimension (i.e. the subject dimension)\ndata_slices = eachslice(data, dims = ndims(data))\n\nfor s = 1:size(data, ndims(data))\n    m = fit(\n        UnfoldModel,\n        event_vec,\n        subset(events, :subject => ByRow(==(subject_list[s]))),\n        data_slices[s],\n    )\n    push!(model_list, m)\nend\n\nmodels = DataFrame(subject = subject_list, unfoldmodel = model_list);\nsize(models) (20, 2) As a result, we get a dataframe which contains an Unfold model for each subject."},{"id":748,"pagetitle":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"3. Compute and visualize the marginal effects","ref":"/UnfoldDocs/UnfoldStats.jl/stable/generated/tutorial/test_splines/#3.-Compute-and-visualize-the-marginal-effects","content":" 3. Compute and visualize the marginal effects In the next step, we will compute the marginal effects of the  continuous  predictor i.e. how the prediction changes for different levels of this predictor. First, we compute the marginal effects separately for each subject. Then we aggregate them over subjects using the  mean . # Specify the predictors of interest\npredictor_dict = Dict(:continuous => range(0, 2, length = 3))\n\n# Compute the marginal effects for all subjects separately\neffects_all_subjects = combine(\n    groupby(models, :subject),\n    :unfoldmodel => (m -> effects(predictor_dict, m[1])) => AsTable,\n)\n\n# Aggregate the marginal effects (per event type, time point and channel) over subjects\n# using the mean as aggregation function\naggregated_effects = @chain effects_all_subjects begin\n    groupby([:eventname, :channel, collect(keys(predictor_dict))..., :time])\n    combine(:yhat .=> [x -> mean(skipmissing(x))] .=> Symbol(\"yhat_\", mean))\nend;\nfirst(aggregated_effects, 5) 5×5 DataFrame Row eventname channel continuous time yhat_mean DataType Int64 Float64 Float64 Float64 1 Any 1 0.0 -0.1 0.142467 2 Any 2 0.0 -0.1 0.00223103 3 Any 3 0.0 -0.1 0.0174379 4 Any 4 0.0 -0.1 0.133778 5 Any 5 0.0 -0.1 0.281127 Next, we want to visualize the marginal effects in a topoplot series. For this we first need to extract the electrode positions for our simulated data (or your real data) and project them from 3d to 2d. # Extract the electrode positions for the simulated data from the headmodel\n# and project them from 3d to 2d.\npos3d = hart.electrodes[\"pos\"];\npos2d = to_positions(pos3d')\npos2d = [Point2f(p[1] + 0.5, p[2] + 0.5) for p in pos2d]; For visualization, we use the  plot_topoplotseries  function  from  UnfoldMakie . In the topoplot series, the time in seconds (binned in time windows) is represented from left to right. The rows (from top to bottom) represent the marginal effects for different levels of the predictor  continuous . # Set the size of the time bins for the topoplot series\nbin_width = 0.1\naggregated_effects.estimate = aggregated_effects.yhat_mean # bug in UnfoldMakie 0.5.12\nf_effects = Figure(size = (1200, 600))\ntp_effects = plot_topoplotseries!(\n    f_effects,\n    aggregated_effects;\n    bin_width,\n    positions = pos2d,\n    mapping = (; y = :estimate, row = :continuous),\n    visual = (; enlarge = 0.6, label_scatter = false, colorrange = (-3, 3)),\n)\n\nax = current_axis()\nlinkaxes!(tp_effects.content[1:end-2]...)\nxlims!(ax, 0, 0.9)\nylims!(ax, 0, 0.9)\ncurrent_figure() In the time windows  [0.1, 0.2) ,  [0.2, 0.3)  and  [0.3, 0.4) , one can see the effect of  continuous  that we simulated. In the next section, we want to quantify and test this effect."},{"id":749,"pagetitle":"Two-stage multi parameter test (Hotelling's T-squared test)","title":"4. Extract coefficients & conduct Hotelling's T² tests","ref":"/UnfoldDocs/UnfoldStats.jl/stable/generated/tutorial/test_splines/#4.-Extract-coefficients-and-conduct-Hotelling's-T-tests","content":" 4. Extract coefficients & conduct Hotelling's T² tests We will use a one-sample Hotelling's T² test to test whether at least one of the spline coefficients is different from 0. First, we extract the spline coefficients (for the  continuous  predictor variable) for all subjects. Then we conduct a Hotelling's T² test separately for each channel and time point and extract the correspoding p-value. # Extract the spline coefficients for the `continuous` predictor variable\n# from the Unfold models of all subjects\neventname = unique(effects_all_subjects.eventname)\ncoefs = extract_coefs(models.unfoldmodel, :continuous, eventname)\n\n# Conduct a one-sample Hotelling's T² test separately for all channels and time points\n# and compute a p-value. We compare the spline coefficients vector against 0.\np_values =\n    mapslices(c -> pvalue(OneSampleHotellingT2Test(c', [0, 0, 0])), coefs, dims = (3, 4)) |>\n    x -> dropdims(x, dims = (3, 4));\n\ntimes = unique(effects_all_subjects.time)\nchannels = axes(p_values, 1)\n\n# For visualization purposes, save the p_values in a data frame together with time and channel\np_values_df = DataFrame(\n    channel = repeat(channels, outer = length(times)),\n    time = repeat(times, inner = length(channels)),\n    p_values = p_values[:],\n);\n\nfirst(p_values_df, 5) 5×3 DataFrame Row channel time p_values Int64 Float64 Float64 1 1 -0.1 0.731021 2 2 -0.1 0.411405 3 3 -0.1 0.212582 4 4 -0.1 0.0953801 5 5 -0.1 0.397495 As a last step, we visualize the p-values in a topoplot series. bin_width = 0.1\np_values_df.estimate = p_values_df.p_values\nf_pvalues = Figure(size = (1200, 200))\ntp_pvalues = plot_topoplotseries!(\n    f_pvalues,\n    p_values_df;\n    bin_width,\n    positions = pos2d,\n    mapping = (; y = :estimate),\n    visual = (;\n        enlarge = 0.6,\n        label_scatter = false,\n        colorrange = (0, 0.1),\n        colormap = :Reds,\n    ),\n    colorbar = (; label = \"p-value\", limits = (0, 0.1), ticks = ([0.0, 0.1], [\"0\", \"0.1\"])),\n)\n\nax = current_axis()\ncurrent_figure() Note To decide whether to consider the effect statistically significant and to correct for multiple comparisons (due to different time points and channels), one could conduct a cluster-permutation test using the Hotelling's T² values as the test statistic. This page was generated using  Literate.jl ."},{"id":752,"pagetitle":"Two-stage single parameter test (t-test)","title":"Unfold single parameter cluster permutation testing","ref":"/UnfoldDocs/UnfoldStats.jl/stable/tutorial/test_single_coefficient/#Unfold-single-parameter-cluster-permutation-testing","content":" Unfold single parameter cluster permutation testing This is an adaptation of the  ClusterDepth.jl tutorial . We simulate a 1x2 design and perform cluster permutation testing via the  ClusterDepth.jl  package"},{"id":753,"pagetitle":"Two-stage single parameter test (t-test)","title":"Simulate data","ref":"/UnfoldDocs/UnfoldStats.jl/stable/tutorial/test_single_coefficient/#Simulate-data","content":" Simulate data Let's create data from 20 subjects Click to expand the simulation details using Random\nusing CairoMakie\nusing UnfoldSim\nusing Unfold\nusing UnfoldMakie\nusing Statistics\nusing ClusterDepth\nusing DataFrames\nusing Distributions\n\nn_subjects = 20\ndata,events = UnfoldSim.predef_eeg(n_subjects;return_epoched=true)\ntimes = range(0,step=1/100,length=size(data,1))"},{"id":754,"pagetitle":"Two-stage single parameter test (t-test)","title":"Fitting regression Models","ref":"/UnfoldDocs/UnfoldStats.jl/stable/tutorial/test_single_coefficient/#Fitting-regression-Models","content":" Fitting regression Models Fit an UnfoldModel to each subject: formula = @formula(0 ~ 1 + condition)\nmodels = map((d, ev) -> (fit(UnfoldModel, formula, DataFrame(ev), collect(d), times), ev.subject[1]),\n    eachslice(data; dims=3),\n    groupby(events, :subject)) \n Progress:   4%|█▉                                       |  ETA: 0:00:09 \n Progress: 100%|█████████████████████████████████████████| Time: 0:00:00 now we can inspect the data easily, and extract the face-effect function add_subject!(df, s)\n    df[!, :subject] .= s\n    return df\nend\nallEffects = map((x) -> (effects(Dict(:condition => [\"car\", \"face\"]), x[1]), x[2]) |> (x) -> add_subject!(x[1], x[2]), models) |> e -> reduce(vcat, e)\n\nplot_erp(allEffects; mapping=(color=:condition, group=:subject)) extract the face-coefficient from the linear model allCoefs = map(m -> (coeftable(m[1]), m[2]) |> (x) -> add_subject!(x[1], x[2]), models) |> e -> reduce(vcat, e)\nplot_erp(allCoefs; mapping=(group=:subject, col=:coefname)) let's unstack the tidy-coef table into a matrix and put it to clusterdepth for clusterpermutation testing faceCoefs = allCoefs |> x -> subset(x, :coefname => x -> x .== \"condition: face\")\nerpMatrix = unstack(faceCoefs, :subject, :time, :estimate) |> x -> Matrix(x[:, 2:end])' |> collect\nsummary(erpMatrix) \"45×20 Matrix{Union{Missing, Float64}}\""},{"id":755,"pagetitle":"Two-stage single parameter test (t-test)","title":"Clusterdepth","ref":"/UnfoldDocs/UnfoldStats.jl/stable/tutorial/test_single_coefficient/#Clusterdepth","content":" Clusterdepth pvals = clusterdepth(erpMatrix; τ=quantile(TDist(n_subjects - 1), 0.95), nperm=5000); well - that was fast, less than a second for a cluster permutation test. not bad at all!"},{"id":756,"pagetitle":"Two-stage single parameter test (t-test)","title":"Plotting","ref":"/UnfoldDocs/UnfoldStats.jl/stable/tutorial/test_single_coefficient/#Plotting","content":" Plotting Some plotting, and we add the identified cluster first calculate the ERP faceERP = groupby(faceCoefs, [:time, :coefname]) |>\n          x -> combine(x, :estimate => mean => :estimate,\n    :estimate => std => :stderror); put the significance into a dataframe-form significant_regions_df = ClusterDepth.cluster(pvals .<= 0.05) |> x -> DataFrame(:from => times[x[1]], :to => times[x[1] .+ x[2]] , :coefname => \"condition: face\") 1×3 DataFrame Row from to coefname Float64 Float64 String 1 0.09 0.21 condition: face and plot it! plot_erp(faceERP; stderror=true, significance=significant_regions_df) Looks good to me! We identified the cluster :-)"},{"id":759,"pagetitle":"Home","title":"UnfoldDecode.jl Documentation","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/#UnfoldDecode.jl-Documentation","content":" UnfoldDecode.jl Documentation In UnfoldDecode.jl we develop new approaches, collect other algorithms, and provide tutorials, to decode overlapping and/or covariate-heavy EEG data."},{"id":760,"pagetitle":"Home","title":"Key features","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/#Key-features","content":" Key features This toolbox right now implements: Overlap-corrected decoding ala  Gal Vishne, Leon Deouell et al. Covariate-corrected decoding ala  back-to-back regression, Jean-Remy King et al."},{"id":761,"pagetitle":"Home","title":"Installation","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/#Installation","content":" Installation julia> using Pkg; Pkg.add(\"UnfoldDecode\") For more detailed instructions please refer to  Installing Julia & Unfold Packages ."},{"id":762,"pagetitle":"Home","title":"Usage example","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/#Usage-example","content":" Usage example"},{"id":763,"pagetitle":"Home","title":"Where to start: Learning roadmap","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/#Where-to-start:-Learning-roadmap","content":" Where to start: Learning roadmap"},{"id":764,"pagetitle":"Home","title":"First steps B2B","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/#First-steps-B2B","content":" First steps B2B 📌 Goal: Learn why to use back-to-back regression, next learn how easy it is to apply it to your data  🔗  B2B explained ,  B2B quickstart"},{"id":765,"pagetitle":"Home","title":"First Steps Overlap correction","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/#First-Steps-Overlap-correction","content":" First Steps Overlap correction 📌 Goal: Learn how to run overlap corrected Unfold-style deconvolution models  🔗  overlap-corrected decoding tutorial"},{"id":766,"pagetitle":"Home","title":"Statement of need","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/#Statement-of-need","content":" Statement of need"},{"id":769,"pagetitle":"Overlap corrected, multi-event, many options, LDA","title":"Overlap-corrected decoding","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/HowTo/overlapcorrectedLDA_options/#Overlap-corrected-decoding","content":" Overlap-corrected decoding We will try to introduce as many fancy features as possible Please read the \"tutorial\" first"},{"id":770,"pagetitle":"Overlap corrected, multi-event, many options, LDA","title":"Simulation","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/HowTo/overlapcorrectedLDA_options/#Simulation","content":" Simulation multi-event dat, evt = UnfoldSim.predef_eeg()\nevt.event = rand([\"eventA\", \"eventB\"], size(evt, 1)) # add random events\ndat = repeat(dat', 5)\ndat .= dat .+ 20 .* rand(size(dat)...) 5×120199 Matrix{Float64}:\n 17.9053   8.87049  10.7419   6.66026  …  11.1886    2.38817  13.3819\n 14.3933  15.454    11.7659   4.8754       3.18727   1.37389  19.7361\n 12.4731  18.9506   13.8243  20.5309       8.4603    9.88742   8.92185\n 19.1302  16.534    13.4568  19.2871       7.97039  18.6621    9.28247\n  2.0325   8.48175  15.1328  13.0128      17.7138    8.29587   5.18685"},{"id":771,"pagetitle":"Overlap corrected, multi-event, many options, LDA","title":"Overlap-model Definition","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/HowTo/overlapcorrectedLDA_options/#Overlap-model-Definition","content":" Overlap-model Definition We have two basis functions now, with two different timewindows. Let's see if it works! des = [\n    \"eventA\" => (@formula(0 ~ 1 + condition + continuous), firbasis((-0.1, 1.0), 100)),\n    \"eventB\" => (@formula(0 ~ 1 + continuous), firbasis((-0.3, 0.5), 100)),\n] 2-element Vector{Pair{String, Tuple{StatsModels.FormulaTerm{StatsModels.ConstantTerm{Int64}}, Unfold.FIRBasis}}}:\n \"eventA\" => (0 ~ 1 + condition + continuous, �[0m�[22m╭──────────────────────────────────────────────────────────────────────────────╮�[22m�[0m111×111 SparseArrays.SparseMatrixCSC with 111 stored entries:\n�[22m│�[22m  �[1m�[34m::BasisFunction�[22m�[39m                                                             �[22m│�[22m⎡⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤                                       \n�[22m│�[22m  �[1mname: �[22m�[38;2;144;202;249m�[39m                                                                      �[22m│�[22m⎢⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥                                       \n�[22m│�[22m  �[1mkerneltype: �[22m�[38;2;144;202;249mUnfold.FIRBasis�[39m                                                 �[22m│�[22m⎢⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥                                       \n�[22m│�[22m  �[1mwidth: �[22m�[38;2;144;202;249m111�[39m                                                                  �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥                                       \n�[22m│�[22m  �[1mheight: �[22m�[38;2;144;202;249m111�[39m                                                                 �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥                                       \n�[22m│�[22m  �[1mcolnames: �[22m�[38;2;144;202;249m[-0.1, -0.09 ... 1.0]�[39m                                             �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⎥                                       \n�[22m│�[22m  �[1mtimes: �[22m�[38;2;144;202;249m[-0.1, -0.09 ... 1.0]�[39m                                                �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⎥                                       \n�[22m│�[22m  �[1mcollabel: �[22m�[38;2;144;202;249mtime�[39m                                                              �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⎥                                       \n�[22m│�[22m  �[1mshift_onset: �[22m�[38;2;144;202;249m-10�[39m                                                            �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⎥                                       \n�[22m│�[22m                                                                              �[22m│�[22m⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⎦                                       \n�[0m�[22m╰──────────────────────────────────────────────────────────────────────────────╯�[22m�[0m�[0m                                                             \n)\n \"eventB\" => (0 ~ 1 + continuous, �[0m�[22m╭──────────────────────────────────────────────────────────────────────────────╮�[22m�[0m81×81 SparseArrays.SparseMatrixCSC with 81 stored entries:\n�[22m│�[22m  �[1m�[34m::BasisFunction�[22m�[39m                                                             �[22m│�[22m⎡⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤                                    \n�[22m│�[22m  �[1mname: �[22m�[38;2;144;202;249m�[39m                                                                      �[22m│�[22m⎢⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥                                    \n�[22m│�[22m  �[1mkerneltype: �[22m�[38;2;144;202;249mUnfold.FIRBasis�[39m                                                 �[22m│�[22m⎢⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥                                    \n�[22m│�[22m  �[1mwidth: �[22m�[38;2;144;202;249m81�[39m                                                                   �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥                                    \n�[22m│�[22m  �[1mheight: �[22m�[38;2;144;202;249m81�[39m                                                                  �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥                                    \n�[22m│�[22m  �[1mcolnames: �[22m�[38;2;144;202;249m[-0.3, -0.29 ... 0.5]�[39m                                             �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⎥                                    \n�[22m│�[22m  �[1mtimes: �[22m�[38;2;144;202;249m[-0.3, -0.29 ... 0.5]�[39m                                                �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⎥                                    \n�[22m│�[22m  �[1mcollabel: �[22m�[38;2;144;202;249mtime�[39m                                                              �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⎥                                    \n�[22m│�[22m  �[1mshift_onset: �[22m�[38;2;144;202;249m-30�[39m                                                            �[22m│�[22m⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⎥                                    \n�[22m│�[22m                                                                              �[22m│�[22m⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⎦                                    \n�[0m�[22m╰──────────────────────────────────────────────────────────────────────────────╯�[22m�[0m�[0m                                                          \n) To show that it is possible, we explicitly specify the solver customsolver = (x, y) -> Unfold.solver_default(x, y)\nuf = Unfold.fit(UnfoldModel, des, evt, dat[1, :]; solver = customsolver);\nplot_erp(coeftable(uf); mapping = (; col = :eventname))"},{"id":772,"pagetitle":"Overlap corrected, multi-event, many options, LDA","title":"Fitting the Overlap-corrected LDA model","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/HowTo/overlapcorrectedLDA_options/#Fitting-the-Overlap-corrected-LDA-model","content":" Fitting the Overlap-corrected LDA model using MLJ, MultivariateStats, MLJMultivariateStatsInterface\nLDA = @load LDA pkg = MultivariateStats MLJMultivariateStatsInterface.LDA you could use other parameters, check out  ?LDA ldaModel = LDA(\n    method = :whiten,\n    cov_w = SimpleCovariance(),\n    cov_b = SimpleCovariance(),\n    regcoef = 1e-3,\n)\n\nuf_lda = UnfoldDecode.fit(\n    UnfoldDecodingModel,\n    des,\n    evt,\n    dat,\n    ldaModel,\n    \"eventA\" => :condition;\n    nfolds = 2,# only 2 folds to speed up computation\n    unfold_fit_options = (; solver = customsolver), #customer solver for fun\n    eventcolumn = :event, # actually the default, but maybe your event dataframe has a different name?\n    multithreading = false,\n) # who needs speed anyway :shrug:\n\nplot_erp(coeftable(uf_lda)) Voila, the model classified the correct period at the correct event This page was generated using  Literate.jl ."},{"id":775,"pagetitle":"Why Back2Back","title":"Motivation for BacktoBack","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/explanations/b2b_why/#explainer-b2b","content":" Motivation for BacktoBack"},{"id":776,"pagetitle":"Why Back2Back","title":"Introduction","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/explanations/b2b_why/#Introduction","content":" Introduction “Back-to-Back” regression (B2B) is an approach to estimate the decoding performance from a set of correlated factors. Why do we need this? Let's have a look at a simple example:  Imagine we record EEG data from an eyetracking experiment, and investigate each fixation (a resting period of the eye) as an event for an ERP. Imagine, we have both cats and dogs, but that we also make large and small eye-movements."},{"id":777,"pagetitle":"Why Back2Back","title":"Data generation","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/explanations/b2b_why/#Data-generation","content":" Data generation"},{"id":778,"pagetitle":"Why Back2Back","title":"Simulation and data collection","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/explanations/b2b_why/#Simulation-and-data-collection","content":" Simulation and data collection Collect the data genarated by UnfoldSim, and add certian level of noise dat, evts = UnfoldSim.predef_eeg(; noiselevel = 0.1, return_epoched = true);\nevts = example_rename_events(evts)"},{"id":779,"pagetitle":"Why Back2Back","title":"Data further generating","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/explanations/b2b_why/#Data-further-generating","content":" Data further generating To make the example more impressive, let's add an orthogonal variable  vegetable . But this variable is special: It is correlated with the covariate  eye_movement_size . evts.vegetable .=\n    [\"tomato\", \"carrot\"][1 .+ (evts.eye_movement_size.+10 .* rand(size(evts, 1)).>7.5)];\ncor(evts.eye_movement_size, evts.vegetable .== \"carrot\") Summarized, we have three independent variables:  animal ,  eye_movement_size , and  vegetable , with the latter two being correlated. Important By construction, there is no  vegetable  effect in the data! All effects we find for vegetable solely come from the correlation with  eye_movement_size  - Now imagine decoding vegetable, you would find a strong  spurious  effect."},{"id":780,"pagetitle":"Why Back2Back","title":"Making it multi channel","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/explanations/b2b_why/#Making-it-multi-channel","content":" Making it multi channel Decoding is multivariate, so we need multiple channels. For simplicity, we just repeat the data 20 times, representing 20 channels. dat_3d = permutedims(repeat(dat, 1, 1, 20), [3 1 2]);\ndat_3d .+= 0.1 * rand(size(dat_3d)...);"},{"id":781,"pagetitle":"Why Back2Back","title":"Solver selection","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/explanations/b2b_why/#Solver-selection","content":" Solver selection b2b_solver = (x, y) -> UnfoldDecode.solver_b2b(x, y; cross_val_reps = 5);"},{"id":782,"pagetitle":"Why Back2Back","title":"Fitting function","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/explanations/b2b_why/#Fitting-function","content":" Fitting function Because we want to compare different scenarios involving different variables, we define a function to estimate them. function run_b2b(f)\n    # Define a design dictionary according to the formula\n    times = range(0, 0.44, step = 1 / 100)\n    designDict = [Any => (f, times)]\n    # Fit the model\n    m = Unfold.fit(UnfoldModel, designDict, evts, dat_3d; solver = b2b_solver)\n\n    results = coeftable(m)\n    results.estimate = abs.(results.estimate)\n    results = results[results.coefname.!=\"(Intercept)\", :]\n    results.formula .= string(f)\n    return results\nend; let's run a decoder without accounting for the other factors results_all = map(\n    run_b2b,\n    [\n        @formula(0 ~ 1 + animal),\n        @formula(0 ~ 1 + vegetable),\n        @formula(0 ~ 1 + eye_movement_size)\n    ],\n)\nplot_erp(vcat(results_all...); axis = (xlabel = \"Time [s]\", ylabel = \"Performance\")) As one can see, all three variables can be decoded well.  Even though vegetable had no effect on the data!! Let's now use B2B to take into account the correlation between  vegetable  and  eye_movement_size : results_all = map(\n    run_b2b,\n    [@formula(0 ~ 1 + vegetable), @formula(0 ~ 1 + vegetable + eye_movement_size)],\n)\nplot_erp(\n    vcat(results_all...);\n    mapping = (; color = :coefname, row = :formula),\n    axis = (xlabel = \"Time [s]\", ylabel = \"Performance\"),\n) As can be seen, when modelling both effects (lower plot), the vegetable effect (correctly and as intended) vanishes. We now learned, that decodable information is only in   eye_movement_size , but not  vegetable , which is \"just\" correlated For completeness sake, we also include the comparison to a non-correlated effect results_all = map(\n    run_b2b,\n    [@formula(0 ~ 1 + animal), @formula(0 ~ 1 + animal + vegetable + eye_movement_size)],\n)\nplot_erp(\n    vcat(results_all...);\n    mapping = (; color = :coefname, row = :formula),\n    axis = (xlabel = \"Time [s]\", ylabel = \"Performance\"),\n) the animal effect remains untouched :) This page was generated using  Literate.jl ."},{"id":785,"pagetitle":"Algorithm choice","title":"Comparison of different solvers for G and H","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/reference/b2b_algorithms/#Comparison-of-different-solvers-for-G-and-H","content":" Comparison of different solvers for G and H Let's prepare some data again dat, evts = UnfoldSim.predef_eeg(; noiselevel = 0.1, return_epoched = true);\ndat_3d = permutedims(repeat(dat, 1, 1, 20), [3 1 2]);\ndat_3d .+= range(5, 20, size(dat_3d, 1)) .* rand(size(dat_3d)...); # vary the noise per channel\nevts.correlated .=\n    [\"tomato\", \"carrot\"][1 .+ (evts.continuous.+10 .* rand(size(evts, 1)).>7.5)];"},{"id":786,"pagetitle":"Algorithm choice","title":"Comparison of the results from different regression methods","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/reference/b2b_algorithms/#Comparison-of-the-results-from-different-regression-methods","content":" Comparison of the results from different regression methods function run_b2b(solver_G, solver_H; kwargs...)\n    b2b_solver = (x, y) -> UnfoldDecode.solver_b2b(x, y; solver_G, solver_H, kwargs...)\n\n    f = @formula(0 ~ 1 + condition + continuous + correlated)\n    # Define a design dictionary according to the formula\n    times = range(0, 0.44, step = 1 / 100)\n    designDict = [Any => (f, times)]\n    # Fit the model\n    m = Unfold.fit(UnfoldModel, designDict, evts, dat_3d; solver = b2b_solver)\n\n    results = coeftable(m)\n    results.estimate = abs.(results.estimate)\n    results = results[results.coefname.!=\"(Intercept)\", :]\n    results.solver_G .= string(solver_G)\n    results.solver_H .= string(solver_H)\n    return results\nend;\n\nrun_models(list) = vcat(map(m -> run_b2b(m...; multithreading = true), list)...)\nresults_all = run_models([\n    [UnfoldDecode.model_lsq, UnfoldDecode.model_lsq],\n    [UnfoldDecode.model_xgboost, UnfoldDecode.model_lsq],\n    [UnfoldDecode.model_ridge, UnfoldDecode.model_ridge],\n    [UnfoldDecode.model_ridge, UnfoldDecode.model_lsq],\n])\n\nplot_erp(\n    results_all;\n    mapping = (; col = :solver_G, row = :solver_H),\n    xis = (xlabel = \"Time [s]\", ylabel = \"Performance\"),\n) Not all combinations are calculated due to time reason. This page was generated using  Literate.jl ."},{"id":789,"pagetitle":"Quick Start b2b","title":"Setup","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/b2b_quickstart/#Setup","content":" Setup using Unfold\nusing UnfoldMakie, CairoMakie\nusing UnfoldSim\nusing UnfoldDecode\nusing DataFrames\nusing Statistics"},{"id":790,"pagetitle":"Quick Start b2b","title":"Quick start of Back-To-Back (b2b)","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/b2b_quickstart/#quickstart-b2b","content":" Quick start of Back-To-Back (b2b)"},{"id":791,"pagetitle":"Quick Start b2b","title":"Data generation","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/b2b_quickstart/#Data-generation","content":" Data generation"},{"id":792,"pagetitle":"Quick Start b2b","title":"Simulation and data collection","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/b2b_quickstart/#Simulation-and-data-collection","content":" Simulation and data collection Generate single channel data via UnfoldSim.jl dat, evts = UnfoldSim.predef_eeg(; noiselevel = 0.1, return_epoched = true); dat  is a time x repetition Matrix,  evts  is a  DataFrame `with independent variables / features to explain the data"},{"id":793,"pagetitle":"Quick Start b2b","title":"Dimension expansion","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/b2b_quickstart/#Dimension-expansion","content":" Dimension expansion Repeat the dat 20 times, representing 20 channels. In the future we will replace this with a direct multi-channel simulation. dat_3d = permutedims(repeat(dat, 1, 1, 20), [3 1 2]); Channels shouldnt be identical, so we add some noise. dat_3d .+= 0.1 * rand(size(dat_3d)...);"},{"id":794,"pagetitle":"Quick Start b2b","title":"Modeling","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/b2b_quickstart/#Modeling","content":" Modeling"},{"id":795,"pagetitle":"Quick Start b2b","title":"Solver selection","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/b2b_quickstart/#Solver-selection","content":" Solver selection Call b2b solver in UnfoldDecode b2b_solver = (x, y) -> UnfoldDecode.solver_b2b(x, y; cross_val_reps = 5); Hint one could specify the specific solvers for G and H by passing the  solver_G  and  solver_H  parameters to the  solver_b2b  function. Implemented solvers are ridge, lasso, lsq, svm, but other solvers from MLJ.jl can be used as well."},{"id":796,"pagetitle":"Quick Start b2b","title":"Generate the formula","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/b2b_quickstart/#Generate-the-formula","content":" Generate the formula We want to decode  condition , but simultaneously control for the effect of  continuous . f = @formula 0 ~ 1 + condition + continuous\ntime = range(0, 0.44, step = 1 / 100)\ndesignDict = [Any => (f, time)]\n\nm = Unfold.fit(UnfoldModel, designDict, evts, dat_3d; solver = b2b_solver);\n\nresults = coeftable(m);\nresults.estimate = abs.(results.estimate); ## back2back has no sign\nresults = results[results.coefname.!=\"(Intercept)\", :] ## the intercept in b2b is hard to interpret 90×7 DataFrame Row channel coefname estimate eventname group stderror time Int64 String Float64 DataType Nothing Nothing Float64 1 1 condition: face 0.000276096 Any 0.0 2 1 condition: face 0.00121805 Any 0.01 3 1 condition: face 0.00905281 Any 0.02 4 1 condition: face 0.00492913 Any 0.03 5 1 condition: face 0.000306879 Any 0.04 6 1 condition: face 0.0011858 Any 0.05 7 1 condition: face 0.00734451 Any 0.06 8 1 condition: face 0.00833586 Any 0.07 9 1 condition: face 0.00952535 Any 0.08 10 1 condition: face 0.00563764 Any 0.09 11 1 condition: face 0.0590155 Any 0.1 12 1 condition: face 0.187331 Any 0.11 13 1 condition: face 0.576066 Any 0.12 14 1 condition: face 0.304674 Any 0.13 15 1 condition: face 0.269461 Any 0.14 16 1 condition: face 0.27268 Any 0.15 17 1 condition: face 0.27276 Any 0.16 18 1 condition: face 0.286085 Any 0.17 19 1 condition: face 0.310983 Any 0.18 20 1 condition: face 0.389116 Any 0.19 21 1 condition: face 0.0400523 Any 0.2 22 1 condition: face 0.0209925 Any 0.21 23 1 condition: face 0.00728841 Any 0.22 24 1 condition: face 0.00631977 Any 0.23 25 1 condition: face 0.00666009 Any 0.24 26 1 condition: face 0.00641612 Any 0.25 27 1 condition: face 0.00634659 Any 0.26 28 1 condition: face 0.00605966 Any 0.27 29 1 condition: face 0.0064253 Any 0.28 30 1 condition: face 0.00661277 Any 0.29 31 1 condition: face 0.00657537 Any 0.3 32 1 condition: face 0.0062685 Any 0.31 33 1 condition: face 0.00681632 Any 0.32 34 1 condition: face 0.00674751 Any 0.33 35 1 condition: face 0.00723387 Any 0.34 36 1 condition: face 0.00693519 Any 0.35 37 1 condition: face 0.00673979 Any 0.36 38 1 condition: face 0.00701447 Any 0.37 39 1 condition: face 0.00625599 Any 0.38 40 1 condition: face 0.00684818 Any 0.39 41 1 condition: face 0.00893697 Any 0.4 42 1 condition: face 0.00750376 Any 0.41 43 1 condition: face 0.0104718 Any 0.42 44 1 condition: face 0.024929 Any 0.43 45 1 condition: face 0.0225599 Any 0.44 46 1 continuous 0.000147515 Any 0.0 47 1 continuous 6.21685e-5 Any 0.01 48 1 continuous 0.000455905 Any 0.02 49 1 continuous 4.37426e-5 Any 0.03 50 1 continuous 0.000123742 Any 0.04 51 1 continuous 1.94433e-5 Any 0.05 52 1 continuous 8.24115e-5 Any 0.06 53 1 continuous 1.53654e-6 Any 0.07 54 1 continuous 7.52518e-6 Any 0.08 55 1 continuous 0.00014592 Any 0.09 56 1 continuous 8.25061e-7 Any 0.1 57 1 continuous 0.000104262 Any 0.11 58 1 continuous 5.49448e-6 Any 0.12 59 1 continuous 0.0001882 Any 0.13 60 1 continuous 1.16102e-6 Any 0.14 61 1 continuous 6.31581e-5 Any 0.15 62 1 continuous 1.56448e-6 Any 0.16 63 1 continuous 0.000599661 Any 0.17 64 1 continuous 0.00728231 Any 0.18 65 1 continuous 0.0978105 Any 0.19 66 1 continuous 0.854214 Any 0.2 67 1 continuous 0.355671 Any 0.21 68 1 continuous 0.282977 Any 0.22 69 1 continuous 0.285093 Any 0.23 70 1 continuous 0.278331 Any 0.24 71 1 continuous 0.282962 Any 0.25 72 1 continuous 0.284605 Any 0.26 73 1 continuous 0.284962 Any 0.27 74 1 continuous 0.283158 Any 0.28 75 1 continuous 0.281591 Any 0.29 76 1 continuous 0.284366 Any 0.3 77 1 continuous 0.282344 Any 0.31 78 1 continuous 0.284764 Any 0.32 79 1 continuous 0.285409 Any 0.33 80 1 continuous 0.281967 Any 0.34 81 1 continuous 0.280067 Any 0.35 82 1 continuous 0.281299 Any 0.36 83 1 continuous 0.274928 Any 0.37 84 1 continuous 0.278807 Any 0.38 85 1 continuous 0.267941 Any 0.39 86 1 continuous 0.259431 Any 0.4 87 1 continuous 0.239387 Any 0.41 88 1 continuous 0.1926 Any 0.42 89 1 continuous 0.0523001 Any 0.43 90 1 continuous 0.000115614 Any 0.44"},{"id":797,"pagetitle":"Quick Start b2b","title":"Plotting","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/b2b_quickstart/#Plotting","content":" Plotting plot_erp(results; axis = (xlabel = \"Time [s]\", ylabel = \"Performance\")) We can see from the graph that b2b solver identifies regions where the signal can be decoded, taking into account the  continuous  feature This page was generated using  Literate.jl ."},{"id":800,"pagetitle":"Overlap corrected LDA","title":"Overlap-corrected decoding tutorial","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/overlapcorrectedLDA/#tutorial-overlap-decoding","content":" Overlap-corrected decoding tutorial This approach follows the work of the Deoulle Group, especially Gal Vishne's work as published 2023: https://doi.org/10.1101/2023.06.28.546397"},{"id":801,"pagetitle":"Overlap corrected LDA","title":"Simulation","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/overlapcorrectedLDA/#Simulation","content":" Simulation We start with simulating some continuous, overlapping data with two conditions. As of now,  UnfoldSim  doesnt support multichannel, so we simply repeat the channel and add some noise` dat, evt = UnfoldSim.predef_eeg()\ndat = repeat(dat', 5)\ndat .= dat .+ 20 .* rand(size(dat)...) 5×120199 Matrix{Float64}:\n  4.47017   4.14245   2.84318   3.5998   …  10.1947    1.6747  10.6637\n 19.3169   17.2812   20.3574   13.0755      13.3753   14.8961   1.75375\n 16.3673   20.0926    4.53176   3.94819      3.58889   2.07     7.6664\n  2.92952   4.32864  19.346     4.76091      8.54636  18.5658   5.1866\n  5.8916   12.9058   16.3997   14.4299      13.5615   12.2012   8.2243"},{"id":802,"pagetitle":"Overlap corrected LDA","title":"Overlap-model Definition","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/overlapcorrectedLDA/#Overlap-model-Definition","content":" Overlap-model Definition We have to define what model we want to use for overlap correction We decide for a one-basisfunction model, with one one condition and one covariate, from  -0.1  to  0.5  seconds afte the stimulus onset. Sampling rate  100  as in the simulation des = [Any => (@formula(0 ~ 1 + condition + continuous), firbasis((-0.1, 1.0), 100))]; Fitting and visualizing a single channel of the model uf = Unfold.fit(UnfoldModel, des, evt, dat[1, :]);\nplot_erp(coeftable(uf))"},{"id":803,"pagetitle":"Overlap corrected LDA","title":"Fitting the Overlap-corrected LDA model","ref":"/UnfoldDocs/UnfoldDecode.jl/stable/generated/tutorials/overlapcorrectedLDA/#Fitting-the-Overlap-corrected-LDA-model","content":" Fitting the Overlap-corrected LDA model Following the  MLJ Modelzoo  we have to do the following to load an LDA model using MLJ, MultivariateStats, MLJMultivariateStatsInterface\nLDA = @load LDA pkg = MultivariateStats\nuf_lda =\n    Unfold.fit(UnfoldDecodingModel, des, evt, dat, LDA(), Any => :condition; nfolds = 2) # 2 folds to speed up computation\nplot_erp(coeftable(uf_lda); mapping = (; color = :coefname)) Voila, the model classified the correct period. This page was generated using  Literate.jl ."}]